//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
// Source maps are supported by all recent versions of Chrome, Safari,  //
// and Firefox, and by Internet Explorer 11.                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var global = Package.meteor.global;
var meteorEnv = Package.meteor.meteorEnv;

/* Package-scope variables */
var wantedIndent, TextAlignMap;

(function(){

///////////////////////////////////////////////////////////////////////
//                                                                   //
// packages/chipcastledotcom_jspdf/packages/chipcastledotcom_jspdf.j //
//                                                                   //
///////////////////////////////////////////////////////////////////////
                                                                     //
(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/chipcastledotcom:jspdf/jsPDF/dist/jspdf.debug.js                                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/** @preserve                                                                                                          // 1
 * jsPDF - PDF Document creation from JavaScript                                                                       // 2
 * Version 1.0.272-git Built on 2014-09-29T15:09                                                                       // 3
 *                           CommitID d4770725ca                                                                       // 4
 *                                                                                                                     // 5
 * Copyright (c) 2010-2014 James Hall, https://github.com/MrRio/jsPDF                                                  // 6
 *               2010 Aaron Spike, https://github.com/acspike                                                          // 7
 *               2012 Willow Systems Corporation, willow-systems.com                                                   // 8
 *               2012 Pablo Hess, https://github.com/pablohess                                                         // 9
 *               2012 Florian Jenett, https://github.com/fjenett                                                       // 10
 *               2013 Warren Weckesser, https://github.com/warrenweckesser                                             // 11
 *               2013 Youssef Beddad, https://github.com/lifof                                                         // 12
 *               2013 Lee Driscoll, https://github.com/lsdriscoll                                                      // 13
 *               2013 Stefan Slonevskiy, https://github.com/stefslon                                                   // 14
 *               2013 Jeremy Morel, https://github.com/jmorel                                                          // 15
 *               2013 Christoph Hartmann, https://github.com/chris-rock                                                // 16
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria                                              // 17
 *               2014 James Makes, https://github.com/dollaruw                                                         // 18
 *               2014 Diego Casorran, https://github.com/diegocr                                                       // 19
 *                                                                                                                     // 20
 * Permission is hereby granted, free of charge, to any person obtaining                                               // 21
 * a copy of this software and associated documentation files (the                                                     // 22
 * "Software"), to deal in the Software without restriction, including                                                 // 23
 * without limitation the rights to use, copy, modify, merge, publish,                                                 // 24
 * distribute, sublicense, and/or sell copies of the Software, and to                                                  // 25
 * permit persons to whom the Software is furnished to do so, subject to                                               // 26
 * the following conditions:                                                                                           // 27
 *                                                                                                                     // 28
 * The above copyright notice and this permission notice shall be                                                      // 29
 * included in all copies or substantial portions of the Software.                                                     // 30
 *                                                                                                                     // 31
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,                                                     // 32
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                  // 33
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                                                               // 34
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE                                              // 35
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION                                              // 36
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION                                               // 37
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                                     // 38
 *                                                                                                                     // 39
 * Contributor(s):                                                                                                     // 40
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,                                                       // 41
 *    kim3er, mfo, alnorth,                                                                                            // 42
 */                                                                                                                    // 43
                                                                                                                       // 44
/**                                                                                                                    // 45
 * Creates new jsPDF document object instance.                                                                         // 46
 *                                                                                                                     // 47
 * @class                                                                                                              // 48
 * @param orientation One of "portrait" or "landscape" (or shortcuts "p" (Default), "l")                               // 49
 * @param unit        Measurement unit to be used when coordinates are specified.                                      // 50
 *                    One of "pt" (points), "mm" (Default), "cm", "in"                                                 // 51
 * @param format      One of 'pageFormats' as shown below, default: a4                                                 // 52
 * @returns {jsPDF}                                                                                                    // 53
 * @name jsPDF                                                                                                         // 54
 */                                                                                                                    // 55
var jsPDF = (function(global) {                                                                                        // 56
	'use strict';                                                                                                         // 57
	var pdfVersion = '1.3',                                                                                               // 58
		pageFormats = { // Size in pt of various paper formats                                                               // 59
			'a0'  : [2383.94, 3370.39], 'a1'  : [1683.78, 2383.94],                                                             // 60
			'a2'  : [1190.55, 1683.78], 'a3'  : [ 841.89, 1190.55],                                                             // 61
			'a4'  : [ 595.28,  841.89], 'a5'  : [ 419.53,  595.28],                                                             // 62
			'a6'  : [ 297.64,  419.53], 'a7'  : [ 209.76,  297.64],                                                             // 63
			'a8'  : [ 147.40,  209.76], 'a9'  : [ 104.88,  147.40],                                                             // 64
			'a10' : [  73.70,  104.88], 'b0'  : [2834.65, 4008.19],                                                             // 65
			'b1'  : [2004.09, 2834.65], 'b2'  : [1417.32, 2004.09],                                                             // 66
			'b3'  : [1000.63, 1417.32], 'b4'  : [ 708.66, 1000.63],                                                             // 67
			'b5'  : [ 498.90,  708.66], 'b6'  : [ 354.33,  498.90],                                                             // 68
			'b7'  : [ 249.45,  354.33], 'b8'  : [ 175.75,  249.45],                                                             // 69
			'b9'  : [ 124.72,  175.75], 'b10' : [  87.87,  124.72],                                                             // 70
			'c0'  : [2599.37, 3676.54], 'c1'  : [1836.85, 2599.37],                                                             // 71
			'c2'  : [1298.27, 1836.85], 'c3'  : [ 918.43, 1298.27],                                                             // 72
			'c4'  : [ 649.13,  918.43], 'c5'  : [ 459.21,  649.13],                                                             // 73
			'c6'  : [ 323.15,  459.21], 'c7'  : [ 229.61,  323.15],                                                             // 74
			'c8'  : [ 161.57,  229.61], 'c9'  : [ 113.39,  161.57],                                                             // 75
			'c10' : [  79.37,  113.39], 'dl'  : [ 311.81,  623.62],                                                             // 76
			'letter'            : [612,   792],                                                                                 // 77
			'government-letter' : [576,   756],                                                                                 // 78
			'legal'             : [612,  1008],                                                                                 // 79
			'junior-legal'      : [576,   360],                                                                                 // 80
			'ledger'            : [1224,  792],                                                                                 // 81
			'tabloid'           : [792,  1224],                                                                                 // 82
			'credit-card'       : [153,   243]                                                                                  // 83
		};                                                                                                                   // 84
                                                                                                                       // 85
	/**                                                                                                                   // 86
	 * jsPDF's Internal PubSub Implementation.                                                                            // 87
	 * See mrrio.github.io/jsPDF/doc/symbols/PubSub.html                                                                  // 88
	 * Backward compatible rewritten on 2014 by                                                                           // 89
	 * Diego Casorran, https://github.com/diegocr                                                                         // 90
	 *                                                                                                                    // 91
	 * @class                                                                                                             // 92
	 * @name PubSub                                                                                                       // 93
	 */                                                                                                                   // 94
	function PubSub(context) {                                                                                            // 95
		var topics = {};                                                                                                     // 96
                                                                                                                       // 97
		this.subscribe = function(topic, callback, once) {                                                                   // 98
			if(typeof callback !== 'function') {                                                                                // 99
				return false;                                                                                                      // 100
			}                                                                                                                   // 101
                                                                                                                       // 102
			if(!topics.hasOwnProperty(topic)) {                                                                                 // 103
				topics[topic] = {};                                                                                                // 104
			}                                                                                                                   // 105
                                                                                                                       // 106
			var id = Math.random().toString(35);                                                                                // 107
			topics[topic][id] = [callback,!!once];                                                                              // 108
                                                                                                                       // 109
			return id;                                                                                                          // 110
		};                                                                                                                   // 111
                                                                                                                       // 112
		this.unsubscribe = function(token) {                                                                                 // 113
			for(var topic in topics) {                                                                                          // 114
				if(topics[topic][token]) {                                                                                         // 115
					delete topics[topic][token];                                                                                      // 116
					return true;                                                                                                      // 117
				}                                                                                                                  // 118
			}                                                                                                                   // 119
			return false;                                                                                                       // 120
		};                                                                                                                   // 121
                                                                                                                       // 122
		this.publish = function(topic) {                                                                                     // 123
			if(topics.hasOwnProperty(topic)) {                                                                                  // 124
				var args = Array.prototype.slice.call(arguments, 1), idr = [];                                                     // 125
                                                                                                                       // 126
				for(var id in topics[topic]) {                                                                                     // 127
					var sub = topics[topic][id];                                                                                      // 128
					try {                                                                                                             // 129
						sub[0].apply(context, args);                                                                                     // 130
					} catch(ex) {                                                                                                     // 131
						if(global.console) {                                                                                             // 132
							console.error('jsPDF PubSub Error', ex.message, ex);                                                            // 133
						}                                                                                                                // 134
					}                                                                                                                 // 135
					if(sub[1]) idr.push(id);                                                                                          // 136
				}                                                                                                                  // 137
				if(idr.length) idr.forEach(this.unsubscribe);                                                                      // 138
			}                                                                                                                   // 139
		};                                                                                                                   // 140
	}                                                                                                                     // 141
                                                                                                                       // 142
	/**                                                                                                                   // 143
	 * @constructor                                                                                                       // 144
	 * @private                                                                                                           // 145
	 */                                                                                                                   // 146
	function jsPDF(orientation, unit, format, compressPdf) {                                                              // 147
		var options = {};                                                                                                    // 148
                                                                                                                       // 149
		if (typeof orientation === 'object') {                                                                               // 150
			options = orientation;                                                                                              // 151
                                                                                                                       // 152
			orientation = options.orientation;                                                                                  // 153
			unit = options.unit || unit;                                                                                        // 154
			format = options.format || format;                                                                                  // 155
			compressPdf = options.compress || options.compressPdf || compressPdf;                                               // 156
		}                                                                                                                    // 157
                                                                                                                       // 158
		// Default options                                                                                                   // 159
		unit        = unit || 'mm';                                                                                          // 160
		format      = format || 'a4';                                                                                        // 161
		orientation = ('' + (orientation || 'P')).toLowerCase();                                                             // 162
                                                                                                                       // 163
		var format_as_string = ('' + format).toLowerCase(),                                                                  // 164
			compress = !!compressPdf && typeof Uint8Array === 'function',                                                       // 165
			textColor            = options.textColor  || '0 g',                                                                 // 166
			drawColor            = options.drawColor  || '0 G',                                                                 // 167
			activeFontSize       = options.fontSize   || 16,                                                                    // 168
			lineHeightProportion = options.lineHeight || 1.15,                                                                  // 169
			lineWidth            = options.lineWidth  || 0.200025, // 2mm                                                       // 170
			objectNumber =  2,  // 'n' Current object number                                                                    // 171
			outToPages   = !1,  // switches where out() prints. outToPages true = push to pages obj. outToPages false = doc builder content
			offsets      = [],  // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.
			fonts        = {},  // collection of font objects, where key is fontKey - a dynamically created label for a given font.
			fontmap      = {},  // mapping structure fontName > fontStyle > font key - performance layer. See addFont()         // 175
			activeFontKey,      // will be string representing the KEY of the font as combination of fontName + fontStyle       // 176
			k,                  // Scale factor                                                                                 // 177
			tmp,                                                                                                                // 178
			page = 0,                                                                                                           // 179
			currentPage,                                                                                                        // 180
			pages = [],                                                                                                         // 181
			pagedim = {},                                                                                                       // 182
			content = [],                                                                                                       // 183
			lineCapID = 0,                                                                                                      // 184
			lineJoinID = 0,                                                                                                     // 185
			content_length = 0,                                                                                                 // 186
			pageWidth,                                                                                                          // 187
			pageHeight,                                                                                                         // 188
			pageMode,                                                                                                           // 189
			zoomMode,                                                                                                           // 190
			layoutMode,                                                                                                         // 191
			documentProperties = {                                                                                              // 192
				'title'    : '',                                                                                                   // 193
				'subject'  : '',                                                                                                   // 194
				'author'   : '',                                                                                                   // 195
				'keywords' : '',                                                                                                   // 196
				'creator'  : ''                                                                                                    // 197
			},                                                                                                                  // 198
			API = {},                                                                                                           // 199
			events = new PubSub(API),                                                                                           // 200
                                                                                                                       // 201
		/////////////////////                                                                                                // 202
		// Private functions                                                                                                 // 203
		/////////////////////                                                                                                // 204
		f2 = function(number) {                                                                                              // 205
			return number.toFixed(2); // Ie, %.2f                                                                               // 206
		},                                                                                                                   // 207
		f3 = function(number) {                                                                                              // 208
			return number.toFixed(3); // Ie, %.3f                                                                               // 209
		},                                                                                                                   // 210
		padd2 = function(number) {                                                                                           // 211
			return ('0' + parseInt(number)).slice(-2);                                                                          // 212
		},                                                                                                                   // 213
		out = function(string) {                                                                                             // 214
			if (outToPages) {                                                                                                   // 215
				/* set by beginPage */                                                                                             // 216
				pages[currentPage].push(string);                                                                                   // 217
			} else {                                                                                                            // 218
				// +1 for '\n' that will be used to join 'content'                                                                 // 219
				content_length += string.length + 1;                                                                               // 220
				content.push(string);                                                                                              // 221
			}                                                                                                                   // 222
		},                                                                                                                   // 223
		newObject = function() {                                                                                             // 224
			// Begin a new object                                                                                               // 225
			objectNumber++;                                                                                                     // 226
			offsets[objectNumber] = content_length;                                                                             // 227
			out(objectNumber + ' 0 obj');                                                                                       // 228
			return objectNumber;                                                                                                // 229
		},                                                                                                                   // 230
		putStream = function(str) {                                                                                          // 231
			out('stream');                                                                                                      // 232
			out(str);                                                                                                           // 233
			out('endstream');                                                                                                   // 234
		},                                                                                                                   // 235
		putPages = function() {                                                                                              // 236
			var n,p,arr,i,deflater,adler32,adler32cs,wPt,hPt;                                                                   // 237
                                                                                                                       // 238
			adler32cs = global.adler32cs || jsPDF.adler32cs;                                                                    // 239
			if (compress && typeof adler32cs === 'undefined') {                                                                 // 240
				compress = false;                                                                                                  // 241
			}                                                                                                                   // 242
                                                                                                                       // 243
			// outToPages = false as set in endDocument(). out() writes to content.                                             // 244
                                                                                                                       // 245
			for (n = 1; n <= page; n++) {                                                                                       // 246
				newObject();                                                                                                       // 247
				wPt = (pageWidth = pagedim[n].width) * k;                                                                          // 248
				hPt = (pageHeight = pagedim[n].height) * k;                                                                        // 249
				out('<</Type /Page');                                                                                              // 250
				out('/Parent 1 0 R');                                                                                              // 251
				out('/Resources 2 0 R');                                                                                           // 252
				out('/MediaBox [0 0 ' + f2(wPt) + ' ' + f2(hPt) + ']');                                                            // 253
				out('/Contents ' + (objectNumber + 1) + ' 0 R>>');                                                                 // 254
				out('endobj');                                                                                                     // 255
                                                                                                                       // 256
				// Page content                                                                                                    // 257
				p = pages[n].join('\n');                                                                                           // 258
				newObject();                                                                                                       // 259
				if (compress) {                                                                                                    // 260
					arr = [];                                                                                                         // 261
					i = p.length;                                                                                                     // 262
					while(i--) {                                                                                                      // 263
						arr[i] = p.charCodeAt(i);                                                                                        // 264
					}                                                                                                                 // 265
					adler32 = adler32cs.from(p);                                                                                      // 266
					deflater = new Deflater(6);                                                                                       // 267
					deflater.append(new Uint8Array(arr));                                                                             // 268
					p = deflater.flush();                                                                                             // 269
					arr = new Uint8Array(p.length + 6);                                                                               // 270
					arr.set(new Uint8Array([120, 156])),                                                                              // 271
					arr.set(p, 2);                                                                                                    // 272
					arr.set(new Uint8Array([adler32 & 0xFF, (adler32 >> 8) & 0xFF, (adler32 >> 16) & 0xFF, (adler32 >> 24) & 0xFF]), p.length+2);
					p = String.fromCharCode.apply(null, arr);                                                                         // 274
					out('<</Length ' + p.length + ' /Filter [/FlateDecode]>>');                                                       // 275
				} else {                                                                                                           // 276
					out('<</Length ' + p.length + '>>');                                                                              // 277
				}                                                                                                                  // 278
				putStream(p);                                                                                                      // 279
				out('endobj');                                                                                                     // 280
			}                                                                                                                   // 281
			offsets[1] = content_length;                                                                                        // 282
			out('1 0 obj');                                                                                                     // 283
			out('<</Type /Pages');                                                                                              // 284
			var kids = '/Kids [';                                                                                               // 285
			for (i = 0; i < page; i++) {                                                                                        // 286
				kids += (3 + 2 * i) + ' 0 R ';                                                                                     // 287
			}                                                                                                                   // 288
			out(kids + ']');                                                                                                    // 289
			out('/Count ' + page);                                                                                              // 290
			out('>>');                                                                                                          // 291
			out('endobj');                                                                                                      // 292
		},                                                                                                                   // 293
		putFont = function(font) {                                                                                           // 294
			font.objectNumber = newObject();                                                                                    // 295
			out('<</BaseFont/' + font.PostScriptName + '/Type/Font');                                                           // 296
			if (typeof font.encoding === 'string') {                                                                            // 297
				out('/Encoding/' + font.encoding);                                                                                 // 298
			}                                                                                                                   // 299
			out('/Subtype/Type1>>');                                                                                            // 300
			out('endobj');                                                                                                      // 301
		},                                                                                                                   // 302
		putFonts = function() {                                                                                              // 303
			for (var fontKey in fonts) {                                                                                        // 304
				if (fonts.hasOwnProperty(fontKey)) {                                                                               // 305
					putFont(fonts[fontKey]);                                                                                          // 306
				}                                                                                                                  // 307
			}                                                                                                                   // 308
		},                                                                                                                   // 309
		putXobjectDict = function() {                                                                                        // 310
			// Loop through images, or other data objects                                                                       // 311
			events.publish('putXobjectDict');                                                                                   // 312
		},                                                                                                                   // 313
		putResourceDictionary = function() {                                                                                 // 314
			out('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');                                                               // 315
			out('/Font <<');                                                                                                    // 316
                                                                                                                       // 317
			// Do this for each font, the '1' bit is the index of the font                                                      // 318
			for (var fontKey in fonts) {                                                                                        // 319
				if (fonts.hasOwnProperty(fontKey)) {                                                                               // 320
					out('/' + fontKey + ' ' + fonts[fontKey].objectNumber + ' 0 R');                                                  // 321
				}                                                                                                                  // 322
			}                                                                                                                   // 323
			out('>>');                                                                                                          // 324
			out('/XObject <<');                                                                                                 // 325
			putXobjectDict();                                                                                                   // 326
			out('>>');                                                                                                          // 327
		},                                                                                                                   // 328
		putResources = function() {                                                                                          // 329
			putFonts();                                                                                                         // 330
			events.publish('putResources');                                                                                     // 331
			// Resource dictionary                                                                                              // 332
			offsets[2] = content_length;                                                                                        // 333
			out('2 0 obj');                                                                                                     // 334
			out('<<');                                                                                                          // 335
			putResourceDictionary();                                                                                            // 336
			out('>>');                                                                                                          // 337
			out('endobj');                                                                                                      // 338
			events.publish('postPutResources');                                                                                 // 339
		},                                                                                                                   // 340
		addToFontDictionary = function(fontKey, fontName, fontStyle) {                                                       // 341
			// this is mapping structure for quick font key lookup.                                                             // 342
			// returns the KEY of the font (ex: "F1") for a given                                                               // 343
			// pair of font name and type (ex: "Arial". "Italic")                                                               // 344
			if (!fontmap.hasOwnProperty(fontName)) {                                                                            // 345
				fontmap[fontName] = {};                                                                                            // 346
			}                                                                                                                   // 347
			fontmap[fontName][fontStyle] = fontKey;                                                                             // 348
		},                                                                                                                   // 349
		/**                                                                                                                  // 350
		 * FontObject describes a particular font as member of an instnace of jsPDF                                          // 351
		 *                                                                                                                   // 352
		 * It's a collection of properties like 'id' (to be used in PDF stream),                                             // 353
		 * 'fontName' (font's family name), 'fontStyle' (font's style variant label)                                         // 354
		 *                                                                                                                   // 355
		 * @class                                                                                                            // 356
		 * @public                                                                                                           // 357
		 * @property id {String} PDF-document-instance-specific label assinged to the font.                                  // 358
		 * @property PostScriptName {String} PDF specification full name for the font                                        // 359
		 * @property encoding {Object} Encoding_name-to-Font_metrics_object mapping.                                         // 360
		 * @name FontObject                                                                                                  // 361
		 */                                                                                                                  // 362
		addFont = function(PostScriptName, fontName, fontStyle, encoding) {                                                  // 363
			var fontKey = 'F' + (Object.keys(fonts).length + 1).toString(10),                                                   // 364
			// This is FontObject                                                                                               // 365
			font = fonts[fontKey] = {                                                                                           // 366
				'id'             : fontKey,                                                                                        // 367
				'PostScriptName' : PostScriptName,                                                                                 // 368
				'fontName'       : fontName,                                                                                       // 369
				'fontStyle'      : fontStyle,                                                                                      // 370
				'encoding'       : encoding,                                                                                       // 371
				'metadata'       : {}                                                                                              // 372
			};                                                                                                                  // 373
			addToFontDictionary(fontKey, fontName, fontStyle);                                                                  // 374
			events.publish('addFont', font);                                                                                    // 375
                                                                                                                       // 376
			return fontKey;                                                                                                     // 377
		},                                                                                                                   // 378
		addFonts = function() {                                                                                              // 379
                                                                                                                       // 380
			var HELVETICA     = "helvetica",                                                                                    // 381
				TIMES         = "times",                                                                                           // 382
				COURIER       = "courier",                                                                                         // 383
				NORMAL        = "normal",                                                                                          // 384
				BOLD          = "bold",                                                                                            // 385
				ITALIC        = "italic",                                                                                          // 386
				BOLD_ITALIC   = "bolditalic",                                                                                      // 387
				encoding      = 'StandardEncoding',                                                                                // 388
				standardFonts = [                                                                                                  // 389
					['Helvetica', HELVETICA, NORMAL],                                                                                 // 390
					['Helvetica-Bold', HELVETICA, BOLD],                                                                              // 391
					['Helvetica-Oblique', HELVETICA, ITALIC],                                                                         // 392
					['Helvetica-BoldOblique', HELVETICA, BOLD_ITALIC],                                                                // 393
					['Courier', COURIER, NORMAL],                                                                                     // 394
					['Courier-Bold', COURIER, BOLD],                                                                                  // 395
					['Courier-Oblique', COURIER, ITALIC],                                                                             // 396
					['Courier-BoldOblique', COURIER, BOLD_ITALIC],                                                                    // 397
					['Times-Roman', TIMES, NORMAL],                                                                                   // 398
					['Times-Bold', TIMES, BOLD],                                                                                      // 399
					['Times-Italic', TIMES, ITALIC],                                                                                  // 400
					['Times-BoldItalic', TIMES, BOLD_ITALIC]                                                                          // 401
				];                                                                                                                 // 402
                                                                                                                       // 403
			for (var i = 0, l = standardFonts.length; i < l; i++) {                                                             // 404
				var fontKey = addFont(                                                                                             // 405
						standardFonts[i][0],                                                                                             // 406
						standardFonts[i][1],                                                                                             // 407
						standardFonts[i][2],                                                                                             // 408
						encoding);                                                                                                       // 409
                                                                                                                       // 410
				// adding aliases for standard fonts, this time matching the capitalization                                        // 411
				var parts = standardFonts[i][0].split('-');                                                                        // 412
				addToFontDictionary(fontKey, parts[0], parts[1] || '');                                                            // 413
			}                                                                                                                   // 414
			events.publish('addFonts', { fonts : fonts, dictionary : fontmap });                                                // 415
		},                                                                                                                   // 416
		SAFE = function __safeCall(fn) {                                                                                     // 417
			fn.foo = function __safeCallWrapper() {                                                                             // 418
				try {                                                                                                              // 419
					return fn.apply(this, arguments);                                                                                 // 420
				} catch (e) {                                                                                                      // 421
					var stack = e.stack || '';                                                                                        // 422
					if(~stack.indexOf(' at ')) stack = stack.split(" at ")[1];                                                        // 423
					var m = "Error in function " + stack.split("\n")[0].split('<')[0] + ": " + e.message;                             // 424
					if(global.console) {                                                                                              // 425
						global.console.error(m, e);                                                                                      // 426
						if(global.alert) alert(m);                                                                                       // 427
					} else {                                                                                                          // 428
						throw new Error(m);                                                                                              // 429
					}                                                                                                                 // 430
				}                                                                                                                  // 431
			};                                                                                                                  // 432
			fn.foo.bar = fn;                                                                                                    // 433
			return fn.foo;                                                                                                      // 434
		},                                                                                                                   // 435
		to8bitStream = function(text, flags) {                                                                               // 436
		/**                                                                                                                  // 437
		 * PDF 1.3 spec:                                                                                                     // 438
		 * "For text strings encoded in Unicode, the first two bytes must be 254 followed by                                 // 439
		 * 255, representing the Unicode byte order marker, U+FEFF. (This sequence conflicts                                 // 440
		 * with the PDFDocEncoding character sequence thorn ydieresis, which is unlikely                                     // 441
		 * to be a meaningful beginning of a word or phrase.) The remainder of the                                           // 442
		 * string consists of Unicode character codes, according to the UTF-16 encoding                                      // 443
		 * specified in the Unicode standard, version 2.0. Commonly used Unicode values                                      // 444
		 * are represented as 2 bytes per character, with the high-order byte appearing first                                // 445
		 * in the string."                                                                                                   // 446
		 *                                                                                                                   // 447
		 * In other words, if there are chars in a string with char code above 255, we                                       // 448
		 * recode the string to UCS2 BE - string doubles in length and BOM is prepended.                                     // 449
		 *                                                                                                                   // 450
		 * HOWEVER!                                                                                                          // 451
		 * Actual *content* (body) text (as opposed to strings used in document properties etc)                              // 452
		 * does NOT expect BOM. There, it is treated as a literal GID (Glyph ID)                                             // 453
		 *                                                                                                                   // 454
		 * Because of Adobe's focus on "you subset your fonts!" you are not supposed to have                                 // 455
		 * a font that maps directly Unicode (UCS2 / UTF16BE) code to font GID, but you could                                // 456
		 * fudge it with "Identity-H" encoding and custom CIDtoGID map that mimics Unicode                                   // 457
		 * code page. There, however, all characters in the stream are treated as GIDs,                                      // 458
		 * including BOM, which is the reason we need to skip BOM in content text (i.e. that                                 // 459
		 * that is tied to a font).                                                                                          // 460
		 *                                                                                                                   // 461
		 * To signal this "special" PDFEscape / to8bitStream handling mode,                                                  // 462
		 * API.text() function sets (unless you overwrite it with manual values                                              // 463
		 * given to API.text(.., flags) )                                                                                    // 464
		 * flags.autoencode = true                                                                                           // 465
		 * flags.noBOM = true                                                                                                // 466
		 *                                                                                                                   // 467
		 * ===================================================================================                               // 468
		 * `flags` properties relied upon:                                                                                   // 469
		 *   .sourceEncoding = string with encoding label.                                                                   // 470
		 *                     "Unicode" by default. = encoding of the incoming text.                                        // 471
		 *                     pass some non-existing encoding name                                                          // 472
		 *                     (ex: 'Do not touch my strings! I know what I am doing.')                                      // 473
		 *                     to make encoding code skip the encoding step.                                                 // 474
		 *   .outputEncoding = Either valid PDF encoding name                                                                // 475
		 *                     (must be supported by jsPDF font metrics, otherwise no encoding)                              // 476
		 *                     or a JS object, where key = sourceCharCode, value = outputCharCode                            // 477
		 *                     missing keys will be treated as: sourceCharCode === outputCharCode                            // 478
		 *   .noBOM                                                                                                          // 479
		 *       See comment higher above for explanation for why this is important                                          // 480
		 *   .autoencode                                                                                                     // 481
		 *       See comment higher above for explanation for why this is important                                          // 482
		 */                                                                                                                  // 483
                                                                                                                       // 484
			var i,l,sourceEncoding,encodingBlock,outputEncoding,newtext,isUnicode,ch,bch;                                       // 485
                                                                                                                       // 486
			flags = flags || {};                                                                                                // 487
			sourceEncoding = flags.sourceEncoding || 'Unicode';                                                                 // 488
			outputEncoding = flags.outputEncoding;                                                                              // 489
                                                                                                                       // 490
			// This 'encoding' section relies on font metrics format                                                            // 491
			// attached to font objects by, among others,                                                                       // 492
			// "Willow Systems' standard_font_metrics plugin"                                                                   // 493
			// see jspdf.plugin.standard_font_metrics.js for format                                                             // 494
			// of the font.metadata.encoding Object.                                                                            // 495
			// It should be something like                                                                                      // 496
			//   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}                                       // 497
			//   .widths = {0:width, code:width, ..., 'fof':divisor}                                                            // 498
			//   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}                                          // 499
			if ((flags.autoencode || outputEncoding) &&                                                                         // 500
				fonts[activeFontKey].metadata &&                                                                                   // 501
				fonts[activeFontKey].metadata[sourceEncoding] &&                                                                   // 502
				fonts[activeFontKey].metadata[sourceEncoding].encoding) {                                                          // 503
				encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;                                            // 504
                                                                                                                       // 505
				// each font has default encoding. Some have it clearly defined.                                                   // 506
				if (!outputEncoding && fonts[activeFontKey].encoding) {                                                            // 507
					outputEncoding = fonts[activeFontKey].encoding;                                                                   // 508
				}                                                                                                                  // 509
                                                                                                                       // 510
				// Hmmm, the above did not work? Let's try again, in different place.                                              // 511
				if (!outputEncoding && encodingBlock.codePages) {                                                                  // 512
					outputEncoding = encodingBlock.codePages[0]; // let's say, first one is the default                               // 513
				}                                                                                                                  // 514
                                                                                                                       // 515
				if (typeof outputEncoding === 'string') {                                                                          // 516
					outputEncoding = encodingBlock[outputEncoding];                                                                   // 517
				}                                                                                                                  // 518
				// we want output encoding to be a JS Object, where                                                                // 519
				// key = sourceEncoding's character code and                                                                       // 520
				// value = outputEncoding's character code.                                                                        // 521
				if (outputEncoding) {                                                                                              // 522
					isUnicode = false;                                                                                                // 523
					newtext = [];                                                                                                     // 524
					for (i = 0, l = text.length; i < l; i++) {                                                                        // 525
						ch = outputEncoding[text.charCodeAt(i)];                                                                         // 526
						if (ch) {                                                                                                        // 527
							newtext.push(                                                                                                   // 528
								String.fromCharCode(ch));                                                                                      // 529
						} else {                                                                                                         // 530
							newtext.push(                                                                                                   // 531
								text[i]);                                                                                                      // 532
						}                                                                                                                // 533
                                                                                                                       // 534
						// since we are looping over chars anyway, might as well                                                         // 535
						// check for residual unicodeness                                                                                // 536
						if (newtext[i].charCodeAt(0) >> 8) {                                                                             // 537
							/* more than 255 */                                                                                             // 538
							isUnicode = true;                                                                                               // 539
						}                                                                                                                // 540
					}                                                                                                                 // 541
					text = newtext.join('');                                                                                          // 542
				}                                                                                                                  // 543
			}                                                                                                                   // 544
                                                                                                                       // 545
			i = text.length;                                                                                                    // 546
			// isUnicode may be set to false above. Hence the triple-equal to undefined                                         // 547
			while (isUnicode === undefined && i !== 0) {                                                                        // 548
				if (text.charCodeAt(i - 1) >> 8) {                                                                                 // 549
					/* more than 255 */                                                                                               // 550
					isUnicode = true;                                                                                                 // 551
				}                                                                                                                  // 552
				i--;                                                                                                               // 553
			}                                                                                                                   // 554
			if (!isUnicode) {                                                                                                   // 555
				return text;                                                                                                       // 556
			}                                                                                                                   // 557
                                                                                                                       // 558
			newtext = flags.noBOM ? [] : [254, 255];                                                                            // 559
			for (i = 0, l = text.length; i < l; i++) {                                                                          // 560
				ch = text.charCodeAt(i);                                                                                           // 561
				bch = ch >> 8; // divide by 256                                                                                    // 562
				if (bch >> 8) {                                                                                                    // 563
					/* something left after dividing by 256 second time */                                                            // 564
					throw new Error("Character at position " + i + " of string '"                                                     // 565
						+ text + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");                                                   // 566
				}                                                                                                                  // 567
				newtext.push(bch);                                                                                                 // 568
				newtext.push(ch - (bch << 8));                                                                                     // 569
			}                                                                                                                   // 570
			return String.fromCharCode.apply(undefined, newtext);                                                               // 571
		},                                                                                                                   // 572
		pdfEscape = function(text, flags) {                                                                                  // 573
			/**                                                                                                                 // 574
			 * Replace '/', '(', and ')' with pdf-safe versions                                                                 // 575
			 *                                                                                                                  // 576
			 * Doing to8bitStream does NOT make this PDF display unicode text. For that                                         // 577
			 * we also need to reference a unicode font and embed it - royal pain in the rear.                                  // 578
			 *                                                                                                                  // 579
			 * There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,                                 // 580
			 * which JavaScript Strings are happy to provide. So, while we still cannot display                                 // 581
			 * 2-byte characters property, at least CONDITIONALLY converting (entire string containing)                         // 582
			 * 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF                               // 583
			 * is still parseable.                                                                                              // 584
			 * This will allow immediate support for unicode in document properties strings.                                    // 585
			 */                                                                                                                 // 586
			return to8bitStream(text, flags).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');                // 587
		},                                                                                                                   // 588
		putInfo = function() {                                                                                               // 589
			out('/Producer (jsPDF ' + jsPDF.version + ')');                                                                     // 590
			for(var key in documentProperties) {                                                                                // 591
				if(documentProperties.hasOwnProperty(key) && documentProperties[key]) {                                            // 592
					out('/'+key.substr(0,1).toUpperCase() + key.substr(1)                                                             // 593
						+' (' + pdfEscape(documentProperties[key]) + ')');                                                               // 594
				}                                                                                                                  // 595
			}                                                                                                                   // 596
			var created  = new Date(),                                                                                          // 597
				tzoffset = created.getTimezoneOffset(),                                                                            // 598
				tzsign   = tzoffset < 0 ? '+' : '-',                                                                               // 599
				tzhour   = Math.floor(Math.abs(tzoffset / 60)),                                                                    // 600
				tzmin    = Math.abs(tzoffset % 60),                                                                                // 601
				tzstr    = [tzsign, padd2(tzhour), "'", padd2(tzmin), "'"].join('');                                               // 602
			out(['/CreationDate (D:',                                                                                           // 603
					created.getFullYear(),                                                                                            // 604
					padd2(created.getMonth() + 1),                                                                                    // 605
					padd2(created.getDate()),                                                                                         // 606
					padd2(created.getHours()),                                                                                        // 607
					padd2(created.getMinutes()),                                                                                      // 608
					padd2(created.getSeconds()), tzstr, ')'].join(''));                                                               // 609
		},                                                                                                                   // 610
		putCatalog = function() {                                                                                            // 611
			out('/Type /Catalog');                                                                                              // 612
			out('/Pages 1 0 R');                                                                                                // 613
			// PDF13ref Section 7.2.1                                                                                           // 614
			if (!zoomMode) zoomMode = 'fullwidth';                                                                              // 615
			switch(zoomMode) {                                                                                                  // 616
				case 'fullwidth'  : out('/OpenAction [3 0 R /FitH null]');       break;                                            // 617
				case 'fullheight' : out('/OpenAction [3 0 R /FitV null]');       break;                                            // 618
				case 'fullpage'   : out('/OpenAction [3 0 R /Fit]');             break;                                            // 619
				case 'original'   : out('/OpenAction [3 0 R /XYZ null null 1]'); break;                                            // 620
				default:                                                                                                           // 621
					var pcn = '' + zoomMode;                                                                                          // 622
					if (pcn.substr(pcn.length-1) === '%')                                                                             // 623
						zoomMode = parseInt(zoomMode) / 100;                                                                             // 624
					if (typeof zoomMode === 'number') {                                                                               // 625
						out('/OpenAction [3 0 R /XYZ null null '+f2(zoomMode)+']');                                                      // 626
					}                                                                                                                 // 627
			}                                                                                                                   // 628
			if (!layoutMode) layoutMode = 'continuous';                                                                         // 629
			switch(layoutMode) {                                                                                                // 630
				case 'continuous' : out('/PageLayout /OneColumn');      break;                                                     // 631
				case 'single'     : out('/PageLayout /SinglePage');     break;                                                     // 632
				case 'two':                                                                                                        // 633
				case 'twoleft'    : out('/PageLayout /TwoColumnLeft');  break;                                                     // 634
				case 'tworight'   : out('/PageLayout /TwoColumnRight'); break;                                                     // 635
			}                                                                                                                   // 636
			if (pageMode) {                                                                                                     // 637
				/**                                                                                                                // 638
				 * A name object specifying how the document should be displayed when opened:                                      // 639
				 * UseNone      : Neither document outline nor thumbnail images visible -- DEFAULT                                 // 640
				 * UseOutlines  : Document outline visible                                                                         // 641
				 * UseThumbs    : Thumbnail images visible                                                                         // 642
				 * FullScreen   : Full-screen mode, with no menu bar, window controls, or any other window visible                 // 643
				 */                                                                                                                // 644
				out('/PageMode /' + pageMode);                                                                                     // 645
			}                                                                                                                   // 646
			events.publish('putCatalog');                                                                                       // 647
		},                                                                                                                   // 648
		putTrailer = function() {                                                                                            // 649
			out('/Size ' + (objectNumber + 1));                                                                                 // 650
			out('/Root ' + objectNumber + ' 0 R');                                                                              // 651
			out('/Info ' + (objectNumber - 1) + ' 0 R');                                                                        // 652
		},                                                                                                                   // 653
		beginPage = function(width,height) {                                                                                 // 654
			// Dimensions are stored as user units and converted to points on output                                            // 655
			var orientation = typeof height === 'string' && height.toLowerCase();                                               // 656
			if (typeof width === 'string') {                                                                                    // 657
				var format = width.toLowerCase();                                                                                  // 658
				if (pageFormats.hasOwnProperty(format)) {                                                                          // 659
					width  = pageFormats[format][0] / k;                                                                              // 660
					height = pageFormats[format][1] / k;                                                                              // 661
				}                                                                                                                  // 662
			}                                                                                                                   // 663
			if (Array.isArray(width)) {                                                                                         // 664
				height = width[1];                                                                                                 // 665
				width = width[0];                                                                                                  // 666
			}                                                                                                                   // 667
			if (orientation) {                                                                                                  // 668
				switch(orientation.substr(0,1)) {                                                                                  // 669
					case 'l': if (height > width ) orientation = 's'; break;                                                          // 670
					case 'p': if (width > height ) orientation = 's'; break;                                                          // 671
				}                                                                                                                  // 672
				if (orientation === 's') { tmp = width; width = height; height = tmp; }                                            // 673
			}                                                                                                                   // 674
			outToPages = true;                                                                                                  // 675
			pages[++page] = [];                                                                                                 // 676
			pagedim[page] = {                                                                                                   // 677
				width  : Number(width)  || pageWidth,                                                                              // 678
				height : Number(height) || pageHeight                                                                              // 679
			};                                                                                                                  // 680
			_setPage(page);                                                                                                     // 681
		},                                                                                                                   // 682
		_addPage = function() {                                                                                              // 683
			beginPage.apply(this, arguments);                                                                                   // 684
			// Set line width                                                                                                   // 685
			out(f2(lineWidth * k) + ' w');                                                                                      // 686
			// Set draw color                                                                                                   // 687
			out(drawColor);                                                                                                     // 688
			// resurrecting non-default line caps, joins                                                                        // 689
			if (lineCapID !== 0) {                                                                                              // 690
				out(lineCapID + ' J');                                                                                             // 691
			}                                                                                                                   // 692
			if (lineJoinID !== 0) {                                                                                             // 693
				out(lineJoinID + ' j');                                                                                            // 694
			}                                                                                                                   // 695
			events.publish('addPage', { pageNumber : page });                                                                   // 696
		},                                                                                                                   // 697
		_setPage = function(n) {                                                                                             // 698
			if (n > 0 && n <= page) {                                                                                           // 699
				currentPage = n;                                                                                                   // 700
				pageWidth = pagedim[n].width;                                                                                      // 701
				pageHeight = pagedim[n].height;                                                                                    // 702
			}                                                                                                                   // 703
		},                                                                                                                   // 704
		/**                                                                                                                  // 705
		 * Returns a document-specific font key - a label assigned to a                                                      // 706
		 * font name + font type combination at the time the font was added                                                  // 707
		 * to the font inventory.                                                                                            // 708
		 *                                                                                                                   // 709
		 * Font key is used as label for the desired font for a block of text                                                // 710
		 * to be added to the PDF document stream.                                                                           // 711
		 * @private                                                                                                          // 712
		 * @function                                                                                                         // 713
		 * @param fontName {String} can be undefined on "falthy" to indicate "use current"                                   // 714
		 * @param fontStyle {String} can be undefined on "falthy" to indicate "use current"                                  // 715
		 * @returns {String} Font key.                                                                                       // 716
		 */                                                                                                                  // 717
		getFont = function(fontName, fontStyle) {                                                                            // 718
			var key;                                                                                                            // 719
                                                                                                                       // 720
			fontName  = fontName  !== undefined ? fontName  : fonts[activeFontKey].fontName;                                    // 721
			fontStyle = fontStyle !== undefined ? fontStyle : fonts[activeFontKey].fontStyle;                                   // 722
                                                                                                                       // 723
			try {                                                                                                               // 724
			 // get a string like 'F3' - the KEY corresponding tot he font + type combination.                                  // 725
				key = fontmap[fontName][fontStyle];                                                                                // 726
			} catch (e) {}                                                                                                      // 727
                                                                                                                       // 728
			if (!key) {                                                                                                         // 729
				throw new Error("Unable to look up font label for font '" + fontName + "', '"                                      // 730
					+ fontStyle + "'. Refer to getFontList() for available fonts.");                                                  // 731
			}                                                                                                                   // 732
			return key;                                                                                                         // 733
		},                                                                                                                   // 734
		buildDocument = function() {                                                                                         // 735
                                                                                                                       // 736
			outToPages = false; // switches out() to content                                                                    // 737
			objectNumber = 2;                                                                                                   // 738
			content = [];                                                                                                       // 739
			offsets = [];                                                                                                       // 740
                                                                                                                       // 741
			// putHeader()                                                                                                      // 742
			out('%PDF-' + pdfVersion);                                                                                          // 743
                                                                                                                       // 744
			putPages();                                                                                                         // 745
                                                                                                                       // 746
			putResources();                                                                                                     // 747
                                                                                                                       // 748
			// Info                                                                                                             // 749
			newObject();                                                                                                        // 750
			out('<<');                                                                                                          // 751
			putInfo();                                                                                                          // 752
			out('>>');                                                                                                          // 753
			out('endobj');                                                                                                      // 754
                                                                                                                       // 755
			// Catalog                                                                                                          // 756
			newObject();                                                                                                        // 757
			out('<<');                                                                                                          // 758
			putCatalog();                                                                                                       // 759
			out('>>');                                                                                                          // 760
			out('endobj');                                                                                                      // 761
                                                                                                                       // 762
			// Cross-ref                                                                                                        // 763
			var o = content_length, i, p = "0000000000";                                                                        // 764
			out('xref');                                                                                                        // 765
			out('0 ' + (objectNumber + 1));                                                                                     // 766
			out(p+' 65535 f ');                                                                                                 // 767
			for (i = 1; i <= objectNumber; i++) {                                                                               // 768
				out((p + offsets[i]).slice(-10) + ' 00000 n ');                                                                    // 769
			}                                                                                                                   // 770
			// Trailer                                                                                                          // 771
			out('trailer');                                                                                                     // 772
			out('<<');                                                                                                          // 773
			putTrailer();                                                                                                       // 774
			out('>>');                                                                                                          // 775
			out('startxref');                                                                                                   // 776
			out(o);                                                                                                             // 777
			out('%%EOF');                                                                                                       // 778
                                                                                                                       // 779
			outToPages = true;                                                                                                  // 780
                                                                                                                       // 781
			return content.join('\n');                                                                                          // 782
		},                                                                                                                   // 783
		getStyle = function(style) {                                                                                         // 784
			// see path-painting operators in PDF spec                                                                          // 785
			var op = 'S'; // stroke                                                                                             // 786
			if (style === 'F') {                                                                                                // 787
				op = 'f'; // fill                                                                                                  // 788
			} else if (style === 'FD' || style === 'DF') {                                                                      // 789
				op = 'B'; // both                                                                                                  // 790
			} else if (style === 'f' || style === 'f*' || style === 'B' || style === 'B*') {                                    // 791
				/*                                                                                                                 // 792
				Allow direct use of these PDF path-painting operators:                                                             // 793
				- f	fill using nonzero winding number rule                                                                         // 794
				- f*	fill using even-odd rule                                                                                      // 795
				- B	fill then stroke with fill using non-zero winding number rule                                                  // 796
				- B*	fill then stroke with fill using even-odd rule                                                                // 797
				*/                                                                                                                 // 798
				op = style;                                                                                                        // 799
			}                                                                                                                   // 800
			return op;                                                                                                          // 801
		},                                                                                                                   // 802
		getArrayBuffer = function() {                                                                                        // 803
			var data = buildDocument(), len = data.length,                                                                      // 804
				ab = new ArrayBuffer(len), u8 = new Uint8Array(ab);                                                                // 805
                                                                                                                       // 806
			while(len--) u8[len] = data.charCodeAt(len);                                                                        // 807
			return ab;                                                                                                          // 808
		},                                                                                                                   // 809
		getBlob = function() {                                                                                               // 810
			return new Blob([getArrayBuffer()], { type : "application/pdf" });                                                  // 811
		},                                                                                                                   // 812
		/**                                                                                                                  // 813
		 * Generates the PDF document.                                                                                       // 814
		 *                                                                                                                   // 815
		 * If `type` argument is undefined, output is raw body of resulting PDF returned as a string.                        // 816
		 *                                                                                                                   // 817
		 * @param {String} type A string identifying one of the possible output types.                                       // 818
		 * @param {Object} options An object providing some additional signalling to PDF generator.                          // 819
		 * @function                                                                                                         // 820
		 * @returns {jsPDF}                                                                                                  // 821
		 * @methodOf jsPDF#                                                                                                  // 822
		 * @name output                                                                                                      // 823
		 */                                                                                                                  // 824
		output = SAFE(function(type, options) {                                                                              // 825
			var datauri = ('' + type).substr(0,6) === 'dataur'                                                                  // 826
				? 'data:application/pdf;base64,'+btoa(buildDocument()):0;                                                          // 827
                                                                                                                       // 828
			switch (type) {                                                                                                     // 829
				case undefined:                                                                                                    // 830
					return buildDocument();                                                                                           // 831
				case 'save':                                                                                                       // 832
					if (navigator.getUserMedia) {                                                                                     // 833
						if (global.URL === undefined                                                                                     // 834
						|| global.URL.createObjectURL === undefined) {                                                                   // 835
							return API.output('dataurlnewwindow');                                                                          // 836
						}                                                                                                                // 837
					}                                                                                                                 // 838
					saveAs(getBlob(), options);                                                                                       // 839
					if(typeof saveAs.unload === 'function') {                                                                         // 840
						if(global.setTimeout) {                                                                                          // 841
							setTimeout(saveAs.unload,911);                                                                                  // 842
						}                                                                                                                // 843
					}                                                                                                                 // 844
					break;                                                                                                            // 845
				case 'arraybuffer':                                                                                                // 846
					return getArrayBuffer();                                                                                          // 847
				case 'blob':                                                                                                       // 848
					return getBlob();                                                                                                 // 849
				case 'bloburi':                                                                                                    // 850
				case 'bloburl':                                                                                                    // 851
					// User is responsible of calling revokeObjectURL                                                                 // 852
					return global.URL && global.URL.createObjectURL(getBlob()) || void 0;                                             // 853
				case 'datauristring':                                                                                              // 854
				case 'dataurlstring':                                                                                              // 855
					return datauri;                                                                                                   // 856
				case 'dataurlnewwindow':                                                                                           // 857
					var nW = global.open(datauri);                                                                                    // 858
					if (nW || typeof safari === "undefined") return nW;                                                               // 859
					/* pass through */                                                                                                // 860
				case 'datauri':                                                                                                    // 861
				case 'dataurl':                                                                                                    // 862
					return global.document.location.href = datauri;                                                                   // 863
				default:                                                                                                           // 864
					throw new Error('Output type "' + type + '" is not supported.');                                                  // 865
			}                                                                                                                   // 866
			// @TODO: Add different output options                                                                              // 867
		});                                                                                                                  // 868
                                                                                                                       // 869
		switch (unit) {                                                                                                      // 870
			case 'pt':  k = 1;          break;                                                                                  // 871
			case 'mm':  k = 72 / 25.4;  break;                                                                                  // 872
			case 'cm':  k = 72 / 2.54;  break;                                                                                  // 873
			case 'in':  k = 72;         break;                                                                                  // 874
			case 'px':  k = 96 / 72;    break;                                                                                  // 875
			case 'pc':  k = 12;         break;                                                                                  // 876
			case 'em':  k = 12;         break;                                                                                  // 877
			case 'ex':  k = 6;          break;                                                                                  // 878
			default:                                                                                                            // 879
				throw ('Invalid unit: ' + unit);                                                                                   // 880
		}                                                                                                                    // 881
                                                                                                                       // 882
		//---------------------------------------                                                                            // 883
		// Public API                                                                                                        // 884
                                                                                                                       // 885
		/**                                                                                                                  // 886
		 * Object exposing internal API to plugins                                                                           // 887
		 * @public                                                                                                           // 888
		 */                                                                                                                  // 889
		API.internal = {                                                                                                     // 890
			'pdfEscape' : pdfEscape,                                                                                            // 891
			'getStyle' : getStyle,                                                                                              // 892
			/**                                                                                                                 // 893
			 * Returns {FontObject} describing a particular font.                                                               // 894
			 * @public                                                                                                          // 895
			 * @function                                                                                                        // 896
			 * @param fontName {String} (Optional) Font's family name                                                           // 897
			 * @param fontStyle {String} (Optional) Font's style variation name (Example:"Italic")                              // 898
			 * @returns {FontObject}                                                                                            // 899
			 */                                                                                                                 // 900
			'getFont' : function() {                                                                                            // 901
				return fonts[getFont.apply(API, arguments)];                                                                       // 902
			},                                                                                                                  // 903
			'getFontSize' : function() {                                                                                        // 904
				return activeFontSize;                                                                                             // 905
			},                                                                                                                  // 906
			'getLineHeight' : function() {                                                                                      // 907
				return activeFontSize * lineHeightProportion;                                                                      // 908
			},                                                                                                                  // 909
			'write' : function(string1 /*, string2, string3, etc */) {                                                          // 910
				out(arguments.length === 1 ? string1 : Array.prototype.join.call(arguments, ' '));                                 // 911
			},                                                                                                                  // 912
			'getCoordinateString' : function(value) {                                                                           // 913
				return f2(value * k);                                                                                              // 914
			},                                                                                                                  // 915
			'getVerticalCoordinateString' : function(value) {                                                                   // 916
				return f2((pageHeight - value) * k);                                                                               // 917
			},                                                                                                                  // 918
			'collections' : {},                                                                                                 // 919
			'newObject' : newObject,                                                                                            // 920
			'putStream' : putStream,                                                                                            // 921
			'events' : events,                                                                                                  // 922
			// ratio that you use in multiplication of a given "size" number to arrive to 'point'                               // 923
			// units of measurement.                                                                                            // 924
			// scaleFactor is set at initialization of the document and calculated against the stated                           // 925
			// default measurement units for the document.                                                                      // 926
			// If default is "mm", k is the number that will turn number in 'mm' into 'points' number.                          // 927
			// through multiplication.                                                                                          // 928
			'scaleFactor' : k,                                                                                                  // 929
			'pageSize' : {                                                                                                      // 930
				get width() {                                                                                                      // 931
					return pageWidth                                                                                                  // 932
				},                                                                                                                 // 933
				get height() {                                                                                                     // 934
					return pageHeight                                                                                                 // 935
				}                                                                                                                  // 936
			},                                                                                                                  // 937
			'output' : function(type, options) {                                                                                // 938
				return output(type, options);                                                                                      // 939
			},                                                                                                                  // 940
			'getNumberOfPages' : function() {                                                                                   // 941
				return pages.length - 1;                                                                                           // 942
			},                                                                                                                  // 943
			'pages' : pages                                                                                                     // 944
		};                                                                                                                   // 945
                                                                                                                       // 946
		/**                                                                                                                  // 947
		 * Adds (and transfers the focus to) new page to the PDF document.                                                   // 948
		 * @function                                                                                                         // 949
		 * @returns {jsPDF}                                                                                                  // 950
		 *                                                                                                                   // 951
		 * @methodOf jsPDF#                                                                                                  // 952
		 * @name addPage                                                                                                     // 953
		 */                                                                                                                  // 954
		API.addPage = function() {                                                                                           // 955
			_addPage.apply(this, arguments);                                                                                    // 956
			return this;                                                                                                        // 957
		};                                                                                                                   // 958
		API.setPage = function() {                                                                                           // 959
			_setPage.apply(this, arguments);                                                                                    // 960
			return this;                                                                                                        // 961
		};                                                                                                                   // 962
		API.setDisplayMode = function(zoom, layout, pmode) {                                                                 // 963
			zoomMode   = zoom;                                                                                                  // 964
			layoutMode = layout;                                                                                                // 965
			pageMode   = pmode;                                                                                                 // 966
			return this;                                                                                                        // 967
		},                                                                                                                   // 968
                                                                                                                       // 969
		/**                                                                                                                  // 970
		 * Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.                    // 971
		 *                                                                                                                   // 972
		 * @function                                                                                                         // 973
		 * @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page       // 975
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page      // 976
		 * @param {Object} flags Collection of settings signalling how the text must be encoded. Defaults are sane. If you think you want to pass some flags, you likely can read the source.
		 * @returns {jsPDF}                                                                                                  // 978
		 * @methodOf jsPDF#                                                                                                  // 979
		 * @name text                                                                                                        // 980
		 */                                                                                                                  // 981
		API.text = function(text, x, y, flags, angle) {                                                                      // 982
			/**                                                                                                                 // 983
			 * Inserts something like this into PDF                                                                             // 984
			 *   BT                                                                                                             // 985
			 *    /F1 16 Tf  % Font name + size                                                                                 // 986
			 *    16 TL % How many units down for next line in multiline text                                                   // 987
			 *    0 g % color                                                                                                   // 988
			 *    28.35 813.54 Td % position                                                                                    // 989
			 *    (line one) Tj                                                                                                 // 990
			 *    T* (line two) Tj                                                                                              // 991
			 *    T* (line three) Tj                                                                                            // 992
			 *   ET                                                                                                             // 993
			 */                                                                                                                 // 994
			function ESC(s) {                                                                                                   // 995
				s = s.split("\t").join(Array(options.TabLen||9).join(" "));                                                        // 996
				return pdfEscape(s, flags);                                                                                        // 997
			}                                                                                                                   // 998
                                                                                                                       // 999
			// Pre-August-2012 the order of arguments was function(x, y, text, flags)                                           // 1000
			// in effort to make all calls have similar signature like                                                          // 1001
			//   function(data, coordinates... , miscellaneous)                                                                 // 1002
			// this method had its args flipped.                                                                                // 1003
			// code below allows backward compatibility with old arg order.                                                     // 1004
			if (typeof text === 'number') {                                                                                     // 1005
				tmp = y;                                                                                                           // 1006
				y = x;                                                                                                             // 1007
				x = text;                                                                                                          // 1008
				text = tmp;                                                                                                        // 1009
			}                                                                                                                   // 1010
                                                                                                                       // 1011
			// If there are any newlines in text, we assume                                                                     // 1012
			// the user wanted to print multiple lines, so break the                                                            // 1013
			// text up into an array.  If the text is already an array,                                                         // 1014
			// we assume the user knows what they are doing.                                                                    // 1015
			if (typeof text === 'string' && text.match(/[\n\r]/)) {                                                             // 1016
				text = text.split(/\r\n|\r|\n/g);                                                                                  // 1017
			}                                                                                                                   // 1018
			if (typeof flags === 'number') {                                                                                    // 1019
				angle = flags;                                                                                                     // 1020
				flags = null;                                                                                                      // 1021
			}                                                                                                                   // 1022
			var xtra = '',mode = 'Td', todo;                                                                                    // 1023
			if (angle) {                                                                                                        // 1024
				angle *= (Math.PI / 180);                                                                                          // 1025
				var c = Math.cos(angle),                                                                                           // 1026
				s = Math.sin(angle);                                                                                               // 1027
				xtra = [f2(c), f2(s), f2(s * -1), f2(c), ''].join(" ");                                                            // 1028
				mode = 'Tm';                                                                                                       // 1029
			}                                                                                                                   // 1030
			flags = flags || {};                                                                                                // 1031
			if (!('noBOM' in flags))                                                                                            // 1032
				flags.noBOM = true;                                                                                                // 1033
			if (!('autoencode' in flags))                                                                                       // 1034
				flags.autoencode = true;                                                                                           // 1035
                                                                                                                       // 1036
			if (typeof text === 'string') {                                                                                     // 1037
				text = ESC(text);                                                                                                  // 1038
			} else if (text instanceof Array) {                                                                                 // 1039
				// we don't want to destroy  original text array, so cloning it                                                    // 1040
				var sa = text.concat(), da = [], len = sa.length;                                                                  // 1041
				// we do array.join('text that must not be PDFescaped")                                                            // 1042
				// thus, pdfEscape each component separately                                                                       // 1043
				while (len--) {                                                                                                    // 1044
					da.push(ESC(sa.shift()));                                                                                         // 1045
				}                                                                                                                  // 1046
				var linesLeft = Math.ceil((pageHeight - y) * k / (activeFontSize * lineHeightProportion));                         // 1047
				if (0 <= linesLeft && linesLeft < da.length + 1) {                                                                 // 1048
					todo = da.splice(linesLeft-1);                                                                                    // 1049
				}                                                                                                                  // 1050
				text = da.join(") Tj\nT* (");                                                                                      // 1051
			} else {                                                                                                            // 1052
				throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');                        // 1053
			}                                                                                                                   // 1054
			// Using "'" ("go next line and render text" mark) would save space but would complicate our rendering code, templates
                                                                                                                       // 1056
			// BT .. ET does NOT have default settings for Tf. You must state that explicitely every time for BT .. ET          // 1057
			// if you want text transformation matrix (+ multiline) to work reliably (which reads sizes of things from font declarations)
			// Thus, there is NO useful, *reliable* concept of "default" font for a page.                                       // 1059
			// The fact that "default" (reuse font used before) font worked before in basic cases is an accident                // 1060
			// - readers dealing smartly with brokenness of jsPDF's markup.                                                     // 1061
			out(                                                                                                                // 1062
				'BT\n/' +                                                                                                          // 1063
				activeFontKey + ' ' + activeFontSize + ' Tf\n' +     // font face, style, size                                     // 1064
				(activeFontSize * lineHeightProportion) + ' TL\n' +  // line spacing                                               // 1065
				textColor +                                                                                                        // 1066
				'\n' + xtra + f2(x * k) + ' ' + f2((pageHeight - y) * k) + ' ' + mode + '\n(' +                                    // 1067
				text +                                                                                                             // 1068
				') Tj\nET');                                                                                                       // 1069
                                                                                                                       // 1070
			if (todo) {                                                                                                         // 1071
				this.addPage();                                                                                                    // 1072
				this.text( todo, x, activeFontSize * 1.7 / k);                                                                     // 1073
			}                                                                                                                   // 1074
                                                                                                                       // 1075
			return this;                                                                                                        // 1076
		};                                                                                                                   // 1077
                                                                                                                       // 1078
		API.lstext = function(text, x, y, spacing) {                                                                         // 1079
			for (var i = 0, len = text.length ; i < len; i++, x += spacing) this.text(text[i], x, y);                           // 1080
		};                                                                                                                   // 1081
                                                                                                                       // 1082
		API.line = function(x1, y1, x2, y2) {                                                                                // 1083
			return this.lines([[x2 - x1, y2 - y1]], x1, y1);                                                                    // 1084
		};                                                                                                                   // 1085
                                                                                                                       // 1086
		API.clip = function() {                                                                                              // 1087
			// By patrick-roberts, github.com/MrRio/jsPDF/issues/328                                                            // 1088
			// Call .clip() after calling .rect() with a style argument of null                                                 // 1089
			out('W') // clip                                                                                                    // 1090
			out('S') // stroke path; necessary for clip to work                                                                 // 1091
		};                                                                                                                   // 1092
                                                                                                                       // 1093
		/**                                                                                                                  // 1094
		 * Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.        // 1095
		 * All data points in `lines` are relative to last line origin.                                                      // 1096
		 * `x`, `y` become x1,y1 for first line / curve in the set.                                                          // 1097
		 * For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.                // 1098
		 * For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.
		 *                                                                                                                   // 1100
		 * @example .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, 10) // line, line, bezier curve, line                // 1101
		 * @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).                  // 1102
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page       // 1103
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page      // 1104
		 * @param {Number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @param {Boolean} closed If true, the path is closed with a straight line from the end of the last curve to the starting point.
		 * @function                                                                                                         // 1108
		 * @returns {jsPDF}                                                                                                  // 1109
		 * @methodOf jsPDF#                                                                                                  // 1110
		 * @name lines                                                                                                       // 1111
		 */                                                                                                                  // 1112
		API.lines = function(lines, x, y, scale, style, closed) {                                                            // 1113
			var scalex,scaley,i,l,leg,x2,y2,x3,y3,x4,y4;                                                                        // 1114
                                                                                                                       // 1115
			// Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)                                   // 1116
			// in effort to make all calls have similar signature like                                                          // 1117
			//   function(content, coordinateX, coordinateY , miscellaneous)                                                    // 1118
			// this method had its args flipped.                                                                                // 1119
			// code below allows backward compatibility with old arg order.                                                     // 1120
			if (typeof lines === 'number') {                                                                                    // 1121
				tmp = y;                                                                                                           // 1122
				y = x;                                                                                                             // 1123
				x = lines;                                                                                                         // 1124
				lines = tmp;                                                                                                       // 1125
			}                                                                                                                   // 1126
                                                                                                                       // 1127
			scale = scale || [1, 1];                                                                                            // 1128
                                                                                                                       // 1129
			// starting point                                                                                                   // 1130
			out(f3(x * k) + ' ' + f3((pageHeight - y) * k) + ' m ');                                                            // 1131
                                                                                                                       // 1132
			scalex = scale[0];                                                                                                  // 1133
			scaley = scale[1];                                                                                                  // 1134
			l = lines.length;                                                                                                   // 1135
			//, x2, y2 // bezier only. In page default measurement "units", *after* scaling                                     // 1136
			//, x3, y3 // bezier only. In page default measurement "units", *after* scaling                                     // 1137
			// ending point for all, lines and bezier. . In page default measurement "units", *after* scaling                   // 1138
			x4 = x; // last / ending point = starting point for first item.                                                     // 1139
			y4 = y; // last / ending point = starting point for first item.                                                     // 1140
                                                                                                                       // 1141
			for (i = 0; i < l; i++) {                                                                                           // 1142
				leg = lines[i];                                                                                                    // 1143
				if (leg.length === 2) {                                                                                            // 1144
					// simple line                                                                                                    // 1145
					x4 = leg[0] * scalex + x4; // here last x4 was prior ending point                                                 // 1146
					y4 = leg[1] * scaley + y4; // here last y4 was prior ending point                                                 // 1147
					out(f3(x4 * k) + ' ' + f3((pageHeight - y4) * k) + ' l');                                                         // 1148
				} else {                                                                                                           // 1149
					// bezier curve                                                                                                   // 1150
					x2 = leg[0] * scalex + x4; // here last x4 is prior ending point                                                  // 1151
					y2 = leg[1] * scaley + y4; // here last y4 is prior ending point                                                  // 1152
					x3 = leg[2] * scalex + x4; // here last x4 is prior ending point                                                  // 1153
					y3 = leg[3] * scaley + y4; // here last y4 is prior ending point                                                  // 1154
					x4 = leg[4] * scalex + x4; // here last x4 was prior ending point                                                 // 1155
					y4 = leg[5] * scaley + y4; // here last y4 was prior ending point                                                 // 1156
					out(                                                                                                              // 1157
						f3(x2 * k) + ' ' +                                                                                               // 1158
						f3((pageHeight - y2) * k) + ' ' +                                                                                // 1159
						f3(x3 * k) + ' ' +                                                                                               // 1160
						f3((pageHeight - y3) * k) + ' ' +                                                                                // 1161
						f3(x4 * k) + ' ' +                                                                                               // 1162
						f3((pageHeight - y4) * k) + ' c');                                                                               // 1163
				}                                                                                                                  // 1164
			}                                                                                                                   // 1165
                                                                                                                       // 1166
			if (closed) {                                                                                                       // 1167
				out(' h');                                                                                                         // 1168
			}                                                                                                                   // 1169
                                                                                                                       // 1170
			// stroking / filling / both the path                                                                               // 1171
			if (style !== null) {                                                                                               // 1172
				out(getStyle(style));                                                                                              // 1173
			}                                                                                                                   // 1174
			return this;                                                                                                        // 1175
		};                                                                                                                   // 1176
                                                                                                                       // 1177
		/**                                                                                                                  // 1178
		 * Adds a rectangle to PDF                                                                                           // 1179
		 *                                                                                                                   // 1180
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page       // 1181
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page      // 1182
		 * @param {Number} w Width (in units declared at inception of PDF document)                                          // 1183
		 * @param {Number} h Height (in units declared at inception of PDF document)                                         // 1184
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function                                                                                                         // 1186
		 * @returns {jsPDF}                                                                                                  // 1187
		 * @methodOf jsPDF#                                                                                                  // 1188
		 * @name rect                                                                                                        // 1189
		 */                                                                                                                  // 1190
		API.rect = function(x, y, w, h, style) {                                                                             // 1191
			var op = getStyle(style);                                                                                           // 1192
			out([                                                                                                               // 1193
					f2(x * k),                                                                                                        // 1194
					f2((pageHeight - y) * k),                                                                                         // 1195
					f2(w * k),                                                                                                        // 1196
					f2(-h * k),                                                                                                       // 1197
					're'                                                                                                              // 1198
				].join(' '));                                                                                                      // 1199
                                                                                                                       // 1200
			if (style !== null) {                                                                                               // 1201
				out(getStyle(style));                                                                                              // 1202
			}                                                                                                                   // 1203
                                                                                                                       // 1204
			return this;                                                                                                        // 1205
		};                                                                                                                   // 1206
                                                                                                                       // 1207
		/**                                                                                                                  // 1208
		 * Adds a triangle to PDF                                                                                            // 1209
		 *                                                                                                                   // 1210
		 * @param {Number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page      // 1211
		 * @param {Number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page     // 1212
		 * @param {Number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page      // 1213
		 * @param {Number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page     // 1214
		 * @param {Number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page      // 1215
		 * @param {Number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page     // 1216
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function                                                                                                         // 1218
		 * @returns {jsPDF}                                                                                                  // 1219
		 * @methodOf jsPDF#                                                                                                  // 1220
		 * @name triangle                                                                                                    // 1221
		 */                                                                                                                  // 1222
		API.triangle = function(x1, y1, x2, y2, x3, y3, style) {                                                             // 1223
			this.lines(                                                                                                         // 1224
				[                                                                                                                  // 1225
					[x2 - x1, y2 - y1], // vector to point 2                                                                          // 1226
					[x3 - x2, y3 - y2], // vector to point 3                                                                          // 1227
					[x1 - x3, y1 - y3]// closing vector back to point 1                                                               // 1228
				],                                                                                                                 // 1229
				x1,                                                                                                                // 1230
				y1, // start of path                                                                                               // 1231
				[1, 1],                                                                                                            // 1232
				style,                                                                                                             // 1233
				true);                                                                                                             // 1234
			return this;                                                                                                        // 1235
		};                                                                                                                   // 1236
                                                                                                                       // 1237
		/**                                                                                                                  // 1238
		 * Adds a rectangle with rounded corners to PDF                                                                      // 1239
		 *                                                                                                                   // 1240
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page       // 1241
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page      // 1242
		 * @param {Number} w Width (in units declared at inception of PDF document)                                          // 1243
		 * @param {Number} h Height (in units declared at inception of PDF document)                                         // 1244
		 * @param {Number} rx Radius along x axis (in units declared at inception of PDF document)                           // 1245
		 * @param {Number} rx Radius along y axis (in units declared at inception of PDF document)                           // 1246
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function                                                                                                         // 1248
		 * @returns {jsPDF}                                                                                                  // 1249
		 * @methodOf jsPDF#                                                                                                  // 1250
		 * @name roundedRect                                                                                                 // 1251
		 */                                                                                                                  // 1252
		API.roundedRect = function(x, y, w, h, rx, ry, style) {                                                              // 1253
			var MyArc = 4 / 3 * (Math.SQRT2 - 1);                                                                               // 1254
			this.lines(                                                                                                         // 1255
				[                                                                                                                  // 1256
					[(w - 2 * rx), 0],                                                                                                // 1257
					[(rx * MyArc), 0, rx, ry - (ry * MyArc), rx, ry],                                                                 // 1258
					[0, (h - 2 * ry)],                                                                                                // 1259
					[0, (ry * MyArc),  - (rx * MyArc), ry, -rx, ry],                                                                  // 1260
					[(-w + 2 * rx), 0],                                                                                               // 1261
					[ - (rx * MyArc), 0, -rx,  - (ry * MyArc), -rx, -ry],                                                             // 1262
					[0, (-h + 2 * ry)],                                                                                               // 1263
					[0,  - (ry * MyArc), (rx * MyArc), -ry, rx, -ry]                                                                  // 1264
				],                                                                                                                 // 1265
				x + rx,                                                                                                            // 1266
				y, // start of path                                                                                                // 1267
				[1, 1],                                                                                                            // 1268
				style);                                                                                                            // 1269
			return this;                                                                                                        // 1270
		};                                                                                                                   // 1271
                                                                                                                       // 1272
		/**                                                                                                                  // 1273
		 * Adds an ellipse to PDF                                                                                            // 1274
		 *                                                                                                                   // 1275
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page       // 1276
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page      // 1277
		 * @param {Number} rx Radius along x axis (in units declared at inception of PDF document)                           // 1278
		 * @param {Number} rx Radius along y axis (in units declared at inception of PDF document)                           // 1279
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function                                                                                                         // 1281
		 * @returns {jsPDF}                                                                                                  // 1282
		 * @methodOf jsPDF#                                                                                                  // 1283
		 * @name ellipse                                                                                                     // 1284
		 */                                                                                                                  // 1285
		API.ellipse = function(x, y, rx, ry, style) {                                                                        // 1286
			var lx = 4 / 3 * (Math.SQRT2 - 1) * rx,                                                                             // 1287
				ly = 4 / 3 * (Math.SQRT2 - 1) * ry;                                                                                // 1288
                                                                                                                       // 1289
			out([                                                                                                               // 1290
					f2((x + rx) * k),                                                                                                 // 1291
					f2((pageHeight - y) * k),                                                                                         // 1292
					'm',                                                                                                              // 1293
					f2((x + rx) * k),                                                                                                 // 1294
					f2((pageHeight - (y - ly)) * k),                                                                                  // 1295
					f2((x + lx) * k),                                                                                                 // 1296
					f2((pageHeight - (y - ry)) * k),                                                                                  // 1297
					f2(x * k),                                                                                                        // 1298
					f2((pageHeight - (y - ry)) * k),                                                                                  // 1299
					'c'                                                                                                               // 1300
				].join(' '));                                                                                                      // 1301
			out([                                                                                                               // 1302
					f2((x - lx) * k),                                                                                                 // 1303
					f2((pageHeight - (y - ry)) * k),                                                                                  // 1304
					f2((x - rx) * k),                                                                                                 // 1305
					f2((pageHeight - (y - ly)) * k),                                                                                  // 1306
					f2((x - rx) * k),                                                                                                 // 1307
					f2((pageHeight - y) * k),                                                                                         // 1308
					'c'                                                                                                               // 1309
				].join(' '));                                                                                                      // 1310
			out([                                                                                                               // 1311
					f2((x - rx) * k),                                                                                                 // 1312
					f2((pageHeight - (y + ly)) * k),                                                                                  // 1313
					f2((x - lx) * k),                                                                                                 // 1314
					f2((pageHeight - (y + ry)) * k),                                                                                  // 1315
					f2(x * k),                                                                                                        // 1316
					f2((pageHeight - (y + ry)) * k),                                                                                  // 1317
					'c'                                                                                                               // 1318
				].join(' '));                                                                                                      // 1319
			out([                                                                                                               // 1320
					f2((x + lx) * k),                                                                                                 // 1321
					f2((pageHeight - (y + ry)) * k),                                                                                  // 1322
					f2((x + rx) * k),                                                                                                 // 1323
					f2((pageHeight - (y + ly)) * k),                                                                                  // 1324
					f2((x + rx) * k),                                                                                                 // 1325
					f2((pageHeight - y) * k),                                                                                         // 1326
					'c'                                                                                                               // 1327
				].join(' '));                                                                                                      // 1328
                                                                                                                       // 1329
			if (style !== null) {                                                                                               // 1330
				out(getStyle(style));                                                                                              // 1331
			}                                                                                                                   // 1332
                                                                                                                       // 1333
			return this;                                                                                                        // 1334
		};                                                                                                                   // 1335
                                                                                                                       // 1336
		/**                                                                                                                  // 1337
		 * Adds an circle to PDF                                                                                             // 1338
		 *                                                                                                                   // 1339
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page       // 1340
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page      // 1341
		 * @param {Number} r Radius (in units declared at inception of PDF document)                                         // 1342
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function                                                                                                         // 1344
		 * @returns {jsPDF}                                                                                                  // 1345
		 * @methodOf jsPDF#                                                                                                  // 1346
		 * @name circle                                                                                                      // 1347
		 */                                                                                                                  // 1348
		API.circle = function(x, y, r, style) {                                                                              // 1349
			return this.ellipse(x, y, r, r, style);                                                                             // 1350
		};                                                                                                                   // 1351
                                                                                                                       // 1352
		/**                                                                                                                  // 1353
		 * Adds a properties to the PDF document                                                                             // 1354
		 *                                                                                                                   // 1355
		 * @param {Object} A property_name-to-property_value object structure.                                               // 1356
		 * @function                                                                                                         // 1357
		 * @returns {jsPDF}                                                                                                  // 1358
		 * @methodOf jsPDF#                                                                                                  // 1359
		 * @name setProperties                                                                                               // 1360
		 */                                                                                                                  // 1361
		API.setProperties = function(properties) {                                                                           // 1362
			// copying only those properties we can render.                                                                     // 1363
			for (var property in documentProperties) {                                                                          // 1364
				if (documentProperties.hasOwnProperty(property) && properties[property]) {                                         // 1365
					documentProperties[property] = properties[property];                                                              // 1366
				}                                                                                                                  // 1367
			}                                                                                                                   // 1368
			return this;                                                                                                        // 1369
		};                                                                                                                   // 1370
                                                                                                                       // 1371
		/**                                                                                                                  // 1372
		 * Sets font size for upcoming text elements.                                                                        // 1373
		 *                                                                                                                   // 1374
		 * @param {Number} size Font size in points.                                                                         // 1375
		 * @function                                                                                                         // 1376
		 * @returns {jsPDF}                                                                                                  // 1377
		 * @methodOf jsPDF#                                                                                                  // 1378
		 * @name setFontSize                                                                                                 // 1379
		 */                                                                                                                  // 1380
		API.setFontSize = function(size) {                                                                                   // 1381
			activeFontSize = size;                                                                                              // 1382
			return this;                                                                                                        // 1383
		};                                                                                                                   // 1384
                                                                                                                       // 1385
		/**                                                                                                                  // 1386
		 * Sets text font face, variant for upcoming text elements.                                                          // 1387
		 * See output of jsPDF.getFontList() for possible font names, styles.                                                // 1388
		 *                                                                                                                   // 1389
		 * @param {String} fontName Font name or family. Example: "times"                                                    // 1390
		 * @param {String} fontStyle Font style or variant. Example: "italic"                                                // 1391
		 * @function                                                                                                         // 1392
		 * @returns {jsPDF}                                                                                                  // 1393
		 * @methodOf jsPDF#                                                                                                  // 1394
		 * @name setFont                                                                                                     // 1395
		 */                                                                                                                  // 1396
		API.setFont = function(fontName, fontStyle) {                                                                        // 1397
			activeFontKey = getFont(fontName, fontStyle);                                                                       // 1398
			// if font is not found, the above line blows up and we never go further                                            // 1399
			return this;                                                                                                        // 1400
		};                                                                                                                   // 1401
                                                                                                                       // 1402
		/**                                                                                                                  // 1403
		 * Switches font style or variant for upcoming text elements,                                                        // 1404
		 * while keeping the font face or family same.                                                                       // 1405
		 * See output of jsPDF.getFontList() for possible font names, styles.                                                // 1406
		 *                                                                                                                   // 1407
		 * @param {String} style Font style or variant. Example: "italic"                                                    // 1408
		 * @function                                                                                                         // 1409
		 * @returns {jsPDF}                                                                                                  // 1410
		 * @methodOf jsPDF#                                                                                                  // 1411
		 * @name setFontStyle                                                                                                // 1412
		 */                                                                                                                  // 1413
		API.setFontStyle = API.setFontType = function(style) {                                                               // 1414
			activeFontKey = getFont(undefined, style);                                                                          // 1415
			// if font is not found, the above line blows up and we never go further                                            // 1416
			return this;                                                                                                        // 1417
		};                                                                                                                   // 1418
                                                                                                                       // 1419
		/**                                                                                                                  // 1420
		 * Returns an object - a tree of fontName to fontStyle relationships available to                                    // 1421
		 * active PDF document.                                                                                              // 1422
		 *                                                                                                                   // 1423
		 * @public                                                                                                           // 1424
		 * @function                                                                                                         // 1425
		 * @returns {Object} Like {'times':['normal', 'italic', ... ], 'arial':['normal', 'bold', ... ], ... }               // 1426
		 * @methodOf jsPDF#                                                                                                  // 1427
		 * @name getFontList                                                                                                 // 1428
		 */                                                                                                                  // 1429
		API.getFontList = function() {                                                                                       // 1430
			// TODO: iterate over fonts array or return copy of fontmap instead in case more are ever added.                    // 1431
			var list = {},fontName,fontStyle,tmp;                                                                               // 1432
                                                                                                                       // 1433
			for (fontName in fontmap) {                                                                                         // 1434
				if (fontmap.hasOwnProperty(fontName)) {                                                                            // 1435
					list[fontName] = tmp = [];                                                                                        // 1436
					for (fontStyle in fontmap[fontName]) {                                                                            // 1437
						if (fontmap[fontName].hasOwnProperty(fontStyle)) {                                                               // 1438
							tmp.push(fontStyle);                                                                                            // 1439
						}                                                                                                                // 1440
					}                                                                                                                 // 1441
				}                                                                                                                  // 1442
			}                                                                                                                   // 1443
                                                                                                                       // 1444
			return list;                                                                                                        // 1445
		};                                                                                                                   // 1446
                                                                                                                       // 1447
		/**                                                                                                                  // 1448
		 * Sets line width for upcoming lines.                                                                               // 1449
		 *                                                                                                                   // 1450
		 * @param {Number} width Line width (in units declared at inception of PDF document)                                 // 1451
		 * @function                                                                                                         // 1452
		 * @returns {jsPDF}                                                                                                  // 1453
		 * @methodOf jsPDF#                                                                                                  // 1454
		 * @name setLineWidth                                                                                                // 1455
		 */                                                                                                                  // 1456
		API.setLineWidth = function(width) {                                                                                 // 1457
			out((width * k).toFixed(2) + ' w');                                                                                 // 1458
			return this;                                                                                                        // 1459
		};                                                                                                                   // 1460
                                                                                                                       // 1461
		/**                                                                                                                  // 1462
		 * Sets the stroke color for upcoming elements.                                                                      // 1463
		 *                                                                                                                   // 1464
		 * Depending on the number of arguments given, Gray, RGB, or CMYK                                                    // 1465
		 * color space is implied.                                                                                           // 1466
		 *                                                                                                                   // 1467
		 * When only ch1 is given, "Gray" color space is implied and it                                                      // 1468
		 * must be a value in the range from 0.00 (solid black) to to 1.00 (white)                                           // 1469
		 * if values are communicated as String types, or in range from 0 (black)                                            // 1470
		 * to 255 (white) if communicated as Number type.                                                                    // 1471
		 * The RGB-like 0-255 range is provided for backward compatibility.                                                  // 1472
		 *                                                                                                                   // 1473
		 * When only ch1,ch2,ch3 are given, "RGB" color space is implied and each                                            // 1474
		 * value must be in the range from 0.00 (minimum intensity) to to 1.00                                               // 1475
		 * (max intensity) if values are communicated as String types, or                                                    // 1476
		 * from 0 (min intensity) to to 255 (max intensity) if values are communicated                                       // 1477
		 * as Number types.                                                                                                  // 1478
		 * The RGB-like 0-255 range is provided for backward compatibility.                                                  // 1479
		 *                                                                                                                   // 1480
		 * When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each                                            // 1481
		 * value must be a in the range from 0.00 (0% concentration) to to                                                   // 1482
		 * 1.00 (100% concentration)                                                                                         // 1483
		 *                                                                                                                   // 1484
		 * Because JavaScript treats fixed point numbers badly (rounds to                                                    // 1485
		 * floating point nearest to binary representation) it is highly advised to                                          // 1486
		 * communicate the fractional numbers as String types, not JavaScript Number type.                                   // 1487
		 *                                                                                                                   // 1488
		 * @param {Number|String} ch1 Color channel value                                                                    // 1489
		 * @param {Number|String} ch2 Color channel value                                                                    // 1490
		 * @param {Number|String} ch3 Color channel value                                                                    // 1491
		 * @param {Number|String} ch4 Color channel value                                                                    // 1492
		 *                                                                                                                   // 1493
		 * @function                                                                                                         // 1494
		 * @returns {jsPDF}                                                                                                  // 1495
		 * @methodOf jsPDF#                                                                                                  // 1496
		 * @name setDrawColor                                                                                                // 1497
		 */                                                                                                                  // 1498
		API.setDrawColor = function(ch1, ch2, ch3, ch4) {                                                                    // 1499
			var color;                                                                                                          // 1500
			if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {                                              // 1501
				// Gray color space.                                                                                               // 1502
				if (typeof ch1 === 'string') {                                                                                     // 1503
					color = ch1 + ' G';                                                                                               // 1504
				} else {                                                                                                           // 1505
					color = f2(ch1 / 255) + ' G';                                                                                     // 1506
				}                                                                                                                  // 1507
			} else if (ch4 === undefined) {                                                                                     // 1508
				// RGB                                                                                                             // 1509
				if (typeof ch1 === 'string') {                                                                                     // 1510
					color = [ch1, ch2, ch3, 'RG'].join(' ');                                                                          // 1511
				} else {                                                                                                           // 1512
					color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'RG'].join(' ');                                            // 1513
				}                                                                                                                  // 1514
			} else {                                                                                                            // 1515
				// CMYK                                                                                                            // 1516
				if (typeof ch1 === 'string') {                                                                                     // 1517
					color = [ch1, ch2, ch3, ch4, 'K'].join(' ');                                                                      // 1518
				} else {                                                                                                           // 1519
					color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'K'].join(' ');                                                      // 1520
				}                                                                                                                  // 1521
			}                                                                                                                   // 1522
                                                                                                                       // 1523
			out(color);                                                                                                         // 1524
			return this;                                                                                                        // 1525
		};                                                                                                                   // 1526
                                                                                                                       // 1527
		/**                                                                                                                  // 1528
		 * Sets the fill color for upcoming elements.                                                                        // 1529
		 *                                                                                                                   // 1530
		 * Depending on the number of arguments given, Gray, RGB, or CMYK                                                    // 1531
		 * color space is implied.                                                                                           // 1532
		 *                                                                                                                   // 1533
		 * When only ch1 is given, "Gray" color space is implied and it                                                      // 1534
		 * must be a value in the range from 0.00 (solid black) to to 1.00 (white)                                           // 1535
		 * if values are communicated as String types, or in range from 0 (black)                                            // 1536
		 * to 255 (white) if communicated as Number type.                                                                    // 1537
		 * The RGB-like 0-255 range is provided for backward compatibility.                                                  // 1538
		 *                                                                                                                   // 1539
		 * When only ch1,ch2,ch3 are given, "RGB" color space is implied and each                                            // 1540
		 * value must be in the range from 0.00 (minimum intensity) to to 1.00                                               // 1541
		 * (max intensity) if values are communicated as String types, or                                                    // 1542
		 * from 0 (min intensity) to to 255 (max intensity) if values are communicated                                       // 1543
		 * as Number types.                                                                                                  // 1544
		 * The RGB-like 0-255 range is provided for backward compatibility.                                                  // 1545
		 *                                                                                                                   // 1546
		 * When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each                                            // 1547
		 * value must be a in the range from 0.00 (0% concentration) to to                                                   // 1548
		 * 1.00 (100% concentration)                                                                                         // 1549
		 *                                                                                                                   // 1550
		 * Because JavaScript treats fixed point numbers badly (rounds to                                                    // 1551
		 * floating point nearest to binary representation) it is highly advised to                                          // 1552
		 * communicate the fractional numbers as String types, not JavaScript Number type.                                   // 1553
		 *                                                                                                                   // 1554
		 * @param {Number|String} ch1 Color channel value                                                                    // 1555
		 * @param {Number|String} ch2 Color channel value                                                                    // 1556
		 * @param {Number|String} ch3 Color channel value                                                                    // 1557
		 * @param {Number|String} ch4 Color channel value                                                                    // 1558
		 *                                                                                                                   // 1559
		 * @function                                                                                                         // 1560
		 * @returns {jsPDF}                                                                                                  // 1561
		 * @methodOf jsPDF#                                                                                                  // 1562
		 * @name setFillColor                                                                                                // 1563
		 */                                                                                                                  // 1564
		API.setFillColor = function(ch1, ch2, ch3, ch4) {                                                                    // 1565
			var color;                                                                                                          // 1566
                                                                                                                       // 1567
			if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {                                              // 1568
				// Gray color space.                                                                                               // 1569
				if (typeof ch1 === 'string') {                                                                                     // 1570
					color = ch1 + ' g';                                                                                               // 1571
				} else {                                                                                                           // 1572
					color = f2(ch1 / 255) + ' g';                                                                                     // 1573
				}                                                                                                                  // 1574
			} else if (ch4 === undefined) {                                                                                     // 1575
				// RGB                                                                                                             // 1576
				if (typeof ch1 === 'string') {                                                                                     // 1577
					color = [ch1, ch2, ch3, 'rg'].join(' ');                                                                          // 1578
				} else {                                                                                                           // 1579
					color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'rg'].join(' ');                                            // 1580
				}                                                                                                                  // 1581
			} else {                                                                                                            // 1582
				// CMYK                                                                                                            // 1583
				if (typeof ch1 === 'string') {                                                                                     // 1584
					color = [ch1, ch2, ch3, ch4, 'k'].join(' ');                                                                      // 1585
				} else {                                                                                                           // 1586
					color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'k'].join(' ');                                                      // 1587
				}                                                                                                                  // 1588
			}                                                                                                                   // 1589
                                                                                                                       // 1590
			out(color);                                                                                                         // 1591
			return this;                                                                                                        // 1592
		};                                                                                                                   // 1593
                                                                                                                       // 1594
		/**                                                                                                                  // 1595
		 * Sets the text color for upcoming elements.                                                                        // 1596
		 * If only one, first argument is given,                                                                             // 1597
		 * treats the value as gray-scale color value.                                                                       // 1598
		 *                                                                                                                   // 1599
		 * @param {Number} r Red channel color value in range 0-255 or {String} r color value in hexadecimal, example: '#FFFFFF'
		 * @param {Number} g Green channel color value in range 0-255                                                        // 1601
		 * @param {Number} b Blue channel color value in range 0-255                                                         // 1602
		 * @function                                                                                                         // 1603
		 * @returns {jsPDF}                                                                                                  // 1604
		 * @methodOf jsPDF#                                                                                                  // 1605
		 * @name setTextColor                                                                                                // 1606
		 */                                                                                                                  // 1607
		API.setTextColor = function(r, g, b) {                                                                               // 1608
			if ((typeof r === 'string') && /^#[0-9A-Fa-f]{6}$/.test(r)) {                                                       // 1609
				var hex = parseInt(r.substr(1), 16);                                                                               // 1610
				r = (hex >> 16) & 255;                                                                                             // 1611
				g = (hex >> 8) & 255;                                                                                              // 1612
				b = (hex & 255);                                                                                                   // 1613
			}                                                                                                                   // 1614
                                                                                                                       // 1615
			if ((r === 0 && g === 0 && b === 0) || (typeof g === 'undefined')) {                                                // 1616
				textColor = f3(r / 255) + ' g';                                                                                    // 1617
			} else {                                                                                                            // 1618
				textColor = [f3(r / 255), f3(g / 255), f3(b / 255), 'rg'].join(' ');                                               // 1619
			}                                                                                                                   // 1620
			return this;                                                                                                        // 1621
		};                                                                                                                   // 1622
                                                                                                                       // 1623
		/**                                                                                                                  // 1624
		 * Is an Object providing a mapping from human-readable to                                                           // 1625
		 * integer flag values designating the varieties of line cap                                                         // 1626
		 * and join styles.                                                                                                  // 1627
		 *                                                                                                                   // 1628
		 * @returns {Object}                                                                                                 // 1629
		 * @fieldOf jsPDF#                                                                                                   // 1630
		 * @name CapJoinStyles                                                                                               // 1631
		 */                                                                                                                  // 1632
		API.CapJoinStyles = {                                                                                                // 1633
			0 : 0,                                                                                                              // 1634
			'butt' : 0,                                                                                                         // 1635
			'but' : 0,                                                                                                          // 1636
			'miter' : 0,                                                                                                        // 1637
			1 : 1,                                                                                                              // 1638
			'round' : 1,                                                                                                        // 1639
			'rounded' : 1,                                                                                                      // 1640
			'circle' : 1,                                                                                                       // 1641
			2 : 2,                                                                                                              // 1642
			'projecting' : 2,                                                                                                   // 1643
			'project' : 2,                                                                                                      // 1644
			'square' : 2,                                                                                                       // 1645
			'bevel' : 2                                                                                                         // 1646
		};                                                                                                                   // 1647
                                                                                                                       // 1648
		/**                                                                                                                  // 1649
		 * Sets the line cap styles                                                                                          // 1650
		 * See {jsPDF.CapJoinStyles} for variants                                                                            // 1651
		 *                                                                                                                   // 1652
		 * @param {String|Number} style A string or number identifying the type of line cap                                  // 1653
		 * @function                                                                                                         // 1654
		 * @returns {jsPDF}                                                                                                  // 1655
		 * @methodOf jsPDF#                                                                                                  // 1656
		 * @name setLineCap                                                                                                  // 1657
		 */                                                                                                                  // 1658
		API.setLineCap = function(style) {                                                                                   // 1659
			var id = this.CapJoinStyles[style];                                                                                 // 1660
			if (id === undefined) {                                                                                             // 1661
				throw new Error("Line cap style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
			}                                                                                                                   // 1663
			lineCapID = id;                                                                                                     // 1664
			out(id + ' J');                                                                                                     // 1665
                                                                                                                       // 1666
			return this;                                                                                                        // 1667
		};                                                                                                                   // 1668
                                                                                                                       // 1669
		/**                                                                                                                  // 1670
		 * Sets the line join styles                                                                                         // 1671
		 * See {jsPDF.CapJoinStyles} for variants                                                                            // 1672
		 *                                                                                                                   // 1673
		 * @param {String|Number} style A string or number identifying the type of line join                                 // 1674
		 * @function                                                                                                         // 1675
		 * @returns {jsPDF}                                                                                                  // 1676
		 * @methodOf jsPDF#                                                                                                  // 1677
		 * @name setLineJoin                                                                                                 // 1678
		 */                                                                                                                  // 1679
		API.setLineJoin = function(style) {                                                                                  // 1680
			var id = this.CapJoinStyles[style];                                                                                 // 1681
			if (id === undefined) {                                                                                             // 1682
				throw new Error("Line join style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
			}                                                                                                                   // 1684
			lineJoinID = id;                                                                                                    // 1685
			out(id + ' j');                                                                                                     // 1686
                                                                                                                       // 1687
			return this;                                                                                                        // 1688
		};                                                                                                                   // 1689
                                                                                                                       // 1690
		// Output is both an internal (for plugins) and external function                                                    // 1691
		API.output = output;                                                                                                 // 1692
                                                                                                                       // 1693
		/**                                                                                                                  // 1694
		 * Saves as PDF document. An alias of jsPDF.output('save', 'filename.pdf')                                           // 1695
		 * @param  {String} filename The filename including extension.                                                       // 1696
		 *                                                                                                                   // 1697
		 * @function                                                                                                         // 1698
		 * @returns {jsPDF}                                                                                                  // 1699
		 * @methodOf jsPDF#                                                                                                  // 1700
		 * @name save                                                                                                        // 1701
		 */                                                                                                                  // 1702
		API.save = function(filename) {                                                                                      // 1703
			API.output('save', filename);                                                                                       // 1704
		};                                                                                                                   // 1705
                                                                                                                       // 1706
		// applying plugins (more methods) ON TOP of built-in API.                                                           // 1707
		// this is intentional as we allow plugins to override                                                               // 1708
		// built-ins                                                                                                         // 1709
		for (var plugin in jsPDF.API) {                                                                                      // 1710
			if (jsPDF.API.hasOwnProperty(plugin)) {                                                                             // 1711
				if (plugin === 'events' && jsPDF.API.events.length) {                                                              // 1712
					(function(events, newEvents) {                                                                                    // 1713
                                                                                                                       // 1714
						// jsPDF.API.events is a JS Array of Arrays                                                                      // 1715
						// where each Array is a pair of event name, handler                                                             // 1716
						// Events were added by plugins to the jsPDF instantiator.                                                       // 1717
						// These are always added to the new instance and some ran                                                       // 1718
						// during instantiation.                                                                                         // 1719
						var eventname,handler_and_args,i;                                                                                // 1720
                                                                                                                       // 1721
						for (i = newEvents.length - 1; i !== -1; i--) {                                                                  // 1722
							// subscribe takes 3 args: 'topic', function, runonce_flag                                                      // 1723
							// if undefined, runonce is false.                                                                              // 1724
							// users can attach callback directly,                                                                          // 1725
							// or they can attach an array with [callback, runonce_flag]                                                    // 1726
							// that's what the "apply" magic is for below.                                                                  // 1727
							eventname = newEvents[i][0];                                                                                    // 1728
							handler_and_args = newEvents[i][1];                                                                             // 1729
							events.subscribe.apply(                                                                                         // 1730
								events,                                                                                                        // 1731
								[eventname].concat(                                                                                            // 1732
									typeof handler_and_args === 'function' ?                                                                      // 1733
										[handler_and_args] : handler_and_args));                                                                     // 1734
						}                                                                                                                // 1735
					}(events, jsPDF.API.events));                                                                                     // 1736
				} else {                                                                                                           // 1737
					API[plugin] = jsPDF.API[plugin];                                                                                  // 1738
				}                                                                                                                  // 1739
			}                                                                                                                   // 1740
		}                                                                                                                    // 1741
                                                                                                                       // 1742
		//////////////////////////////////////////////////////                                                               // 1743
		// continuing initialization of jsPDF Document object                                                                // 1744
		//////////////////////////////////////////////////////                                                               // 1745
		// Add the first page automatically                                                                                  // 1746
		addFonts();                                                                                                          // 1747
		activeFontKey = 'F1';                                                                                                // 1748
		_addPage(format, orientation);                                                                                       // 1749
                                                                                                                       // 1750
		events.publish('initialized');                                                                                       // 1751
		return API;                                                                                                          // 1752
	}                                                                                                                     // 1753
                                                                                                                       // 1754
	/**                                                                                                                   // 1755
	 * jsPDF.API is a STATIC property of jsPDF class.                                                                     // 1756
	 * jsPDF.API is an object you can add methods and properties to.                                                      // 1757
	 * The methods / properties you add will show up in new jsPDF objects.                                                // 1758
	 *                                                                                                                    // 1759
	 * One property is prepopulated. It is the 'events' Object. Plugin authors can add topics,                            // 1760
	 * callbacks to this object. These will be reassigned to all new instances of jsPDF.                                  // 1761
	 * Examples:                                                                                                          // 1762
	 * jsPDF.API.events['initialized'] = function(){ 'this' is API object }                                               // 1763
	 * jsPDF.API.events['addFont'] = function(added_font_object){ 'this' is API object }                                  // 1764
	 *                                                                                                                    // 1765
	 * @static                                                                                                            // 1766
	 * @public                                                                                                            // 1767
	 * @memberOf jsPDF                                                                                                    // 1768
	 * @name API                                                                                                          // 1769
	 *                                                                                                                    // 1770
	 * @example                                                                                                           // 1771
	 * jsPDF.API.mymethod = function(){                                                                                   // 1772
	 *   // 'this' will be ref to internal API object. see jsPDF source                                                   // 1773
	 *   // , so you can refer to built-in methods like so:                                                               // 1774
	 *   //     this.line(....)                                                                                           // 1775
	 *   //     this.text(....)                                                                                           // 1776
	 * }                                                                                                                  // 1777
	 * var pdfdoc = new jsPDF()                                                                                           // 1778
	 * pdfdoc.mymethod() // <- !!!!!!                                                                                     // 1779
	 */                                                                                                                   // 1780
	jsPDF.API = {events:[]};                                                                                              // 1781
	jsPDF.version = "1.0.272-debug 2014-09-29T15:09:diegocr";                                                             // 1782
                                                                                                                       // 1783
	if (typeof define === 'function' && define.amd) {                                                                     // 1784
		define('jsPDF', function() {                                                                                         // 1785
			return jsPDF;                                                                                                       // 1786
		});                                                                                                                  // 1787
	} else {                                                                                                              // 1788
		global.jsPDF = jsPDF;                                                                                                // 1789
	}                                                                                                                     // 1790
	return jsPDF;                                                                                                         // 1791
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this));                            // 1792
/**                                                                                                                    // 1793
 * jsPDF addHTML PlugIn                                                                                                // 1794
 * Copyright (c) 2014 Diego Casorran                                                                                   // 1795
 *                                                                                                                     // 1796
 * Licensed under the MIT License.                                                                                     // 1797
 * http://opensource.org/licenses/mit-license                                                                          // 1798
 */                                                                                                                    // 1799
                                                                                                                       // 1800
(function (jsPDFAPI) {                                                                                                 // 1801
	'use strict';                                                                                                         // 1802
                                                                                                                       // 1803
	/**                                                                                                                   // 1804
	 * Renders an HTML element to canvas object which added as an image to the PDF                                        // 1805
	 *                                                                                                                    // 1806
	 * This PlugIn requires html2canvas: https://github.com/niklasvh/html2canvas                                          // 1807
	 *            OR rasterizeHTML: https://github.com/cburgmer/rasterizeHTML.js                                          // 1808
	 *                                                                                                                    // 1809
	 * @public                                                                                                            // 1810
	 * @function                                                                                                          // 1811
	 * @param element {Mixed} HTML Element, or anything supported by html2canvas.                                         // 1812
	 * @param x {Number} starting X coordinate in jsPDF instance's declared units.                                        // 1813
	 * @param y {Number} starting Y coordinate in jsPDF instance's declared units.                                        // 1814
	 * @param options {Object} Additional options, check the code below.                                                  // 1815
	 * @param callback {Function} to call when the rendering has finished.                                                // 1816
	 *                                                                                                                    // 1817
	 * NOTE: Every parameter is optional except 'element' and 'callback', in such                                         // 1818
	 *       case the image is positioned at 0x0 covering the whole PDF document                                          // 1819
	 *       size. Ie, to easily take screenshoots of webpages saving them to PDF.                                        // 1820
	 */                                                                                                                   // 1821
	jsPDFAPI.addHTML = function (element, x, y, options, callback) {                                                      // 1822
		'use strict';                                                                                                        // 1823
                                                                                                                       // 1824
		if(typeof html2canvas === 'undefined' && typeof rasterizeHTML === 'undefined')                                       // 1825
			throw new Error('You need either '                                                                                  // 1826
				+'https://github.com/niklasvh/html2canvas'                                                                         // 1827
				+' or https://github.com/cburgmer/rasterizeHTML.js');                                                              // 1828
                                                                                                                       // 1829
		if(typeof x !== 'number') {                                                                                          // 1830
			options = x;                                                                                                        // 1831
			callback = y;                                                                                                       // 1832
		}                                                                                                                    // 1833
                                                                                                                       // 1834
		if(typeof options === 'function') {                                                                                  // 1835
			callback = options;                                                                                                 // 1836
			options = null;                                                                                                     // 1837
		}                                                                                                                    // 1838
                                                                                                                       // 1839
		var I = this.internal, K = I.scaleFactor, W = I.pageSize.width, H = I.pageSize.height;                               // 1840
                                                                                                                       // 1841
		options = options || {};                                                                                             // 1842
		options.onrendered = function(obj) {                                                                                 // 1843
			x = parseInt(x) || 0;                                                                                               // 1844
			y = parseInt(y) || 0;                                                                                               // 1845
			var dim = options.dim || {};                                                                                        // 1846
			var h = dim.h || 0;                                                                                                 // 1847
			var w = dim.w || Math.min(W,obj.width/K) - x;                                                                       // 1848
                                                                                                                       // 1849
			var format = 'JPEG';                                                                                                // 1850
			if(options.format)                                                                                                  // 1851
				format = options.format;                                                                                           // 1852
                                                                                                                       // 1853
			if(obj.height > H && options.pagesplit) {                                                                           // 1854
				var crop = function() {                                                                                            // 1855
					var cy = 0;                                                                                                       // 1856
					while(1) {                                                                                                        // 1857
						var canvas = document.createElement('canvas');                                                                   // 1858
						canvas.width = Math.min(W*K,obj.width);                                                                          // 1859
						canvas.height = Math.min(H*K,obj.height-cy);                                                                     // 1860
						var ctx = canvas.getContext('2d');                                                                               // 1861
						ctx.drawImage(obj,0,cy,obj.width,canvas.height,0,0,canvas.width,canvas.height);                                  // 1862
						var args = [canvas, x,cy?0:y,canvas.width/K,canvas.height/K, format,null,'SLOW'];                                // 1863
						this.addImage.apply(this, args);                                                                                 // 1864
						cy += canvas.height;                                                                                             // 1865
						if(cy >= obj.height) break;                                                                                      // 1866
						this.addPage();                                                                                                  // 1867
					}                                                                                                                 // 1868
					callback(w,cy,null,args);                                                                                         // 1869
				}.bind(this);                                                                                                      // 1870
				if(obj.nodeName === 'CANVAS') {                                                                                    // 1871
					var img = new Image();                                                                                            // 1872
					img.onload = crop;                                                                                                // 1873
					img.src = obj.toDataURL("image/png");                                                                             // 1874
					obj = img;                                                                                                        // 1875
				} else {                                                                                                           // 1876
					crop();                                                                                                           // 1877
				}                                                                                                                  // 1878
			} else {                                                                                                            // 1879
				var alias = Math.random().toString(35);                                                                            // 1880
				var args = [obj, x,y,w,h, format,alias,'SLOW'];                                                                    // 1881
                                                                                                                       // 1882
				this.addImage.apply(this, args);                                                                                   // 1883
                                                                                                                       // 1884
				callback(w,h,alias,args);                                                                                          // 1885
			}                                                                                                                   // 1886
		}.bind(this);                                                                                                        // 1887
                                                                                                                       // 1888
		if(typeof html2canvas !== 'undefined' && !options.rstz) {                                                            // 1889
			return html2canvas(element, options);                                                                               // 1890
		}                                                                                                                    // 1891
                                                                                                                       // 1892
		if(typeof rasterizeHTML !== 'undefined') {                                                                           // 1893
			var meth = 'drawDocument';                                                                                          // 1894
			if(typeof element === 'string') {                                                                                   // 1895
				meth = /^http/.test(element) ? 'drawURL' : 'drawHTML';                                                             // 1896
			}                                                                                                                   // 1897
			options.width = options.width || (W*K);                                                                             // 1898
			return rasterizeHTML[meth](element, void 0, options).then(function(r) {                                             // 1899
				options.onrendered(r.image);                                                                                       // 1900
			}, function(e) {                                                                                                    // 1901
				callback(null,e);                                                                                                  // 1902
			});                                                                                                                 // 1903
		}                                                                                                                    // 1904
                                                                                                                       // 1905
		return null;                                                                                                         // 1906
	};                                                                                                                    // 1907
})(jsPDF.API);                                                                                                         // 1908
/** @preserve                                                                                                          // 1909
 * jsPDF addImage plugin                                                                                               // 1910
 * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/                                                      // 1911
 *               2013 Chris Dowling, https://github.com/gingerchris                                                    // 1912
 *               2013 Trinh Ho, https://github.com/ineedfat                                                            // 1913
 *               2013 Edwin Alejandro Perez, https://github.com/eaparango                                              // 1914
 *               2013 Norah Smith, https://github.com/burnburnrocket                                                   // 1915
 *               2014 Diego Casorran, https://github.com/diegocr                                                       // 1916
 *               2014 James Robb, https://github.com/jamesbrobb                                                        // 1917
 *                                                                                                                     // 1918
 * Permission is hereby granted, free of charge, to any person obtaining                                               // 1919
 * a copy of this software and associated documentation files (the                                                     // 1920
 * "Software"), to deal in the Software without restriction, including                                                 // 1921
 * without limitation the rights to use, copy, modify, merge, publish,                                                 // 1922
 * distribute, sublicense, and/or sell copies of the Software, and to                                                  // 1923
 * permit persons to whom the Software is furnished to do so, subject to                                               // 1924
 * the following conditions:                                                                                           // 1925
 *                                                                                                                     // 1926
 * The above copyright notice and this permission notice shall be                                                      // 1927
 * included in all copies or substantial portions of the Software.                                                     // 1928
 *                                                                                                                     // 1929
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,                                                     // 1930
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                  // 1931
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                                                               // 1932
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE                                              // 1933
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION                                              // 1934
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION                                               // 1935
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                                     // 1936
 */                                                                                                                    // 1937
                                                                                                                       // 1938
;(function(jsPDFAPI) {                                                                                                 // 1939
	'use strict'                                                                                                          // 1940
                                                                                                                       // 1941
	var namespace = 'addImage_',                                                                                          // 1942
		supported_image_types = ['jpeg', 'jpg', 'png'];                                                                      // 1943
                                                                                                                       // 1944
	// Image functionality ported from pdf.js                                                                             // 1945
	var putImage = function(img) {                                                                                        // 1946
                                                                                                                       // 1947
		var objectNumber = this.internal.newObject()                                                                         // 1948
		, out = this.internal.write                                                                                          // 1949
		, putStream = this.internal.putStream                                                                                // 1950
                                                                                                                       // 1951
		img['n'] = objectNumber                                                                                              // 1952
                                                                                                                       // 1953
		out('<</Type /XObject')                                                                                              // 1954
		out('/Subtype /Image')                                                                                               // 1955
		out('/Width ' + img['w'])                                                                                            // 1956
		out('/Height ' + img['h'])                                                                                           // 1957
		if (img['cs'] === this.color_spaces.INDEXED) {                                                                       // 1958
			out('/ColorSpace [/Indexed /DeviceRGB '                                                                             // 1959
					// if an indexed png defines more than one colour with transparency, we've created a smask                        // 1960
					+ (img['pal'].length / 3 - 1) + ' ' + ('smask' in img ? objectNumber + 2 : objectNumber + 1)                      // 1961
					+ ' 0 R]');                                                                                                       // 1962
		} else {                                                                                                             // 1963
			out('/ColorSpace /' + img['cs']);                                                                                   // 1964
			if (img['cs'] === this.color_spaces.DEVICE_CMYK) {                                                                  // 1965
				out('/Decode [1 0 1 0 1 0 1 0]');                                                                                  // 1966
			}                                                                                                                   // 1967
		}                                                                                                                    // 1968
		out('/BitsPerComponent ' + img['bpc']);                                                                              // 1969
		if ('f' in img) {                                                                                                    // 1970
			out('/Filter /' + img['f']);                                                                                        // 1971
		}                                                                                                                    // 1972
		if ('dp' in img) {                                                                                                   // 1973
			out('/DecodeParms <<' + img['dp'] + '>>');                                                                          // 1974
		}                                                                                                                    // 1975
		if ('trns' in img && img['trns'].constructor == Array) {                                                             // 1976
			var trns = '',                                                                                                      // 1977
				i = 0,                                                                                                             // 1978
				len = img['trns'].length;                                                                                          // 1979
			for (; i < len; i++)                                                                                                // 1980
				trns += (img['trns'][i] + ' ' + img['trns'][i] + ' ');                                                             // 1981
			out('/Mask [' + trns + ']');                                                                                        // 1982
		}                                                                                                                    // 1983
		if ('smask' in img) {                                                                                                // 1984
			out('/SMask ' + (objectNumber + 1) + ' 0 R');                                                                       // 1985
		}                                                                                                                    // 1986
		out('/Length ' + img['data'].length + '>>');                                                                         // 1987
                                                                                                                       // 1988
		putStream(img['data']);                                                                                              // 1989
                                                                                                                       // 1990
		out('endobj');                                                                                                       // 1991
                                                                                                                       // 1992
		// Soft mask                                                                                                         // 1993
		if ('smask' in img) {                                                                                                // 1994
			var dp = '/Predictor 15 /Colors 1 /BitsPerComponent ' + img['bpc'] + ' /Columns ' + img['w'];                       // 1995
			var smask = {'w': img['w'], 'h': img['h'], 'cs': 'DeviceGray', 'bpc': img['bpc'], 'dp': dp, 'data': img['smask']};  // 1996
			if ('f' in img)                                                                                                     // 1997
				smask.f = img['f'];                                                                                                // 1998
			putImage.call(this, smask);                                                                                         // 1999
		}                                                                                                                    // 2000
                                                                                                                       // 2001
	    //Palette                                                                                                         // 2002
		if (img['cs'] === this.color_spaces.INDEXED) {                                                                       // 2003
                                                                                                                       // 2004
			this.internal.newObject();                                                                                          // 2005
			//out('<< /Filter / ' + img['f'] +' /Length ' + img['pal'].length + '>>');                                          // 2006
			//putStream(zlib.compress(img['pal']));                                                                             // 2007
			out('<< /Length ' + img['pal'].length + '>>');                                                                      // 2008
			putStream(this.arrayBufferToBinaryString(new Uint8Array(img['pal'])));                                              // 2009
			out('endobj');                                                                                                      // 2010
		}                                                                                                                    // 2011
	}                                                                                                                     // 2012
	, putResourcesCallback = function() {                                                                                 // 2013
		var images = this.internal.collections[namespace + 'images']                                                         // 2014
		for ( var i in images ) {                                                                                            // 2015
			putImage.call(this, images[i])                                                                                      // 2016
		}                                                                                                                    // 2017
	}                                                                                                                     // 2018
	, putXObjectsDictCallback = function(){                                                                               // 2019
		var images = this.internal.collections[namespace + 'images']                                                         // 2020
		, out = this.internal.write                                                                                          // 2021
		, image                                                                                                              // 2022
		for (var i in images) {                                                                                              // 2023
			image = images[i]                                                                                                   // 2024
			out(                                                                                                                // 2025
				'/I' + image['i']                                                                                                  // 2026
				, image['n']                                                                                                       // 2027
				, '0'                                                                                                              // 2028
				, 'R'                                                                                                              // 2029
			)                                                                                                                   // 2030
		}                                                                                                                    // 2031
	}                                                                                                                     // 2032
	, checkCompressValue = function(value) {                                                                              // 2033
		if(value && typeof value === 'string')                                                                               // 2034
			value = value.toUpperCase();                                                                                        // 2035
		return value in jsPDFAPI.image_compression ? value : jsPDFAPI.image_compression.NONE;                                // 2036
	}                                                                                                                     // 2037
	, getImages = function() {                                                                                            // 2038
		var images = this.internal.collections[namespace + 'images'];                                                        // 2039
		//first run, so initialise stuff                                                                                     // 2040
		if(!images) {                                                                                                        // 2041
			this.internal.collections[namespace + 'images'] = images = {};                                                      // 2042
			this.internal.events.subscribe('putResources', putResourcesCallback);                                               // 2043
			this.internal.events.subscribe('putXobjectDict', putXObjectsDictCallback);                                          // 2044
		}                                                                                                                    // 2045
                                                                                                                       // 2046
		return images;                                                                                                       // 2047
	}                                                                                                                     // 2048
	, getImageIndex = function(images) {                                                                                  // 2049
		var imageIndex = 0;                                                                                                  // 2050
                                                                                                                       // 2051
		if (images){                                                                                                         // 2052
			// this is NOT the first time this method is ran on this instance of jsPDF object.                                  // 2053
			imageIndex = Object.keys ?                                                                                          // 2054
			Object.keys(images).length :                                                                                        // 2055
			(function(o){                                                                                                       // 2056
				var i = 0                                                                                                          // 2057
				for (var e in o){if(o.hasOwnProperty(e)){ i++ }}                                                                   // 2058
				return i                                                                                                           // 2059
			})(images)                                                                                                          // 2060
		}                                                                                                                    // 2061
                                                                                                                       // 2062
		return imageIndex;                                                                                                   // 2063
	}                                                                                                                     // 2064
	, notDefined = function(value) {                                                                                      // 2065
		return typeof value === 'undefined' || value === null;                                                               // 2066
	}                                                                                                                     // 2067
	, generateAliasFromData = function(data) {                                                                            // 2068
		return typeof data === 'string' && jsPDFAPI.sHashCode(data);                                                         // 2069
	}                                                                                                                     // 2070
	, doesNotSupportImageType = function(type) {                                                                          // 2071
		return supported_image_types.indexOf(type) === -1;                                                                   // 2072
	}                                                                                                                     // 2073
	, processMethodNotEnabled = function(type) {                                                                          // 2074
		return typeof jsPDFAPI['process' + type.toUpperCase()] !== 'function';                                               // 2075
	}                                                                                                                     // 2076
	, isDOMElement = function(object) {                                                                                   // 2077
		return typeof object === 'object' && object.nodeType === 1;                                                          // 2078
	}                                                                                                                     // 2079
	, createDataURIFromElement = function(element, format, angle) {                                                       // 2080
                                                                                                                       // 2081
		//if element is an image which uses data url defintion, just return the dataurl                                      // 2082
		if (element.nodeName === 'IMG' && element.hasAttribute('src')) {                                                     // 2083
			var src = ''+element.getAttribute('src');                                                                           // 2084
			if (!angle && src.indexOf('data:image/') === 0) return src;                                                         // 2085
                                                                                                                       // 2086
			// only if the user doesn't care about a format                                                                     // 2087
			if (!format && /\.png(?:[?#].*)?$/i.test(src)) format = 'png';                                                      // 2088
		}                                                                                                                    // 2089
                                                                                                                       // 2090
		if(element.nodeName === 'CANVAS') {                                                                                  // 2091
			var canvas = element;                                                                                               // 2092
		} else {                                                                                                             // 2093
			var canvas = document.createElement('canvas');                                                                      // 2094
			canvas.width = element.clientWidth || element.width;                                                                // 2095
			canvas.height = element.clientHeight || element.height;                                                             // 2096
                                                                                                                       // 2097
			var ctx = canvas.getContext('2d');                                                                                  // 2098
			if (!ctx) {                                                                                                         // 2099
				throw ('addImage requires canvas to be supported by browser.');                                                    // 2100
			}                                                                                                                   // 2101
			if (angle) {                                                                                                        // 2102
				var x, y, b, c, s, w, h, to_radians = Math.PI/180, angleInRadians;                                                 // 2103
                                                                                                                       // 2104
				if (typeof angle === 'object') {                                                                                   // 2105
					x = angle.x;                                                                                                      // 2106
					y = angle.y;                                                                                                      // 2107
					b = angle.bg;                                                                                                     // 2108
					angle = angle.angle;                                                                                              // 2109
				}                                                                                                                  // 2110
				angleInRadians = angle*to_radians;                                                                                 // 2111
				c = Math.abs(Math.cos(angleInRadians));                                                                            // 2112
				s = Math.abs(Math.sin(angleInRadians));                                                                            // 2113
				w = canvas.width;                                                                                                  // 2114
				h = canvas.height;                                                                                                 // 2115
				canvas.width = h * s + w * c;                                                                                      // 2116
				canvas.height = h * c + w * s;                                                                                     // 2117
                                                                                                                       // 2118
				if (isNaN(x)) x = canvas.width / 2;                                                                                // 2119
				if (isNaN(y)) y = canvas.height / 2;                                                                               // 2120
                                                                                                                       // 2121
				ctx.clearRect(0,0,canvas.width, canvas.height);                                                                    // 2122
				ctx.fillStyle = b || 'white';                                                                                      // 2123
				ctx.fillRect(0, 0, canvas.width, canvas.height);                                                                   // 2124
				ctx.save();                                                                                                        // 2125
				ctx.translate(x, y);                                                                                               // 2126
				ctx.rotate(angleInRadians);                                                                                        // 2127
				ctx.drawImage(element, -(w/2), -(h/2));                                                                            // 2128
				ctx.rotate(-angleInRadians);                                                                                       // 2129
				ctx.translate(-x, -y);                                                                                             // 2130
				ctx.restore();                                                                                                     // 2131
			} else {                                                                                                            // 2132
				ctx.drawImage(element, 0, 0, canvas.width, canvas.height);                                                         // 2133
			}                                                                                                                   // 2134
		}                                                                                                                    // 2135
		return canvas.toDataURL((''+format).toLowerCase() == 'png' ? 'image/png' : 'image/jpeg');                            // 2136
	}                                                                                                                     // 2137
	,checkImagesForAlias = function(alias, images) {                                                                      // 2138
		var cached_info;                                                                                                     // 2139
		if(images) {                                                                                                         // 2140
			for(var e in images) {                                                                                              // 2141
				if(alias === images[e].alias) {                                                                                    // 2142
					cached_info = images[e];                                                                                          // 2143
					break;                                                                                                            // 2144
				}                                                                                                                  // 2145
			}                                                                                                                   // 2146
		}                                                                                                                    // 2147
		return cached_info;                                                                                                  // 2148
	}                                                                                                                     // 2149
	,determineWidthAndHeight = function(w, h, info) {                                                                     // 2150
		if (!w && !h) {                                                                                                      // 2151
			w = -96;                                                                                                            // 2152
			h = -96;                                                                                                            // 2153
		}                                                                                                                    // 2154
		if (w < 0) {                                                                                                         // 2155
			w = (-1) * info['w'] * 72 / w / this.internal.scaleFactor;                                                          // 2156
		}                                                                                                                    // 2157
		if (h < 0) {                                                                                                         // 2158
			h = (-1) * info['h'] * 72 / h / this.internal.scaleFactor;                                                          // 2159
		}                                                                                                                    // 2160
		if (w === 0) {                                                                                                       // 2161
			w = h * info['w'] / info['h'];                                                                                      // 2162
		}                                                                                                                    // 2163
		if (h === 0) {                                                                                                       // 2164
			h = w * info['h'] / info['w'];                                                                                      // 2165
		}                                                                                                                    // 2166
                                                                                                                       // 2167
		return [w, h];                                                                                                       // 2168
	}                                                                                                                     // 2169
	, writeImageToPDF = function(x, y, w, h, info, index, images) {                                                       // 2170
		var dims = determineWidthAndHeight.call(this, w, h, info),                                                           // 2171
			coord = this.internal.getCoordinateString,                                                                          // 2172
			vcoord = this.internal.getVerticalCoordinateString;                                                                 // 2173
                                                                                                                       // 2174
		w = dims[0];                                                                                                         // 2175
		h = dims[1];                                                                                                         // 2176
                                                                                                                       // 2177
		images[index] = info;                                                                                                // 2178
                                                                                                                       // 2179
		this.internal.write(                                                                                                 // 2180
			'q'                                                                                                                 // 2181
			, coord(w)                                                                                                          // 2182
			, '0 0'                                                                                                             // 2183
			, coord(h) // TODO: check if this should be shifted by vcoord                                                       // 2184
			, coord(x)                                                                                                          // 2185
			, vcoord(y + h)                                                                                                     // 2186
			, 'cm /I'+info['i']                                                                                                 // 2187
			, 'Do Q'                                                                                                            // 2188
		)                                                                                                                    // 2189
	};                                                                                                                    // 2190
                                                                                                                       // 2191
	/**                                                                                                                   // 2192
	 * COLOR SPACES                                                                                                       // 2193
	 */                                                                                                                   // 2194
	jsPDFAPI.color_spaces = {                                                                                             // 2195
		DEVICE_RGB:'DeviceRGB',                                                                                              // 2196
		DEVICE_GRAY:'DeviceGray',                                                                                            // 2197
		DEVICE_CMYK:'DeviceCMYK',                                                                                            // 2198
		CAL_GREY:'CalGray',                                                                                                  // 2199
		CAL_RGB:'CalRGB',                                                                                                    // 2200
		LAB:'Lab',                                                                                                           // 2201
		ICC_BASED:'ICCBased',                                                                                                // 2202
		INDEXED:'Indexed',                                                                                                   // 2203
		PATTERN:'Pattern',                                                                                                   // 2204
		SEPERATION:'Seperation',                                                                                             // 2205
		DEVICE_N:'DeviceN'                                                                                                   // 2206
	};                                                                                                                    // 2207
                                                                                                                       // 2208
	/**                                                                                                                   // 2209
	 * DECODE METHODS                                                                                                     // 2210
	 */                                                                                                                   // 2211
	jsPDFAPI.decode = {                                                                                                   // 2212
		DCT_DECODE:'DCTDecode',                                                                                              // 2213
		FLATE_DECODE:'FlateDecode',                                                                                          // 2214
		LZW_DECODE:'LZWDecode',                                                                                              // 2215
		JPX_DECODE:'JPXDecode',                                                                                              // 2216
		JBIG2_DECODE:'JBIG2Decode',                                                                                          // 2217
		ASCII85_DECODE:'ASCII85Decode',                                                                                      // 2218
		ASCII_HEX_DECODE:'ASCIIHexDecode',                                                                                   // 2219
		RUN_LENGTH_DECODE:'RunLengthDecode',                                                                                 // 2220
		CCITT_FAX_DECODE:'CCITTFaxDecode'                                                                                    // 2221
	};                                                                                                                    // 2222
                                                                                                                       // 2223
	/**                                                                                                                   // 2224
	 * IMAGE COMPRESSION TYPES                                                                                            // 2225
	 */                                                                                                                   // 2226
	jsPDFAPI.image_compression = {                                                                                        // 2227
		NONE: 'NONE',                                                                                                        // 2228
		FAST: 'FAST',                                                                                                        // 2229
		MEDIUM: 'MEDIUM',                                                                                                    // 2230
		SLOW: 'SLOW'                                                                                                         // 2231
	};                                                                                                                    // 2232
                                                                                                                       // 2233
	jsPDFAPI.sHashCode = function(str) {                                                                                  // 2234
		return Array.prototype.reduce && str.split("").reduce(function(a,b){a=((a<<5)-a)+b.charCodeAt(0);return a&a},0);     // 2235
	};                                                                                                                    // 2236
                                                                                                                       // 2237
	jsPDFAPI.isString = function(object) {                                                                                // 2238
		return typeof object === 'string';                                                                                   // 2239
	};                                                                                                                    // 2240
                                                                                                                       // 2241
	/**                                                                                                                   // 2242
	 * Strips out and returns info from a valid base64 data URI                                                           // 2243
	 * @param {String[dataURI]} a valid data URI of format 'data:[<MIME-type>][;base64],<data>'                           // 2244
	 * @returns an Array containing the following                                                                         // 2245
	 * [0] the complete data URI                                                                                          // 2246
	 * [1] <MIME-type>                                                                                                    // 2247
	 * [2] format - the second part of the mime-type i.e 'png' in 'image/png'                                             // 2248
	 * [4] <data>                                                                                                         // 2249
	 */                                                                                                                   // 2250
	jsPDFAPI.extractInfoFromBase64DataURI = function(dataURI) {                                                           // 2251
		return /^data:([\w]+?\/([\w]+?));base64,(.+?)$/g.exec(dataURI);                                                      // 2252
	};                                                                                                                    // 2253
                                                                                                                       // 2254
	/**                                                                                                                   // 2255
	 * Check to see if ArrayBuffer is supported                                                                           // 2256
	 */                                                                                                                   // 2257
	jsPDFAPI.supportsArrayBuffer = function() {                                                                           // 2258
		return typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';                                      // 2259
	};                                                                                                                    // 2260
                                                                                                                       // 2261
	/**                                                                                                                   // 2262
	 * Tests supplied object to determine if ArrayBuffer                                                                  // 2263
	 * @param {Object[object]}                                                                                            // 2264
	 */                                                                                                                   // 2265
	jsPDFAPI.isArrayBuffer = function(object) {                                                                           // 2266
		if(!this.supportsArrayBuffer())                                                                                      // 2267
	        return false;                                                                                                 // 2268
		return object instanceof ArrayBuffer;                                                                                // 2269
	};                                                                                                                    // 2270
                                                                                                                       // 2271
	/**                                                                                                                   // 2272
	 * Tests supplied object to determine if it implements the ArrayBufferView (TypedArray) interface                     // 2273
	 * @param {Object[object]}                                                                                            // 2274
	 */                                                                                                                   // 2275
	jsPDFAPI.isArrayBufferView = function(object) {                                                                       // 2276
		if(!this.supportsArrayBuffer())                                                                                      // 2277
	        return false;                                                                                                 // 2278
		if(typeof Uint32Array === 'undefined')                                                                               // 2279
			return false;                                                                                                       // 2280
		return (object instanceof Int8Array ||                                                                               // 2281
				object instanceof Uint8Array ||                                                                                    // 2282
				(typeof Uint8ClampedArray !== 'undefined' && object instanceof Uint8ClampedArray) ||                               // 2283
				object instanceof Int16Array ||                                                                                    // 2284
				object instanceof Uint16Array ||                                                                                   // 2285
				object instanceof Int32Array ||                                                                                    // 2286
				object instanceof Uint32Array ||                                                                                   // 2287
				object instanceof Float32Array ||                                                                                  // 2288
				object instanceof Float64Array );                                                                                  // 2289
	};                                                                                                                    // 2290
                                                                                                                       // 2291
	/**                                                                                                                   // 2292
	 * Exactly what it says on the tin                                                                                    // 2293
	 */                                                                                                                   // 2294
	jsPDFAPI.binaryStringToUint8Array = function(binary_string) {                                                         // 2295
		/*                                                                                                                   // 2296
		 * not sure how efficient this will be will bigger files. Is there a native method?                                  // 2297
		 */                                                                                                                  // 2298
		var len = binary_string.length;                                                                                      // 2299
	    var bytes = new Uint8Array( len );                                                                                // 2300
	    for (var i = 0; i < len; i++) {                                                                                   // 2301
	        bytes[i] = binary_string.charCodeAt(i);                                                                       // 2302
	    }                                                                                                                 // 2303
	    return bytes;                                                                                                     // 2304
	};                                                                                                                    // 2305
                                                                                                                       // 2306
	/**                                                                                                                   // 2307
	 * @see this discussion                                                                                               // 2308
	 * http://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers                             // 2309
	 *                                                                                                                    // 2310
	 * As stated, i imagine the method below is highly inefficent for large files.                                        // 2311
	 *                                                                                                                    // 2312
	 * Also of note from Mozilla,                                                                                         // 2313
	 *                                                                                                                    // 2314
	 * "However, this is slow and error-prone, due to the need for multiple conversions (especially if the binary data is not actually byte-format data, but, for example, 32-bit integers or floats)."
	 *                                                                                                                    // 2316
	 * https://developer.mozilla.org/en-US/Add-ons/Code_snippets/StringView                                               // 2317
	 *                                                                                                                    // 2318
	 * Although i'm strugglig to see how StringView solves this issue? Doesn't appear to be a direct method for conversion?
	 *                                                                                                                    // 2320
	 * Async method using Blob and FileReader could be best, but i'm not sure how to fit it into the flow?                // 2321
	 */                                                                                                                   // 2322
	jsPDFAPI.arrayBufferToBinaryString = function(buffer) {                                                               // 2323
		if(this.isArrayBuffer(buffer))                                                                                       // 2324
			buffer = new Uint8Array(buffer);                                                                                    // 2325
                                                                                                                       // 2326
	    var binary_string = '';                                                                                           // 2327
	    var len = buffer.byteLength;                                                                                      // 2328
	    for (var i = 0; i < len; i++) {                                                                                   // 2329
	        binary_string += String.fromCharCode(buffer[i]);                                                              // 2330
	    }                                                                                                                 // 2331
	    return binary_string;                                                                                             // 2332
	    /*                                                                                                                // 2333
	     * Another solution is the method below - convert array buffer straight to base64 and then use atob               // 2334
	     */                                                                                                               // 2335
		//return atob(this.arrayBufferToBase64(buffer));                                                                     // 2336
	};                                                                                                                    // 2337
                                                                                                                       // 2338
	/**                                                                                                                   // 2339
	 * Converts an ArrayBuffer directly to base64                                                                         // 2340
	 *                                                                                                                    // 2341
	 * Taken from here                                                                                                    // 2342
	 *                                                                                                                    // 2343
	 * http://jsperf.com/encoding-xhr-image-data/31                                                                       // 2344
	 *                                                                                                                    // 2345
	 * Need to test if this is a better solution for larger files                                                         // 2346
	 *                                                                                                                    // 2347
	 */                                                                                                                   // 2348
	jsPDFAPI.arrayBufferToBase64 = function(arrayBuffer) {                                                                // 2349
		var base64    = ''                                                                                                   // 2350
		var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'                                   // 2351
                                                                                                                       // 2352
		var bytes         = new Uint8Array(arrayBuffer)                                                                      // 2353
		var byteLength    = bytes.byteLength                                                                                 // 2354
		var byteRemainder = byteLength % 3                                                                                   // 2355
		var mainLength    = byteLength - byteRemainder                                                                       // 2356
                                                                                                                       // 2357
		var a, b, c, d                                                                                                       // 2358
		var chunk                                                                                                            // 2359
                                                                                                                       // 2360
		// Main loop deals with bytes in chunks of 3                                                                         // 2361
		for (var i = 0; i < mainLength; i = i + 3) {                                                                         // 2362
			// Combine the three bytes into a single integer                                                                    // 2363
			chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]                                                       // 2364
                                                                                                                       // 2365
			// Use bitmasks to extract 6-bit segments from the triplet                                                          // 2366
			a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18                                                          // 2367
			b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12                                                          // 2368
			c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6                                                           // 2369
			d = chunk & 63               // 63       = 2^6 - 1                                                                  // 2370
                                                                                                                       // 2371
			// Convert the raw binary segments to the appropriate ASCII encoding                                                // 2372
			base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]                                                 // 2373
		}                                                                                                                    // 2374
                                                                                                                       // 2375
		// Deal with the remaining bytes and padding                                                                         // 2376
		if (byteRemainder == 1) {                                                                                            // 2377
			chunk = bytes[mainLength]                                                                                           // 2378
                                                                                                                       // 2379
			a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2                                                                      // 2380
                                                                                                                       // 2381
			// Set the 4 least significant bits to zero                                                                         // 2382
			b = (chunk & 3)   << 4 // 3   = 2^2 - 1                                                                             // 2383
                                                                                                                       // 2384
			base64 += encodings[a] + encodings[b] + '=='                                                                        // 2385
		} else if (byteRemainder == 2) {                                                                                     // 2386
			chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]                                                            // 2387
                                                                                                                       // 2388
			a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10                                                                // 2389
			b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4                                                                 // 2390
                                                                                                                       // 2391
			// Set the 2 least significant bits to zero                                                                         // 2392
			c = (chunk & 15)    <<  2 // 15    = 2^4 - 1                                                                        // 2393
                                                                                                                       // 2394
			base64 += encodings[a] + encodings[b] + encodings[c] + '='                                                          // 2395
		}                                                                                                                    // 2396
                                                                                                                       // 2397
		return base64                                                                                                        // 2398
	};                                                                                                                    // 2399
                                                                                                                       // 2400
	jsPDFAPI.createImageInfo = function(data, wd, ht, cs, bpc, f, imageIndex, alias, dp, trns, pal, smask) {              // 2401
		var info = {                                                                                                         // 2402
				alias:alias,                                                                                                       // 2403
				w : wd,                                                                                                            // 2404
				h : ht,                                                                                                            // 2405
				cs : cs,                                                                                                           // 2406
				bpc : bpc,                                                                                                         // 2407
				i : imageIndex,                                                                                                    // 2408
				data : data                                                                                                        // 2409
				// n: objectNumber will be added by putImage code                                                                  // 2410
			};                                                                                                                  // 2411
                                                                                                                       // 2412
		if(f) info.f = f;                                                                                                    // 2413
		if(dp) info.dp = dp;                                                                                                 // 2414
		if(trns) info.trns = trns;                                                                                           // 2415
		if(pal) info.pal = pal;                                                                                              // 2416
		if(smask) info.smask = smask;                                                                                        // 2417
                                                                                                                       // 2418
		return info;                                                                                                         // 2419
	};                                                                                                                    // 2420
                                                                                                                       // 2421
	jsPDFAPI.addImage = function(imageData, format, x, y, w, h, alias, compression, rotation) {                           // 2422
		'use strict'                                                                                                         // 2423
                                                                                                                       // 2424
		if(typeof format !== 'string') {                                                                                     // 2425
			var tmp = h;                                                                                                        // 2426
			h = w;                                                                                                              // 2427
			w = y;                                                                                                              // 2428
			y = x;                                                                                                              // 2429
			x = format;                                                                                                         // 2430
			format = tmp;                                                                                                       // 2431
		}                                                                                                                    // 2432
                                                                                                                       // 2433
		if (typeof imageData === 'object' && !isDOMElement(imageData) && "imageData" in imageData) {                         // 2434
			var options = imageData;                                                                                            // 2435
                                                                                                                       // 2436
			imageData = options.imageData;                                                                                      // 2437
			format = options.format || format;                                                                                  // 2438
			x = options.x || x || 0;                                                                                            // 2439
			y = options.y || y || 0;                                                                                            // 2440
			w = options.w || w;                                                                                                 // 2441
			h = options.h || h;                                                                                                 // 2442
			alias = options.alias || alias;                                                                                     // 2443
			compression = options.compression || compression;                                                                   // 2444
			rotation = options.rotation || options.angle || rotation;                                                           // 2445
		}                                                                                                                    // 2446
                                                                                                                       // 2447
		if (isNaN(x) || isNaN(y))                                                                                            // 2448
		{                                                                                                                    // 2449
			console.error('jsPDF.addImage: Invalid coordinates', arguments);                                                    // 2450
			throw new Error('Invalid coordinates passed to jsPDF.addImage');                                                    // 2451
		}                                                                                                                    // 2452
                                                                                                                       // 2453
		var images = getImages.call(this), info;                                                                             // 2454
                                                                                                                       // 2455
		if (!(info = checkImagesForAlias(imageData, images))) {                                                              // 2456
			var dataAsBinaryString;                                                                                             // 2457
                                                                                                                       // 2458
			if(isDOMElement(imageData))                                                                                         // 2459
				imageData = createDataURIFromElement(imageData, format, rotation);                                                 // 2460
                                                                                                                       // 2461
			if(notDefined(alias))                                                                                               // 2462
				alias = generateAliasFromData(imageData);                                                                          // 2463
                                                                                                                       // 2464
			if (!(info = checkImagesForAlias(alias, images))) {                                                                 // 2465
                                                                                                                       // 2466
				if(this.isString(imageData)) {                                                                                     // 2467
                                                                                                                       // 2468
					var base64Info = this.extractInfoFromBase64DataURI(imageData);                                                    // 2469
                                                                                                                       // 2470
					if(base64Info) {                                                                                                  // 2471
                                                                                                                       // 2472
						format = base64Info[2];                                                                                          // 2473
						imageData = atob(base64Info[3]);//convert to binary string                                                       // 2474
                                                                                                                       // 2475
					} else {                                                                                                          // 2476
                                                                                                                       // 2477
						if (imageData.charCodeAt(0) === 0x89 &&                                                                          // 2478
							imageData.charCodeAt(1) === 0x50 &&                                                                             // 2479
							imageData.charCodeAt(2) === 0x4e &&                                                                             // 2480
							imageData.charCodeAt(3) === 0x47  )  format = 'png';                                                            // 2481
					}                                                                                                                 // 2482
				}                                                                                                                  // 2483
				format = (format || 'JPEG').toLowerCase();                                                                         // 2484
                                                                                                                       // 2485
				if(doesNotSupportImageType(format))                                                                                // 2486
					throw new Error('addImage currently only supports formats ' + supported_image_types + ', not \''+format+'\'');    // 2487
                                                                                                                       // 2488
				if(processMethodNotEnabled(format))                                                                                // 2489
					throw new Error('please ensure that the plugin for \''+format+'\' support is added');                             // 2490
                                                                                                                       // 2491
				/**                                                                                                                // 2492
				 * need to test if it's more efficent to convert all binary strings                                                // 2493
				 * to TypedArray - or should we just leave and process as string?                                                  // 2494
				 */                                                                                                                // 2495
				if(this.supportsArrayBuffer()) {                                                                                   // 2496
					dataAsBinaryString = imageData;                                                                                   // 2497
					imageData = this.binaryStringToUint8Array(imageData);                                                             // 2498
				}                                                                                                                  // 2499
                                                                                                                       // 2500
				info = this['process' + format.toUpperCase()](                                                                     // 2501
					imageData,                                                                                                        // 2502
					getImageIndex(images),                                                                                            // 2503
					alias,                                                                                                            // 2504
					checkCompressValue(compression),                                                                                  // 2505
					dataAsBinaryString                                                                                                // 2506
				);                                                                                                                 // 2507
                                                                                                                       // 2508
				if(!info)                                                                                                          // 2509
					throw new Error('An unkwown error occurred whilst processing the image');                                         // 2510
			}                                                                                                                   // 2511
		}                                                                                                                    // 2512
                                                                                                                       // 2513
		writeImageToPDF.call(this, x, y, w, h, info, info.i, images);                                                        // 2514
                                                                                                                       // 2515
		return this                                                                                                          // 2516
	};                                                                                                                    // 2517
                                                                                                                       // 2518
	/**                                                                                                                   // 2519
	 * JPEG SUPPORT                                                                                                       // 2520
	 **/                                                                                                                  // 2521
                                                                                                                       // 2522
	//takes a string imgData containing the raw bytes of                                                                  // 2523
	//a jpeg image and returns [width, height]                                                                            // 2524
	//Algorithm from: http://www.64lines.com/jpeg-width-height                                                            // 2525
	var getJpegSize = function(imgData) {                                                                                 // 2526
		'use strict'                                                                                                         // 2527
		var width, height, numcomponents;                                                                                    // 2528
		// Verify we have a valid jpeg header 0xff,0xd8,0xff,0xe0,?,?,'J','F','I','F',0x00                                   // 2529
		if (!imgData.charCodeAt(0) === 0xff ||                                                                               // 2530
			!imgData.charCodeAt(1) === 0xd8 ||                                                                                  // 2531
			!imgData.charCodeAt(2) === 0xff ||                                                                                  // 2532
			!imgData.charCodeAt(3) === 0xe0 ||                                                                                  // 2533
			!imgData.charCodeAt(6) === 'J'.charCodeAt(0) ||                                                                     // 2534
			!imgData.charCodeAt(7) === 'F'.charCodeAt(0) ||                                                                     // 2535
			!imgData.charCodeAt(8) === 'I'.charCodeAt(0) ||                                                                     // 2536
			!imgData.charCodeAt(9) === 'F'.charCodeAt(0) ||                                                                     // 2537
			!imgData.charCodeAt(10) === 0x00) {                                                                                 // 2538
				throw new Error('getJpegSize requires a binary string jpeg file')                                                  // 2539
		}                                                                                                                    // 2540
		var blockLength = imgData.charCodeAt(4)*256 + imgData.charCodeAt(5);                                                 // 2541
		var i = 4, len = imgData.length;                                                                                     // 2542
		while ( i < len ) {                                                                                                  // 2543
			i += blockLength;                                                                                                   // 2544
			if (imgData.charCodeAt(i) !== 0xff) {                                                                               // 2545
				throw new Error('getJpegSize could not find the size of the image');                                               // 2546
			}                                                                                                                   // 2547
			if (imgData.charCodeAt(i+1) === 0xc0 || //(SOF) Huffman  - Baseline DCT                                             // 2548
			    imgData.charCodeAt(i+1) === 0xc1 || //(SOF) Huffman  - Extended sequential DCT                                  // 2549
			    imgData.charCodeAt(i+1) === 0xc2 || // Progressive DCT (SOF2)                                                   // 2550
			    imgData.charCodeAt(i+1) === 0xc3 || // Spatial (sequential) lossless (SOF3)                                     // 2551
			    imgData.charCodeAt(i+1) === 0xc4 || // Differential sequential DCT (SOF5)                                       // 2552
			    imgData.charCodeAt(i+1) === 0xc5 || // Differential progressive DCT (SOF6)                                      // 2553
			    imgData.charCodeAt(i+1) === 0xc6 || // Differential spatial (SOF7)                                              // 2554
			    imgData.charCodeAt(i+1) === 0xc7) {                                                                             // 2555
				height = imgData.charCodeAt(i+5)*256 + imgData.charCodeAt(i+6);                                                    // 2556
				width = imgData.charCodeAt(i+7)*256 + imgData.charCodeAt(i+8);                                                     // 2557
                numcomponents = imgData.charCodeAt(i+9);                                                               // 2558
				return [width, height, numcomponents];                                                                             // 2559
			} else {                                                                                                            // 2560
				i += 2;                                                                                                            // 2561
				blockLength = imgData.charCodeAt(i)*256 + imgData.charCodeAt(i+1)                                                  // 2562
			}                                                                                                                   // 2563
		}                                                                                                                    // 2564
	}                                                                                                                     // 2565
	, getJpegSizeFromBytes = function(data) {                                                                             // 2566
                                                                                                                       // 2567
		var hdr = (data[0] << 8) | data[1];                                                                                  // 2568
                                                                                                                       // 2569
		if(hdr !== 0xFFD8)                                                                                                   // 2570
			throw new Error('Supplied data is not a JPEG');                                                                     // 2571
                                                                                                                       // 2572
		var len = data.length,                                                                                               // 2573
			block = (data[4] << 8) + data[5],                                                                                   // 2574
			pos = 4,                                                                                                            // 2575
			bytes, width, height, numcomponents;                                                                                // 2576
                                                                                                                       // 2577
		while(pos < len) {                                                                                                   // 2578
			pos += block;                                                                                                       // 2579
			bytes = readBytes(data, pos);                                                                                       // 2580
			block = (bytes[2] << 8) + bytes[3];                                                                                 // 2581
			if((bytes[1] === 0xC0 || bytes[1] === 0xC2) && bytes[0] === 0xFF && block > 7) {                                    // 2582
				bytes = readBytes(data, pos + 5);                                                                                  // 2583
				width = (bytes[2] << 8) + bytes[3];                                                                                // 2584
				height = (bytes[0] << 8) + bytes[1];                                                                               // 2585
                numcomponents = bytes[4];                                                                              // 2586
				return {width:width, height:height, numcomponents: numcomponents};                                                 // 2587
			}                                                                                                                   // 2588
                                                                                                                       // 2589
			pos+=2;                                                                                                             // 2590
		}                                                                                                                    // 2591
                                                                                                                       // 2592
		throw new Error('getJpegSizeFromBytes could not find the size of the image');                                        // 2593
	}                                                                                                                     // 2594
	, readBytes = function(data, offset) {                                                                                // 2595
		return data.subarray(offset, offset+ 5);                                                                             // 2596
	};                                                                                                                    // 2597
                                                                                                                       // 2598
	jsPDFAPI.processJPEG = function(data, index, alias, compression, dataAsBinaryString) {                                // 2599
		'use strict'                                                                                                         // 2600
		var colorSpace = this.color_spaces.DEVICE_RGB,                                                                       // 2601
			filter = this.decode.DCT_DECODE,                                                                                    // 2602
			bpc = 8,                                                                                                            // 2603
			dims;                                                                                                               // 2604
                                                                                                                       // 2605
		if(this.isString(data)) {                                                                                            // 2606
			dims = getJpegSize(data);                                                                                           // 2607
			return this.createImageInfo(data, dims[0], dims[1], dims[3] == 1 ? this.color_spaces.DEVICE_GRAY:colorSpace, bpc, filter, index, alias);
		}                                                                                                                    // 2609
                                                                                                                       // 2610
		if(this.isArrayBuffer(data))                                                                                         // 2611
			data = new Uint8Array(data);                                                                                        // 2612
                                                                                                                       // 2613
		if(this.isArrayBufferView(data)) {                                                                                   // 2614
                                                                                                                       // 2615
			dims = getJpegSizeFromBytes(data);                                                                                  // 2616
                                                                                                                       // 2617
			// if we already have a stored binary string rep use that                                                           // 2618
			data = dataAsBinaryString || this.arrayBufferToBinaryString(data);                                                  // 2619
                                                                                                                       // 2620
			return this.createImageInfo(data, dims.width, dims.height, dims.numcomponents == 1 ? this.color_spaces.DEVICE_GRAY:colorSpace, bpc, filter, index, alias);
		}                                                                                                                    // 2622
                                                                                                                       // 2623
		return null;                                                                                                         // 2624
	};                                                                                                                    // 2625
                                                                                                                       // 2626
	jsPDFAPI.processJPG = function(/*data, index, alias, compression, dataAsBinaryString*/) {                             // 2627
		return this.processJPEG.apply(this, arguments);                                                                      // 2628
	}                                                                                                                     // 2629
                                                                                                                       // 2630
})(jsPDF.API);                                                                                                         // 2631
(function (jsPDFAPI) {                                                                                                 // 2632
	'use strict';                                                                                                         // 2633
                                                                                                                       // 2634
	jsPDFAPI.autoPrint = function () {                                                                                    // 2635
		'use strict'                                                                                                         // 2636
		var refAutoPrintTag;                                                                                                 // 2637
                                                                                                                       // 2638
		this.internal.events.subscribe('postPutResources', function () {                                                     // 2639
			refAutoPrintTag = this.internal.newObject()                                                                         // 2640
				this.internal.write("<< /S/Named /Type/Action /N/Print >>", "endobj");                                             // 2641
		});                                                                                                                  // 2642
                                                                                                                       // 2643
		this.internal.events.subscribe("putCatalog", function () {                                                           // 2644
			this.internal.write("/OpenAction " + refAutoPrintTag + " 0" + " R");                                                // 2645
		});                                                                                                                  // 2646
		return this;                                                                                                         // 2647
	};                                                                                                                    // 2648
})(jsPDF.API);                                                                                                         // 2649
/** ====================================================================                                               // 2650
 * jsPDF Cell plugin                                                                                                   // 2651
 * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com                                                         // 2652
 *               2013 Eduardo Menezes de Morais, eduardo.morais@usp.br                                                 // 2653
 *               2013 Lee Driscoll, https://github.com/lsdriscoll                                                      // 2654
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria                                              // 2655
 *               2014 James Hall, james@parall.ax                                                                      // 2656
 *               2014 Diego Casorran, https://github.com/diegocr                                                       // 2657
 *                                                                                                                     // 2658
 * Permission is hereby granted, free of charge, to any person obtaining                                               // 2659
 * a copy of this software and associated documentation files (the                                                     // 2660
 * "Software"), to deal in the Software without restriction, including                                                 // 2661
 * without limitation the rights to use, copy, modify, merge, publish,                                                 // 2662
 * distribute, sublicense, and/or sell copies of the Software, and to                                                  // 2663
 * permit persons to whom the Software is furnished to do so, subject to                                               // 2664
 * the following conditions:                                                                                           // 2665
 *                                                                                                                     // 2666
 * The above copyright notice and this permission notice shall be                                                      // 2667
 * included in all copies or substantial portions of the Software.                                                     // 2668
 *                                                                                                                     // 2669
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,                                                     // 2670
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                  // 2671
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                                                               // 2672
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE                                              // 2673
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION                                              // 2674
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION                                               // 2675
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                                     // 2676
 * ====================================================================                                                // 2677
 */                                                                                                                    // 2678
                                                                                                                       // 2679
(function (jsPDFAPI) {                                                                                                 // 2680
    'use strict';                                                                                                      // 2681
    /*jslint browser:true */                                                                                           // 2682
    /*global document: false, jsPDF */                                                                                 // 2683
                                                                                                                       // 2684
    var fontName,                                                                                                      // 2685
        fontSize,                                                                                                      // 2686
        fontStyle,                                                                                                     // 2687
        padding = 3,                                                                                                   // 2688
        margin = 13,                                                                                                   // 2689
        headerFunction,                                                                                                // 2690
        lastCellPos = { x: undefined, y: undefined, w: undefined, h: undefined, ln: undefined },                       // 2691
        pages = 1,                                                                                                     // 2692
        setLastCellPosition = function (x, y, w, h, ln) {                                                              // 2693
            lastCellPos = { 'x': x, 'y': y, 'w': w, 'h': h, 'ln': ln };                                                // 2694
        },                                                                                                             // 2695
        getLastCellPosition = function () {                                                                            // 2696
            return lastCellPos;                                                                                        // 2697
        },                                                                                                             // 2698
        NO_MARGINS = {left:0, top:0, bottom: 0};                                                                       // 2699
                                                                                                                       // 2700
    jsPDFAPI.setHeaderFunction = function (func) {                                                                     // 2701
        headerFunction = func;                                                                                         // 2702
    };                                                                                                                 // 2703
                                                                                                                       // 2704
    jsPDFAPI.getTextDimensions = function (txt) {                                                                      // 2705
        fontName = this.internal.getFont().fontName;                                                                   // 2706
        fontSize = this.table_font_size || this.internal.getFontSize();                                                // 2707
        fontStyle = this.internal.getFont().fontStyle;                                                                 // 2708
        // 1 pixel = 0.264583 mm and 1 mm = 72/25.4 point                                                              // 2709
        var px2pt = 0.264583 * 72 / 25.4,                                                                              // 2710
            dimensions,                                                                                                // 2711
            text;                                                                                                      // 2712
                                                                                                                       // 2713
        text = document.createElement('font');                                                                         // 2714
        text.id = "jsPDFCell";                                                                                         // 2715
        text.style.fontStyle = fontStyle;                                                                              // 2716
        text.style.fontName = fontName;                                                                                // 2717
        text.style.fontSize = fontSize + 'pt';                                                                         // 2718
        text.textContent = txt;                                                                                        // 2719
                                                                                                                       // 2720
        document.body.appendChild(text);                                                                               // 2721
                                                                                                                       // 2722
        dimensions = { w: (text.offsetWidth + 1) * px2pt, h: (text.offsetHeight + 1) * px2pt};                         // 2723
                                                                                                                       // 2724
        document.body.removeChild(text);                                                                               // 2725
                                                                                                                       // 2726
        return dimensions;                                                                                             // 2727
    };                                                                                                                 // 2728
                                                                                                                       // 2729
    jsPDFAPI.cellAddPage = function () {                                                                               // 2730
        var margins = this.margins || NO_MARGINS;                                                                      // 2731
                                                                                                                       // 2732
        this.addPage();                                                                                                // 2733
                                                                                                                       // 2734
        setLastCellPosition(margins.left, margins.top, undefined, undefined);                                          // 2735
        //setLastCellPosition(undefined, undefined, undefined, undefined, undefined);                                  // 2736
        pages += 1;                                                                                                    // 2737
    };                                                                                                                 // 2738
                                                                                                                       // 2739
    jsPDFAPI.cellInitialize = function () {                                                                            // 2740
        lastCellPos = { x: undefined, y: undefined, w: undefined, h: undefined, ln: undefined };                       // 2741
        pages = 1;                                                                                                     // 2742
    };                                                                                                                 // 2743
                                                                                                                       // 2744
    jsPDFAPI.cell = function (x, y, w, h, txt, ln, align) {                                                            // 2745
        var curCell = getLastCellPosition();                                                                           // 2746
                                                                                                                       // 2747
        // If this is not the first cell, we must change its position                                                  // 2748
        if (curCell.ln !== undefined) {                                                                                // 2749
            if (curCell.ln === ln) {                                                                                   // 2750
                //Same line                                                                                            // 2751
                x = curCell.x + curCell.w;                                                                             // 2752
                y = curCell.y;                                                                                         // 2753
            } else {                                                                                                   // 2754
                //New line                                                                                             // 2755
                var margins = this.margins || NO_MARGINS;                                                              // 2756
                if ((curCell.y + curCell.h + h + margin) >= this.internal.pageSize.height - margins.bottom) {          // 2757
                    this.cellAddPage();                                                                                // 2758
                    if (this.printHeaders && this.tableHeaderRow) {                                                    // 2759
                        this.printHeaderRow(ln, true);                                                                 // 2760
                    }                                                                                                  // 2761
                }                                                                                                      // 2762
                //We ignore the passed y: the lines may have diferent heights                                          // 2763
                y = (getLastCellPosition().y + getLastCellPosition().h);                                               // 2764
                                                                                                                       // 2765
            }                                                                                                          // 2766
        }                                                                                                              // 2767
                                                                                                                       // 2768
        if (txt[0] !== undefined) {                                                                                    // 2769
            if (this.printingHeaderRow) {                                                                              // 2770
                this.rect(x, y, w, h, 'FD');                                                                           // 2771
            } else {                                                                                                   // 2772
                this.rect(x, y, w, h);                                                                                 // 2773
            }                                                                                                          // 2774
            if (align === 'right') {                                                                                   // 2775
                if (txt instanceof Array) {                                                                            // 2776
                    for(var i = 0; i<txt.length; i++) {                                                                // 2777
                        var currentLine = txt[i];                                                                      // 2778
                        var textSize = this.getStringUnitWidth(currentLine) * this.internal.getFontSize();             // 2779
                        this.text(currentLine, x + w - textSize - padding, y + this.internal.getLineHeight()*(i+1));   // 2780
                    }                                                                                                  // 2781
                }                                                                                                      // 2782
            } else {                                                                                                   // 2783
                this.text(txt, x + padding, y + this.internal.getLineHeight());                                        // 2784
            }                                                                                                          // 2785
        }                                                                                                              // 2786
        setLastCellPosition(x, y, w, h, ln);                                                                           // 2787
        return this;                                                                                                   // 2788
    };                                                                                                                 // 2789
                                                                                                                       // 2790
    /**                                                                                                                // 2791
     * Return the maximum value from an array                                                                          // 2792
     * @param array                                                                                                    // 2793
     * @param comparisonFn                                                                                             // 2794
     * @returns {*}                                                                                                    // 2795
     */                                                                                                                // 2796
    jsPDFAPI.arrayMax = function (array, comparisonFn) {                                                               // 2797
        var max = array[0],                                                                                            // 2798
            i,                                                                                                         // 2799
            ln,                                                                                                        // 2800
            item;                                                                                                      // 2801
                                                                                                                       // 2802
        for (i = 0, ln = array.length; i < ln; i += 1) {                                                               // 2803
            item = array[i];                                                                                           // 2804
                                                                                                                       // 2805
            if (comparisonFn) {                                                                                        // 2806
                if (comparisonFn(max, item) === -1) {                                                                  // 2807
                    max = item;                                                                                        // 2808
                }                                                                                                      // 2809
            } else {                                                                                                   // 2810
                if (item > max) {                                                                                      // 2811
                    max = item;                                                                                        // 2812
                }                                                                                                      // 2813
            }                                                                                                          // 2814
        }                                                                                                              // 2815
                                                                                                                       // 2816
        return max;                                                                                                    // 2817
    };                                                                                                                 // 2818
                                                                                                                       // 2819
    /**                                                                                                                // 2820
     * Create a table from a set of data.                                                                              // 2821
     * @param {Integer} [x] : left-position for top-left corner of table                                               // 2822
     * @param {Integer} [y] top-position for top-left corner of table                                                  // 2823
     * @param {Object[]} [data] As array of objects containing key-value pairs corresponding to a row of data.         // 2824
     * @param {String[]} [headers] Omit or null to auto-generate headers at a performance cost                         // 2825
                                                                                                                       // 2826
     * @param {Object} [config.printHeaders] True to print column headers at the top of every page                     // 2827
     * @param {Object} [config.autoSize] True to dynamically set the column widths to match the widest cell value      // 2828
     * @param {Object} [config.margins] margin values for left, top, bottom, and width                                 // 2829
     * @param {Object} [config.fontSize] Integer fontSize to use (optional)                                            // 2830
     */                                                                                                                // 2831
                                                                                                                       // 2832
    jsPDFAPI.table = function (x,y, data, headers, config) {                                                           // 2833
        if (!data) {                                                                                                   // 2834
            throw 'No data for PDF table';                                                                             // 2835
        }                                                                                                              // 2836
                                                                                                                       // 2837
        var headerNames = [],                                                                                          // 2838
            headerPrompts = [],                                                                                        // 2839
            header,                                                                                                    // 2840
            i,                                                                                                         // 2841
            ln,                                                                                                        // 2842
            cln,                                                                                                       // 2843
            columnMatrix = {},                                                                                         // 2844
            columnWidths = {},                                                                                         // 2845
            columnData,                                                                                                // 2846
            column,                                                                                                    // 2847
            columnMinWidths = [],                                                                                      // 2848
            j,                                                                                                         // 2849
            tableHeaderConfigs = [],                                                                                   // 2850
            model,                                                                                                     // 2851
            jln,                                                                                                       // 2852
            func,                                                                                                      // 2853
                                                                                                                       // 2854
        //set up defaults. If a value is provided in config, defaults will be overwritten:                             // 2855
           autoSize        = false,                                                                                    // 2856
           printHeaders    = true,                                                                                     // 2857
           fontSize        = 12,                                                                                       // 2858
           margins         = NO_MARGINS;                                                                               // 2859
                                                                                                                       // 2860
           margins.width = this.internal.pageSize.width;                                                               // 2861
                                                                                                                       // 2862
        if (config) {                                                                                                  // 2863
        //override config defaults if the user has specified non-default behavior:                                     // 2864
            if(config.autoSize === true) {                                                                             // 2865
                autoSize = true;                                                                                       // 2866
            }                                                                                                          // 2867
            if(config.printHeaders === false) {                                                                        // 2868
                printHeaders = false;                                                                                  // 2869
            }                                                                                                          // 2870
            if(config.fontSize){                                                                                       // 2871
                fontSize = config.fontSize;                                                                            // 2872
            }                                                                                                          // 2873
            if(config.margins){                                                                                        // 2874
                margins = config.margins;                                                                              // 2875
            }                                                                                                          // 2876
        }                                                                                                              // 2877
                                                                                                                       // 2878
        /**                                                                                                            // 2879
         * @property {Number} lnMod                                                                                    // 2880
         * Keep track of the current line number modifier used when creating cells                                     // 2881
         */                                                                                                            // 2882
        this.lnMod = 0;                                                                                                // 2883
        lastCellPos = { x: undefined, y: undefined, w: undefined, h: undefined, ln: undefined },                       // 2884
        pages = 1;                                                                                                     // 2885
                                                                                                                       // 2886
        this.printHeaders = printHeaders;                                                                              // 2887
        this.margins = margins;                                                                                        // 2888
        this.setFontSize(fontSize);                                                                                    // 2889
        this.table_font_size = fontSize;                                                                               // 2890
                                                                                                                       // 2891
        // Set header values                                                                                           // 2892
        if (headers === undefined || (headers === null)) {                                                             // 2893
            // No headers defined so we derive from data                                                               // 2894
            headerNames = Object.keys(data[0]);                                                                        // 2895
                                                                                                                       // 2896
        } else if (headers[0] && (typeof headers[0] !== 'string')) {                                                   // 2897
            var px2pt = 0.264583 * 72 / 25.4;                                                                          // 2898
                                                                                                                       // 2899
            // Split header configs into names and prompts                                                             // 2900
            for (i = 0, ln = headers.length; i < ln; i += 1) {                                                         // 2901
                header = headers[i];                                                                                   // 2902
                headerNames.push(header.name);                                                                         // 2903
                headerPrompts.push(header.prompt);                                                                     // 2904
                columnWidths[header.name] = header.width *px2pt;                                                       // 2905
            }                                                                                                          // 2906
                                                                                                                       // 2907
        } else {                                                                                                       // 2908
            headerNames = headers;                                                                                     // 2909
        }                                                                                                              // 2910
                                                                                                                       // 2911
        if (autoSize) {                                                                                                // 2912
            // Create a matrix of columns e.g., {column_title: [row1_Record, row2_Record]}                             // 2913
            func = function (rec) {                                                                                    // 2914
                return rec[header];                                                                                    // 2915
            };                                                                                                         // 2916
                                                                                                                       // 2917
            for (i = 0, ln = headerNames.length; i < ln; i += 1) {                                                     // 2918
                header = headerNames[i];                                                                               // 2919
                                                                                                                       // 2920
                columnMatrix[header] = data.map(                                                                       // 2921
                    func                                                                                               // 2922
                );                                                                                                     // 2923
                                                                                                                       // 2924
                // get header width                                                                                    // 2925
                columnMinWidths.push(this.getTextDimensions(headerPrompts[i] || header).w);                            // 2926
                column = columnMatrix[header];                                                                         // 2927
                                                                                                                       // 2928
                // get cell widths                                                                                     // 2929
                for (j = 0, cln = column.length; j < cln; j += 1) {                                                    // 2930
                    columnData = column[j];                                                                            // 2931
                    columnMinWidths.push(this.getTextDimensions(columnData).w);                                        // 2932
                }                                                                                                      // 2933
                                                                                                                       // 2934
                // get final column width                                                                              // 2935
                columnWidths[header] = jsPDFAPI.arrayMax(columnMinWidths);                                             // 2936
            }                                                                                                          // 2937
        }                                                                                                              // 2938
                                                                                                                       // 2939
        // -- Construct the table                                                                                      // 2940
                                                                                                                       // 2941
        if (printHeaders) {                                                                                            // 2942
            var lineHeight = this.calculateLineHeight(headerNames, columnWidths, headerPrompts.length?headerPrompts:headerNames);
                                                                                                                       // 2944
            // Construct the header row                                                                                // 2945
            for (i = 0, ln = headerNames.length; i < ln; i += 1) {                                                     // 2946
                header = headerNames[i];                                                                               // 2947
                tableHeaderConfigs.push([x, y, columnWidths[header], lineHeight, String(headerPrompts.length ? headerPrompts[i] : header)]);
            }                                                                                                          // 2949
                                                                                                                       // 2950
            // Store the table header config                                                                           // 2951
            this.setTableHeaderRow(tableHeaderConfigs);                                                                // 2952
                                                                                                                       // 2953
            // Print the header for the start of the table                                                             // 2954
            this.printHeaderRow(1, false);                                                                             // 2955
        }                                                                                                              // 2956
                                                                                                                       // 2957
        // Construct the data rows                                                                                     // 2958
        for (i = 0, ln = data.length; i < ln; i += 1) {                                                                // 2959
            var lineHeight;                                                                                            // 2960
            model = data[i];                                                                                           // 2961
            lineHeight = this.calculateLineHeight(headerNames, columnWidths, model);                                   // 2962
                                                                                                                       // 2963
            for (j = 0, jln = headerNames.length; j < jln; j += 1) {                                                   // 2964
                header = headerNames[j];                                                                               // 2965
                this.cell(x, y, columnWidths[header], lineHeight, model[header], i + 2, header.align);                 // 2966
            }                                                                                                          // 2967
        }                                                                                                              // 2968
        this.lastCellPos = lastCellPos;                                                                                // 2969
        this.table_x = x;                                                                                              // 2970
        this.table_y = y;                                                                                              // 2971
        return this;                                                                                                   // 2972
    };                                                                                                                 // 2973
    /**                                                                                                                // 2974
     * Calculate the height for containing the highest column                                                          // 2975
     * @param {String[]} headerNames is the header, used as keys to the data                                           // 2976
     * @param {Integer[]} columnWidths is size of each column                                                          // 2977
     * @param {Object[]} model is the line of data we want to calculate the height of                                  // 2978
     */                                                                                                                // 2979
    jsPDFAPI.calculateLineHeight = function (headerNames, columnWidths, model) {                                       // 2980
        var header, lineHeight = 0;                                                                                    // 2981
        for (var j = 0; j < headerNames.length; j++) {                                                                 // 2982
            header = headerNames[j];                                                                                   // 2983
            model[header] = this.splitTextToSize(String(model[header]), columnWidths[header] - padding);               // 2984
            var h = this.internal.getLineHeight() * model[header].length + padding;                                    // 2985
            if (h > lineHeight)                                                                                        // 2986
                lineHeight = h;                                                                                        // 2987
        }                                                                                                              // 2988
        return lineHeight;                                                                                             // 2989
    };                                                                                                                 // 2990
                                                                                                                       // 2991
    /**                                                                                                                // 2992
     * Store the config for outputting a table header                                                                  // 2993
     * @param {Object[]} config                                                                                        // 2994
     * An array of cell configs that would define a header row: Each config matches the config used by jsPDFAPI.cell   // 2995
     * except the ln parameter is excluded                                                                             // 2996
     */                                                                                                                // 2997
    jsPDFAPI.setTableHeaderRow = function (config) {                                                                   // 2998
        this.tableHeaderRow = config;                                                                                  // 2999
    };                                                                                                                 // 3000
                                                                                                                       // 3001
    /**                                                                                                                // 3002
     * Output the store header row                                                                                     // 3003
     * @param lineNumber The line number to output the header at                                                       // 3004
     */                                                                                                                // 3005
    jsPDFAPI.printHeaderRow = function (lineNumber, new_page) {                                                        // 3006
        if (!this.tableHeaderRow) {                                                                                    // 3007
            throw 'Property tableHeaderRow does not exist.';                                                           // 3008
        }                                                                                                              // 3009
                                                                                                                       // 3010
        var tableHeaderCell,                                                                                           // 3011
            tmpArray,                                                                                                  // 3012
            i,                                                                                                         // 3013
            ln;                                                                                                        // 3014
                                                                                                                       // 3015
        this.printingHeaderRow = true;                                                                                 // 3016
        if (headerFunction !== undefined) {                                                                            // 3017
            var position = headerFunction(this, pages);                                                                // 3018
            setLastCellPosition(position[0], position[1], position[2], position[3], -1);                               // 3019
        }                                                                                                              // 3020
        this.setFontStyle('bold');                                                                                     // 3021
        var tempHeaderConf = [];                                                                                       // 3022
        for (i = 0, ln = this.tableHeaderRow.length; i < ln; i += 1) {                                                 // 3023
            this.setFillColor(200,200,200);                                                                            // 3024
                                                                                                                       // 3025
            tableHeaderCell = this.tableHeaderRow[i];                                                                  // 3026
            if (new_page) {                                                                                            // 3027
                tableHeaderCell[1] = this.margins && this.margins.top || 0;                                            // 3028
                tempHeaderConf.push(tableHeaderCell);                                                                  // 3029
            }                                                                                                          // 3030
            tmpArray = [].concat(tableHeaderCell);                                                                     // 3031
            this.cell.apply(this, tmpArray.concat(lineNumber));                                                        // 3032
        }                                                                                                              // 3033
        if (tempHeaderConf.length > 0){                                                                                // 3034
            this.setTableHeaderRow(tempHeaderConf);                                                                    // 3035
        }                                                                                                              // 3036
        this.setFontStyle('normal');                                                                                   // 3037
        this.printingHeaderRow = false;                                                                                // 3038
    };                                                                                                                 // 3039
                                                                                                                       // 3040
})(jsPDF.API);                                                                                                         // 3041
/** @preserve                                                                                                          // 3042
 * jsPDF fromHTML plugin. BETA stage. API subject to change. Needs browser                                             // 3043
 * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com                                                   // 3044
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria                                              // 3045
 *               2014 Diego Casorran, https://github.com/diegocr                                                       // 3046
 *               2014 Daniel Husar, https://github.com/danielhusar                                                     // 3047
 *               2014 Wolfgang Gassler, https://github.com/woolfg                                                      // 3048
 *                                                                                                                     // 3049
 * Permission is hereby granted, free of charge, to any person obtaining                                               // 3050
 * a copy of this software and associated documentation files (the                                                     // 3051
 * "Software"), to deal in the Software without restriction, including                                                 // 3052
 * without limitation the rights to use, copy, modify, merge, publish,                                                 // 3053
 * distribute, sublicense, and/or sell copies of the Software, and to                                                  // 3054
 * permit persons to whom the Software is furnished to do so, subject to                                               // 3055
 * the following conditions:                                                                                           // 3056
 *                                                                                                                     // 3057
 * The above copyright notice and this permission notice shall be                                                      // 3058
 * included in all copies or substantial portions of the Software.                                                     // 3059
 *                                                                                                                     // 3060
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,                                                     // 3061
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                  // 3062
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                                                               // 3063
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE                                              // 3064
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION                                              // 3065
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION                                               // 3066
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                                     // 3067
 * ====================================================================                                                // 3068
 */                                                                                                                    // 3069
                                                                                                                       // 3070
(function (jsPDFAPI) {                                                                                                 // 3071
	var clone,                                                                                                            // 3072
	DrillForContent,                                                                                                      // 3073
	FontNameDB,                                                                                                           // 3074
	FontStyleMap,                                                                                                         // 3075
	FontWeightMap,                                                                                                        // 3076
	FloatMap,                                                                                                             // 3077
	ClearMap,                                                                                                             // 3078
	GetCSS,                                                                                                               // 3079
	PurgeWhiteSpace,                                                                                                      // 3080
	Renderer,                                                                                                             // 3081
	ResolveFont,                                                                                                          // 3082
	ResolveUnitedNumber,                                                                                                  // 3083
	UnitedNumberMap,                                                                                                      // 3084
	elementHandledElsewhere,                                                                                              // 3085
	images,                                                                                                               // 3086
	loadImgs,                                                                                                             // 3087
	checkForFooter,                                                                                                       // 3088
	process,                                                                                                              // 3089
	tableToJson;                                                                                                          // 3090
	clone = (function () {                                                                                                // 3091
		return function (obj) {                                                                                              // 3092
			Clone.prototype = obj;                                                                                              // 3093
			return new Clone()                                                                                                  // 3094
		};                                                                                                                   // 3095
		function Clone() {}                                                                                                  // 3096
	})();                                                                                                                 // 3097
	PurgeWhiteSpace = function (array) {                                                                                  // 3098
		var fragment,                                                                                                        // 3099
		i,                                                                                                                   // 3100
		l,                                                                                                                   // 3101
		lTrimmed,                                                                                                            // 3102
		r,                                                                                                                   // 3103
		rTrimmed,                                                                                                            // 3104
		trailingSpace;                                                                                                       // 3105
		i = 0;                                                                                                               // 3106
		l = array.length;                                                                                                    // 3107
		fragment = void 0;                                                                                                   // 3108
		lTrimmed = false;                                                                                                    // 3109
		rTrimmed = false;                                                                                                    // 3110
		while (!lTrimmed && i !== l) {                                                                                       // 3111
			fragment = array[i] = array[i].trimLeft();                                                                          // 3112
			if (fragment) {                                                                                                     // 3113
				lTrimmed = true;                                                                                                   // 3114
			}                                                                                                                   // 3115
			i++;                                                                                                                // 3116
		}                                                                                                                    // 3117
		i = l - 1;                                                                                                           // 3118
		while (l && !rTrimmed && i !== -1) {                                                                                 // 3119
			fragment = array[i] = array[i].trimRight();                                                                         // 3120
			if (fragment) {                                                                                                     // 3121
				rTrimmed = true;                                                                                                   // 3122
			}                                                                                                                   // 3123
			i--;                                                                                                                // 3124
		}                                                                                                                    // 3125
		r = /\s+$/g;                                                                                                         // 3126
		trailingSpace = true;                                                                                                // 3127
		i = 0;                                                                                                               // 3128
		while (i !== l) {                                                                                                    // 3129
			fragment = array[i].replace(/\s+/g, " ");                                                                           // 3130
			if (trailingSpace) {                                                                                                // 3131
				fragment = fragment.trimLeft();                                                                                    // 3132
			}                                                                                                                   // 3133
			if (fragment) {                                                                                                     // 3134
				trailingSpace = r.test(fragment);                                                                                  // 3135
			}                                                                                                                   // 3136
			array[i] = fragment;                                                                                                // 3137
			i++;                                                                                                                // 3138
		}                                                                                                                    // 3139
		return array;                                                                                                        // 3140
	};                                                                                                                    // 3141
	Renderer = function (pdf, x, y, settings) {                                                                           // 3142
		this.pdf = pdf;                                                                                                      // 3143
		this.x = x;                                                                                                          // 3144
		this.y = y;                                                                                                          // 3145
		this.settings = settings;                                                                                            // 3146
		//list of functions which are called after each element-rendering process                                            // 3147
		this.watchFunctions = [];                                                                                            // 3148
		this.init();                                                                                                         // 3149
		return this;                                                                                                         // 3150
	};                                                                                                                    // 3151
	ResolveFont = function (css_font_family_string) {                                                                     // 3152
		var name,                                                                                                            // 3153
		part,                                                                                                                // 3154
		parts;                                                                                                               // 3155
		name = void 0;                                                                                                       // 3156
		parts = css_font_family_string.split(",");                                                                           // 3157
		part = parts.shift();                                                                                                // 3158
		while (!name && part) {                                                                                              // 3159
			name = FontNameDB[part.trim().toLowerCase()];                                                                       // 3160
			part = parts.shift();                                                                                               // 3161
		}                                                                                                                    // 3162
		return name;                                                                                                         // 3163
	};                                                                                                                    // 3164
	ResolveUnitedNumber = function (css_line_height_string) {                                                             // 3165
                                                                                                                       // 3166
		//IE8 issues                                                                                                         // 3167
		css_line_height_string = css_line_height_string === "auto" ? "0px" : css_line_height_string;                         // 3168
		if (css_line_height_string.indexOf("em") > -1 && !isNaN(Number(css_line_height_string.replace("em", "")))) {         // 3169
			css_line_height_string = Number(css_line_height_string.replace("em", "")) * 18.719 + "px";                          // 3170
		}                                                                                                                    // 3171
		if (css_line_height_string.indexOf("pt") > -1 && !isNaN(Number(css_line_height_string.replace("pt", "")))) {         // 3172
			css_line_height_string = Number(css_line_height_string.replace("pt", "")) * 1.333 + "px";                           // 3173
		}                                                                                                                    // 3174
                                                                                                                       // 3175
		var normal,                                                                                                          // 3176
		undef,                                                                                                               // 3177
		value;                                                                                                               // 3178
		undef = void 0;                                                                                                      // 3179
		normal = 16.00;                                                                                                      // 3180
		value = UnitedNumberMap[css_line_height_string];                                                                     // 3181
		if (value) {                                                                                                         // 3182
			return value;                                                                                                       // 3183
		}                                                                                                                    // 3184
		value = {                                                                                                            // 3185
			"xx-small"  :  9,                                                                                                   // 3186
			"x-small"   : 11,                                                                                                   // 3187
			small       : 13,                                                                                                   // 3188
			medium      : 16,                                                                                                   // 3189
			large       : 19,                                                                                                   // 3190
			"x-large"   : 23,                                                                                                   // 3191
			"xx-large"  : 28,                                                                                                   // 3192
			auto        :  0                                                                                                    // 3193
		}[{ css_line_height_string : css_line_height_string }];                                                              // 3194
                                                                                                                       // 3195
		if (value !== undef) {                                                                                               // 3196
			return UnitedNumberMap[css_line_height_string] = value / normal;                                                    // 3197
		}                                                                                                                    // 3198
		if (value = parseFloat(css_line_height_string)) {                                                                    // 3199
			return UnitedNumberMap[css_line_height_string] = value / normal;                                                    // 3200
		}                                                                                                                    // 3201
		value = css_line_height_string.match(/([\d\.]+)(px)/);                                                               // 3202
		if (value.length === 3) {                                                                                            // 3203
			return UnitedNumberMap[css_line_height_string] = parseFloat(value[1]) / normal;                                     // 3204
		}                                                                                                                    // 3205
		return UnitedNumberMap[css_line_height_string] = 1;                                                                  // 3206
	};                                                                                                                    // 3207
	GetCSS = function (element) {                                                                                         // 3208
		var css,tmp,computedCSSElement;                                                                                      // 3209
		computedCSSElement = (function (el) {                                                                                // 3210
			var compCSS;                                                                                                        // 3211
			compCSS = (function (el) {                                                                                          // 3212
				if (document.defaultView && document.defaultView.getComputedStyle) {                                               // 3213
					return document.defaultView.getComputedStyle(el, null);                                                           // 3214
				} else if (el.currentStyle) {                                                                                      // 3215
					return el.currentStyle;                                                                                           // 3216
				} else {                                                                                                           // 3217
					return el.style;                                                                                                  // 3218
				}                                                                                                                  // 3219
			})(el);                                                                                                             // 3220
			return function (prop) {                                                                                            // 3221
				prop = prop.replace(/-\D/g, function (match) {                                                                     // 3222
					return match.charAt(1).toUpperCase();                                                                             // 3223
				});                                                                                                                // 3224
				return compCSS[prop];                                                                                              // 3225
			};                                                                                                                  // 3226
		})(element);                                                                                                         // 3227
		css = {};                                                                                                            // 3228
		tmp = void 0;                                                                                                        // 3229
		css["font-family"] = ResolveFont(computedCSSElement("font-family")) || "times";                                      // 3230
		css["font-style"] = FontStyleMap[computedCSSElement("font-style")] || "normal";                                      // 3231
		css["text-align"] = TextAlignMap[computedCSSElement("text-align")] || "left";                                        // 3232
		tmp = FontWeightMap[computedCSSElement("font-weight")] || "normal";                                                  // 3233
		if (tmp === "bold") {                                                                                                // 3234
			if (css["font-style"] === "normal") {                                                                               // 3235
				css["font-style"] = tmp;                                                                                           // 3236
			} else {                                                                                                            // 3237
				css["font-style"] = tmp + css["font-style"];                                                                       // 3238
			}                                                                                                                   // 3239
		}                                                                                                                    // 3240
		css["font-size"] = ResolveUnitedNumber(computedCSSElement("font-size")) || 1;                                        // 3241
		css["line-height"] = ResolveUnitedNumber(computedCSSElement("line-height")) || 1;                                    // 3242
		css["display"] = (computedCSSElement("display") === "inline" ? "inline" : "block");                                  // 3243
                                                                                                                       // 3244
		tmp = (css["display"] === "block");                                                                                  // 3245
		css["margin-top"]     = tmp && ResolveUnitedNumber(computedCSSElement("margin-top"))     || 0;                       // 3246
		css["margin-bottom"]  = tmp && ResolveUnitedNumber(computedCSSElement("margin-bottom"))  || 0;                       // 3247
		css["padding-top"]    = tmp && ResolveUnitedNumber(computedCSSElement("padding-top"))    || 0;                       // 3248
		css["padding-bottom"] = tmp && ResolveUnitedNumber(computedCSSElement("padding-bottom")) || 0;                       // 3249
		css["margin-left"]    = tmp && ResolveUnitedNumber(computedCSSElement("margin-left"))    || 0;                       // 3250
		css["margin-right"]   = tmp && ResolveUnitedNumber(computedCSSElement("margin-right"))   || 0;                       // 3251
		css["padding-left"]   = tmp && ResolveUnitedNumber(computedCSSElement("padding-left"))   || 0;                       // 3252
		css["padding-right"]  = tmp && ResolveUnitedNumber(computedCSSElement("padding-right"))  || 0;                       // 3253
                                                                                                                       // 3254
		//float and clearing of floats                                                                                       // 3255
		css["float"] = FloatMap[computedCSSElement("cssFloat")] || "none";                                                   // 3256
		css["clear"] = ClearMap[computedCSSElement("clear")] || "none";                                                      // 3257
		return css;                                                                                                          // 3258
	};                                                                                                                    // 3259
	elementHandledElsewhere = function (element, renderer, elementHandlers) {                                             // 3260
		var handlers,                                                                                                        // 3261
		i,                                                                                                                   // 3262
		isHandledElsewhere,                                                                                                  // 3263
		l,                                                                                                                   // 3264
		t;                                                                                                                   // 3265
		isHandledElsewhere = false;                                                                                          // 3266
		i = void 0;                                                                                                          // 3267
		l = void 0;                                                                                                          // 3268
		t = void 0;                                                                                                          // 3269
		handlers = elementHandlers["#" + element.id];                                                                        // 3270
		if (handlers) {                                                                                                      // 3271
			if (typeof handlers === "function") {                                                                               // 3272
				isHandledElsewhere = handlers(element, renderer);                                                                  // 3273
			} else {                                                                                                            // 3274
				i = 0;                                                                                                             // 3275
				l = handlers.length;                                                                                               // 3276
				while (!isHandledElsewhere && i !== l) {                                                                           // 3277
					isHandledElsewhere = handlers[i](element, renderer);                                                              // 3278
					i++;                                                                                                              // 3279
				}                                                                                                                  // 3280
			}                                                                                                                   // 3281
		}                                                                                                                    // 3282
		handlers = elementHandlers[element.nodeName];                                                                        // 3283
		if (!isHandledElsewhere && handlers) {                                                                               // 3284
			if (typeof handlers === "function") {                                                                               // 3285
				isHandledElsewhere = handlers(element, renderer);                                                                  // 3286
			} else {                                                                                                            // 3287
				i = 0;                                                                                                             // 3288
				l = handlers.length;                                                                                               // 3289
				while (!isHandledElsewhere && i !== l) {                                                                           // 3290
					isHandledElsewhere = handlers[i](element, renderer);                                                              // 3291
					i++;                                                                                                              // 3292
				}                                                                                                                  // 3293
			}                                                                                                                   // 3294
		}                                                                                                                    // 3295
		return isHandledElsewhere;                                                                                           // 3296
	};                                                                                                                    // 3297
	tableToJson = function (table, renderer) {                                                                            // 3298
		var data,                                                                                                            // 3299
		headers,                                                                                                             // 3300
		i,                                                                                                                   // 3301
		j,                                                                                                                   // 3302
		rowData,                                                                                                             // 3303
		tableRow,                                                                                                            // 3304
		table_obj,                                                                                                           // 3305
		table_with,                                                                                                          // 3306
		cell,                                                                                                                // 3307
		l;                                                                                                                   // 3308
		data = [];                                                                                                           // 3309
		headers = [];                                                                                                        // 3310
		i = 0;                                                                                                               // 3311
		l = table.rows[0].cells.length;                                                                                      // 3312
		table_with = table.clientWidth;                                                                                      // 3313
		while (i < l) {                                                                                                      // 3314
			cell = table.rows[0].cells[i];                                                                                      // 3315
			headers[i] = {                                                                                                      // 3316
				name : cell.textContent.toLowerCase().replace(/\s+/g, ''),                                                         // 3317
				prompt : cell.textContent.replace(/\r?\n/g, ''),                                                                   // 3318
				width : (cell.clientWidth / table_with) * renderer.pdf.internal.pageSize.width                                     // 3319
			};                                                                                                                  // 3320
			i++;                                                                                                                // 3321
		}                                                                                                                    // 3322
		i = 1;                                                                                                               // 3323
		while (i < table.rows.length) {                                                                                      // 3324
			tableRow = table.rows[i];                                                                                           // 3325
			rowData = {};                                                                                                       // 3326
			j = 0;                                                                                                              // 3327
			while (j < tableRow.cells.length) {                                                                                 // 3328
				rowData[headers[j].name] = tableRow.cells[j].textContent.replace(/\r?\n/g, '');                                    // 3329
				j++;                                                                                                               // 3330
			}                                                                                                                   // 3331
			data.push(rowData);                                                                                                 // 3332
			i++;                                                                                                                // 3333
		}                                                                                                                    // 3334
		return table_obj = {                                                                                                 // 3335
			rows : data,                                                                                                        // 3336
			headers : headers                                                                                                   // 3337
		};                                                                                                                   // 3338
	};                                                                                                                    // 3339
	var SkipNode = {                                                                                                      // 3340
		SCRIPT   : 1,                                                                                                        // 3341
		STYLE    : 1,                                                                                                        // 3342
		NOSCRIPT : 1,                                                                                                        // 3343
		OBJECT   : 1,                                                                                                        // 3344
		EMBED    : 1,                                                                                                        // 3345
		SELECT   : 1                                                                                                         // 3346
	};                                                                                                                    // 3347
	var listCount = 1;                                                                                                    // 3348
	DrillForContent = function (element, renderer, elementHandlers) {                                                     // 3349
		var cn,                                                                                                              // 3350
		cns,                                                                                                                 // 3351
		fragmentCSS,                                                                                                         // 3352
		i,                                                                                                                   // 3353
		isBlock,                                                                                                             // 3354
		l,                                                                                                                   // 3355
		px2pt,                                                                                                               // 3356
		table2json,                                                                                                          // 3357
		cb;                                                                                                                  // 3358
		cns = element.childNodes;                                                                                            // 3359
		cn = void 0;                                                                                                         // 3360
		fragmentCSS = GetCSS(element);                                                                                       // 3361
		isBlock = fragmentCSS.display === "block";                                                                           // 3362
		if (isBlock) {                                                                                                       // 3363
			renderer.setBlockBoundary();                                                                                        // 3364
			renderer.setBlockStyle(fragmentCSS);                                                                                // 3365
		}                                                                                                                    // 3366
		px2pt = 0.264583 * 72 / 25.4;                                                                                        // 3367
		i = 0;                                                                                                               // 3368
		l = cns.length;                                                                                                      // 3369
		while (i < l) {                                                                                                      // 3370
			cn = cns[i];                                                                                                        // 3371
			if (typeof cn === "object") {                                                                                       // 3372
                                                                                                                       // 3373
				//execute all watcher functions to e.g. reset floating                                                             // 3374
				renderer.executeWatchFunctions(cn);                                                                                // 3375
                                                                                                                       // 3376
				/*** HEADER rendering **/                                                                                          // 3377
				if (cn.nodeType === 1 && cn.nodeName === 'HEADER') {                                                               // 3378
					var header = cn;                                                                                                  // 3379
					//store old top margin                                                                                            // 3380
					var oldMarginTop = renderer.pdf.margins_doc.top;                                                                  // 3381
					//subscribe for new page event and render header first on every page                                              // 3382
					renderer.pdf.internal.events.subscribe('addPage', function (pageInfo) {                                           // 3383
						//set current y position to old margin                                                                           // 3384
						renderer.y = oldMarginTop;                                                                                       // 3385
						//render all child nodes of the header element                                                                   // 3386
						DrillForContent(header, renderer, elementHandlers);                                                              // 3387
						//set margin to old margin + rendered header + 10 space to prevent overlapping                                   // 3388
						//important for other plugins (e.g. table) to start rendering at correct position after header                   // 3389
						renderer.pdf.margins_doc.top = renderer.y + 10;                                                                  // 3390
						renderer.y += 10;                                                                                                // 3391
					}, false);                                                                                                        // 3392
				}                                                                                                                  // 3393
                                                                                                                       // 3394
				if (cn.nodeType === 8 && cn.nodeName === "#comment") {                                                             // 3395
					if (~cn.textContent.indexOf("ADD_PAGE")) {                                                                        // 3396
						renderer.pdf.addPage();                                                                                          // 3397
						renderer.y = renderer.pdf.margins_doc.top;                                                                       // 3398
					}                                                                                                                 // 3399
                                                                                                                       // 3400
				} else if (cn.nodeType === 1 && !SkipNode[cn.nodeName]) {                                                          // 3401
					/*** IMAGE RENDERING ***/                                                                                         // 3402
					var cached_image;                                                                                                 // 3403
					if (cn.nodeName === "IMG") {                                                                                      // 3404
						var url = cn.getAttribute("src");                                                                                // 3405
						cached_image = images[renderer.pdf.sHashCode(url) || url];                                                       // 3406
					}                                                                                                                 // 3407
					if (cached_image) {                                                                                               // 3408
						if ((renderer.pdf.internal.pageSize.height - renderer.pdf.margins_doc.bottom < renderer.y + cn.height) && (renderer.y > renderer.pdf.margins_doc.top)) {
							renderer.pdf.addPage();                                                                                         // 3410
							renderer.y = renderer.pdf.margins_doc.top;                                                                      // 3411
							//check if we have to set back some values due to e.g. header rendering for new page                            // 3412
							renderer.executeWatchFunctions(cn);                                                                             // 3413
						}                                                                                                                // 3414
                                                                                                                       // 3415
						var imagesCSS = GetCSS(cn);                                                                                      // 3416
						var imageX = renderer.x;                                                                                         // 3417
						var fontToUnitRatio = 12 / renderer.pdf.internal.scaleFactor;                                                    // 3418
                                                                                                                       // 3419
						//define additional paddings, margins which have to be taken into account for margin calculations                // 3420
						var additionalSpaceLeft = (imagesCSS["margin-left"] + imagesCSS["padding-left"])*fontToUnitRatio;                // 3421
						var additionalSpaceRight = (imagesCSS["margin-right"] + imagesCSS["padding-right"])*fontToUnitRatio;             // 3422
						var additionalSpaceTop = (imagesCSS["margin-top"] + imagesCSS["padding-top"])*fontToUnitRatio;                   // 3423
						var additionalSpaceBottom = (imagesCSS["margin-bottom"] + imagesCSS["padding-bottom"])*fontToUnitRatio;          // 3424
                                                                                                                       // 3425
						//if float is set to right, move the image to the right border                                                   // 3426
						//add space if margin is set                                                                                     // 3427
						if (imagesCSS['float'] !== undefined && imagesCSS['float'] === 'right') {                                        // 3428
							imageX += renderer.settings.width - cn.width - additionalSpaceRight;                                            // 3429
						} else {                                                                                                         // 3430
							imageX +=  additionalSpaceLeft;                                                                                 // 3431
						}                                                                                                                // 3432
                                                                                                                       // 3433
						renderer.pdf.addImage(cached_image, imageX, renderer.y + additionalSpaceTop, cn.width, cn.height);               // 3434
						cached_image = undefined;                                                                                        // 3435
						//if the float prop is specified we have to float the text around the image                                      // 3436
						if (imagesCSS['float'] === 'right' || imagesCSS['float'] === 'left') {                                           // 3437
							//add functiont to set back coordinates after image rendering                                                   // 3438
							renderer.watchFunctions.push((function(diffX , thresholdY, diffWidth, el) {                                     // 3439
								//undo drawing box adaptions which were set by floating                                                        // 3440
								if (renderer.y >= thresholdY) {                                                                                // 3441
									renderer.x += diffX;                                                                                          // 3442
									renderer.settings.width += diffWidth;                                                                         // 3443
									return true;                                                                                                  // 3444
								} else if(el && el.nodeType === 1 && !SkipNode[el.nodeName] && renderer.x+el.width > (renderer.pdf.margins_doc.left + renderer.pdf.margins_doc.width)) {
									renderer.x += diffX;                                                                                          // 3446
									renderer.y = thresholdY;                                                                                      // 3447
									renderer.settings.width += diffWidth;                                                                         // 3448
									return true;                                                                                                  // 3449
								} else {                                                                                                       // 3450
									return false;                                                                                                 // 3451
								}                                                                                                              // 3452
							}).bind(this, (imagesCSS['float'] === 'left') ? -cn.width-additionalSpaceLeft-additionalSpaceRight : 0, renderer.y+cn.height+additionalSpaceTop+additionalSpaceBottom, cn.width));
							//reset floating by clear:both divs                                                                             // 3454
							//just set cursorY after the floating element                                                                   // 3455
							renderer.watchFunctions.push((function(yPositionAfterFloating, pages, el) {                                     // 3456
								if (renderer.y < yPositionAfterFloating && pages === renderer.pdf.internal.getNumberOfPages()) {               // 3457
									if (el.nodeType === 1 && GetCSS(el).clear === 'both') {                                                       // 3458
										renderer.y = yPositionAfterFloating;                                                                         // 3459
										return true;                                                                                                 // 3460
									} else {                                                                                                      // 3461
										return false;                                                                                                // 3462
									}                                                                                                             // 3463
								} else {                                                                                                       // 3464
									return true;                                                                                                  // 3465
								}                                                                                                              // 3466
							}).bind(this, renderer.y+cn.height, renderer.pdf.internal.getNumberOfPages()));                                 // 3467
                                                                                                                       // 3468
							//if floating is set we decrease the available width by the image width                                         // 3469
							renderer.settings.width -= cn.width+additionalSpaceLeft+additionalSpaceRight;                                   // 3470
							//if left just add the image width to the X coordinate                                                          // 3471
							if (imagesCSS['float'] === 'left') {                                                                            // 3472
								renderer.x += cn.width+additionalSpaceLeft+additionalSpaceRight;                                               // 3473
							}                                                                                                               // 3474
						} else {                                                                                                         // 3475
						//if no floating is set, move the rendering cursor after the image height                                        // 3476
							renderer.y += cn.height + additionalSpaceBottom;                                                                // 3477
						}                                                                                                                // 3478
                                                                                                                       // 3479
					/*** TABLE RENDERING ***/                                                                                         // 3480
					} else if (cn.nodeName === "TABLE") {                                                                             // 3481
						table2json = tableToJson(cn, renderer);                                                                          // 3482
						renderer.y += 10;                                                                                                // 3483
						renderer.pdf.table(renderer.x, renderer.y, table2json.rows, table2json.headers, {                                // 3484
							autoSize : false,                                                                                               // 3485
							printHeaders : true,                                                                                            // 3486
							margins : renderer.pdf.margins_doc                                                                              // 3487
						});                                                                                                              // 3488
						renderer.y = renderer.pdf.lastCellPos.y + renderer.pdf.lastCellPos.h + 20;                                       // 3489
					} else if (cn.nodeName === "OL" || cn.nodeName === "UL") {                                                        // 3490
						listCount = 1;                                                                                                   // 3491
						if (!elementHandledElsewhere(cn, renderer, elementHandlers)) {                                                   // 3492
							DrillForContent(cn, renderer, elementHandlers);                                                                 // 3493
						}                                                                                                                // 3494
						renderer.y += 10;                                                                                                // 3495
					} else if (cn.nodeName === "LI") {                                                                                // 3496
						var temp = renderer.x;                                                                                           // 3497
						renderer.x += cn.parentNode.nodeName === "UL" ? 22 : 10;                                                         // 3498
						renderer.y += 3;                                                                                                 // 3499
						if (!elementHandledElsewhere(cn, renderer, elementHandlers)) {                                                   // 3500
							DrillForContent(cn, renderer, elementHandlers);                                                                 // 3501
						}                                                                                                                // 3502
						renderer.x = temp;                                                                                               // 3503
					} else if (cn.nodeName === "BR") {                                                                                // 3504
						renderer.y += fragmentCSS["font-size"] * renderer.pdf.internal.scaleFactor;                                      // 3505
					} else {                                                                                                          // 3506
						if (!elementHandledElsewhere(cn, renderer, elementHandlers)) {                                                   // 3507
							DrillForContent(cn, renderer, elementHandlers);                                                                 // 3508
						}                                                                                                                // 3509
					}                                                                                                                 // 3510
				} else if (cn.nodeType === 3) {                                                                                    // 3511
					var value = cn.nodeValue;                                                                                         // 3512
					if (cn.nodeValue && cn.parentNode.nodeName === "LI") {                                                            // 3513
						if (cn.parentNode.parentNode.nodeName === "OL") {                                                                // 3514
							value = listCount++ + '. ' + value;                                                                             // 3515
						} else {                                                                                                         // 3516
							var fontPx = fragmentCSS["font-size"] * 16;                                                                     // 3517
							var radius = 2;                                                                                                 // 3518
							if (fontPx > 20) {                                                                                              // 3519
								radius = 3;                                                                                                    // 3520
							}                                                                                                               // 3521
							cb = function (x, y) {                                                                                          // 3522
								this.pdf.circle(x, y, radius, 'FD');                                                                           // 3523
							};                                                                                                              // 3524
						}                                                                                                                // 3525
					}                                                                                                                 // 3526
					renderer.addText(value, fragmentCSS);                                                                             // 3527
				} else if (typeof cn === "string") {                                                                               // 3528
					renderer.addText(cn, fragmentCSS);                                                                                // 3529
				}                                                                                                                  // 3530
			}                                                                                                                   // 3531
			i++;                                                                                                                // 3532
		}                                                                                                                    // 3533
                                                                                                                       // 3534
		if (isBlock) {                                                                                                       // 3535
			return renderer.setBlockBoundary(cb);                                                                               // 3536
		}                                                                                                                    // 3537
	};                                                                                                                    // 3538
	images = {};                                                                                                          // 3539
	loadImgs = function (element, renderer, elementHandlers, cb) {                                                        // 3540
		var imgs = element.getElementsByTagName('img'),                                                                      // 3541
		l = imgs.length, found_images,                                                                                       // 3542
		x = 0;                                                                                                               // 3543
		function done() {                                                                                                    // 3544
			renderer.pdf.internal.events.publish('imagesLoaded');                                                               // 3545
			cb(found_images);                                                                                                   // 3546
		}                                                                                                                    // 3547
		function loadImage(url, width, height) {                                                                             // 3548
			if (!url)                                                                                                           // 3549
				return;                                                                                                            // 3550
			var img = new Image();                                                                                              // 3551
			found_images = ++x;                                                                                                 // 3552
			img.crossOrigin = '';                                                                                               // 3553
			img.onerror = img.onload = function () {                                                                            // 3554
				if(img.complete) {                                                                                                 // 3555
					//to support data urls in images, set width and height                                                            // 3556
					//as those values are not recognized automatically                                                                // 3557
					if (img.src.indexOf('data:image/') === 0) {                                                                       // 3558
						img.width = width || img.width || 0;                                                                             // 3559
						img.height = height || img.height || 0;                                                                          // 3560
					}                                                                                                                 // 3561
					//if valid image add to known images array                                                                        // 3562
					if (img.width + img.height) {                                                                                     // 3563
						var hash = renderer.pdf.sHashCode(url) || url;                                                                   // 3564
						images[hash] = images[hash] || img;                                                                              // 3565
					}                                                                                                                 // 3566
				}                                                                                                                  // 3567
				if(!--x) {                                                                                                         // 3568
					done();                                                                                                           // 3569
				}                                                                                                                  // 3570
			};                                                                                                                  // 3571
			img.src = url;                                                                                                      // 3572
		}                                                                                                                    // 3573
		while (l--)                                                                                                          // 3574
			loadImage(imgs[l].getAttribute("src"),imgs[l].width,imgs[l].height);                                                // 3575
		return x || done();                                                                                                  // 3576
	};                                                                                                                    // 3577
	checkForFooter = function (elem, renderer, elementHandlers) {                                                         // 3578
		//check if we can found a <footer> element                                                                           // 3579
		var footer = elem.getElementsByTagName("footer");                                                                    // 3580
		if (footer.length > 0) {                                                                                             // 3581
                                                                                                                       // 3582
			footer = footer[0];                                                                                                 // 3583
                                                                                                                       // 3584
			//bad hack to get height of footer                                                                                  // 3585
			//creat dummy out and check new y after fake rendering                                                              // 3586
			var oldOut = renderer.pdf.internal.write;                                                                           // 3587
			var oldY = renderer.y;                                                                                              // 3588
			renderer.pdf.internal.write = function () {};                                                                       // 3589
			DrillForContent(footer, renderer, elementHandlers);                                                                 // 3590
			var footerHeight = Math.ceil(renderer.y - oldY) + 5;                                                                // 3591
			renderer.y = oldY;                                                                                                  // 3592
			renderer.pdf.internal.write = oldOut;                                                                               // 3593
                                                                                                                       // 3594
			//add 20% to prevent overlapping                                                                                    // 3595
			renderer.pdf.margins_doc.bottom += footerHeight;                                                                    // 3596
                                                                                                                       // 3597
			//Create function render header on every page                                                                       // 3598
			var renderFooter = function (pageInfo) {                                                                            // 3599
				var pageNumber = pageInfo !== undefined ? pageInfo.pageNumber : 1;                                                 // 3600
				//set current y position to old margin                                                                             // 3601
				var oldPosition = renderer.y;                                                                                      // 3602
				//render all child nodes of the header element                                                                     // 3603
				renderer.y = renderer.pdf.internal.pageSize.height - renderer.pdf.margins_doc.bottom;                              // 3604
				renderer.pdf.margins_doc.bottom -= footerHeight;                                                                   // 3605
                                                                                                                       // 3606
				//check if we have to add page numbers                                                                             // 3607
				var spans = footer.getElementsByTagName('span');                                                                   // 3608
				for (var i = 0; i < spans.length; ++i) {                                                                           // 3609
					//if we find some span element with class pageCounter, set the page                                               // 3610
					if ((" " + spans[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" pageCounter ") > -1) {                     // 3611
						spans[i].innerHTML = pageNumber;                                                                                 // 3612
					}                                                                                                                 // 3613
					//if we find some span element with class totalPages, set a variable which is replaced after rendering of all pages
					if ((" " + spans[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") > -1) {                      // 3615
						spans[i].innerHTML = '###jsPDFVarTotalPages###';                                                                 // 3616
					}                                                                                                                 // 3617
				}                                                                                                                  // 3618
                                                                                                                       // 3619
				//render footer content                                                                                            // 3620
				DrillForContent(footer, renderer, elementHandlers);                                                                // 3621
				//set bottom margin to previous height including the footer height                                                 // 3622
				renderer.pdf.margins_doc.bottom += footerHeight;                                                                   // 3623
				//important for other plugins (e.g. table) to start rendering at correct position after header                     // 3624
				renderer.y = oldPosition;                                                                                          // 3625
			};                                                                                                                  // 3626
                                                                                                                       // 3627
			//check if footer contains totalPages which shoudl be replace at the disoposal of the document                      // 3628
			var spans = footer.getElementsByTagName('span');                                                                    // 3629
			for (var i = 0; i < spans.length; ++i) {                                                                            // 3630
				if ((" " + spans[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") > -1) {                       // 3631
					renderer.pdf.internal.events.subscribe('htmlRenderingFinished', renderer.pdf.putTotalPages.bind(renderer.pdf, '###jsPDFVarTotalPages###'), true);
				}                                                                                                                  // 3633
			}                                                                                                                   // 3634
                                                                                                                       // 3635
			//register event to render footer on every new page                                                                 // 3636
			renderer.pdf.internal.events.subscribe('addPage', renderFooter, false);                                             // 3637
			//render footer on first page                                                                                       // 3638
			renderFooter();                                                                                                     // 3639
                                                                                                                       // 3640
			//prevent footer rendering                                                                                          // 3641
			SkipNode['FOOTER'] = 1;                                                                                             // 3642
		}                                                                                                                    // 3643
	};                                                                                                                    // 3644
	process = function (pdf, element, x, y, settings, callback) {                                                         // 3645
		if (!element)                                                                                                        // 3646
			return false;                                                                                                       // 3647
		if (typeof element !== "string" && !element.parentNode)                                                              // 3648
			element = '' + element.innerHTML;                                                                                   // 3649
		if (typeof element === "string") {                                                                                   // 3650
			element = (function (element) {                                                                                     // 3651
				var $frame,                                                                                                        // 3652
				$hiddendiv,                                                                                                        // 3653
				framename,                                                                                                         // 3654
				visuallyhidden;                                                                                                    // 3655
				framename = "jsPDFhtmlText" + Date.now().toString() + (Math.random() * 1000).toFixed(0);                           // 3656
				visuallyhidden = "position: absolute !important;" + "clip: rect(1px 1px 1px 1px); /* IE6, IE7 */" + "clip: rect(1px, 1px, 1px, 1px);" + "padding:0 !important;" + "border:0 !important;" + "height: 1px !important;" + "width: 1px !important; " + "top:auto;" + "left:-100px;" + "overflow: hidden;";
				$hiddendiv = document.createElement('div');                                                                        // 3658
				$hiddendiv.style.cssText = visuallyhidden;                                                                         // 3659
				$hiddendiv.innerHTML = "<iframe style=\"height:1px;width:1px\" name=\"" + framename + "\" />";                     // 3660
				document.body.appendChild($hiddendiv);                                                                             // 3661
				$frame = window.frames[framename];                                                                                 // 3662
				$frame.document.body.innerHTML = element;                                                                          // 3663
				return $frame.document.body;                                                                                       // 3664
			})(element.replace(/<\/?script[^>]*?>/gi, ''));                                                                     // 3665
		}                                                                                                                    // 3666
		var r = new Renderer(pdf, x, y, settings), out;                                                                      // 3667
                                                                                                                       // 3668
		// 1. load images                                                                                                    // 3669
		// 2. prepare optional footer elements                                                                               // 3670
		// 3. render content                                                                                                 // 3671
		loadImgs.call(this, element, r, settings.elementHandlers, function (found_images) {                                  // 3672
			checkForFooter( element, r, settings.elementHandlers);                                                              // 3673
			DrillForContent(element, r, settings.elementHandlers);                                                              // 3674
			//send event dispose for final taks (e.g. footer totalpage replacement)                                             // 3675
			r.pdf.internal.events.publish('htmlRenderingFinished');                                                             // 3676
			out = r.dispose();                                                                                                  // 3677
			if (typeof callback === 'function') callback(out);                                                                  // 3678
			else if (found_images) console.error('jsPDF Warning: rendering issues? provide a callback to fromHTML!');           // 3679
		});                                                                                                                  // 3680
		return out || {x: r.x, y:r.y};                                                                                       // 3681
	};                                                                                                                    // 3682
	Renderer.prototype.init = function () {                                                                               // 3683
		this.paragraph = {                                                                                                   // 3684
			text : [],                                                                                                          // 3685
			style : []                                                                                                          // 3686
		};                                                                                                                   // 3687
		return this.pdf.internal.write("q");                                                                                 // 3688
	};                                                                                                                    // 3689
	Renderer.prototype.dispose = function () {                                                                            // 3690
		this.pdf.internal.write("Q");                                                                                        // 3691
		return {                                                                                                             // 3692
			x : this.x,                                                                                                         // 3693
			y : this.y,                                                                                                         // 3694
			ready:true                                                                                                          // 3695
		};                                                                                                                   // 3696
	};                                                                                                                    // 3697
                                                                                                                       // 3698
	//Checks if we have to execute some watcher functions                                                                 // 3699
	//e.g. to end text floating around an image                                                                           // 3700
	Renderer.prototype.executeWatchFunctions = function(el) {                                                             // 3701
		var ret = false;                                                                                                     // 3702
		var narray = [];                                                                                                     // 3703
		if (this.watchFunctions.length > 0) {                                                                                // 3704
			for(var i=0; i< this.watchFunctions.length; ++i) {                                                                  // 3705
				if (this.watchFunctions[i](el) === true) {                                                                         // 3706
					ret = true;                                                                                                       // 3707
				} else {                                                                                                           // 3708
					narray.push(this.watchFunctions[i]);                                                                              // 3709
				}                                                                                                                  // 3710
			}                                                                                                                   // 3711
			this.watchFunctions = narray;                                                                                       // 3712
		}                                                                                                                    // 3713
		return ret;                                                                                                          // 3714
	};                                                                                                                    // 3715
                                                                                                                       // 3716
	Renderer.prototype.splitFragmentsIntoLines = function (fragments, styles) {                                           // 3717
		var currentLineLength,                                                                                               // 3718
		defaultFontSize,                                                                                                     // 3719
		ff,                                                                                                                  // 3720
		fontMetrics,                                                                                                         // 3721
		fontMetricsCache,                                                                                                    // 3722
		fragment,                                                                                                            // 3723
		fragmentChopped,                                                                                                     // 3724
		fragmentLength,                                                                                                      // 3725
		fragmentSpecificMetrics,                                                                                             // 3726
		fs,                                                                                                                  // 3727
		k,                                                                                                                   // 3728
		line,                                                                                                                // 3729
		lines,                                                                                                               // 3730
		maxLineLength,                                                                                                       // 3731
		style;                                                                                                               // 3732
		defaultFontSize = 12;                                                                                                // 3733
		k = this.pdf.internal.scaleFactor;                                                                                   // 3734
		fontMetricsCache = {};                                                                                               // 3735
		ff = void 0;                                                                                                         // 3736
		fs = void 0;                                                                                                         // 3737
		fontMetrics = void 0;                                                                                                // 3738
		fragment = void 0;                                                                                                   // 3739
		style = void 0;                                                                                                      // 3740
		fragmentSpecificMetrics = void 0;                                                                                    // 3741
		fragmentLength = void 0;                                                                                             // 3742
		fragmentChopped = void 0;                                                                                            // 3743
		line = [];                                                                                                           // 3744
		lines = [line];                                                                                                      // 3745
		currentLineLength = 0;                                                                                               // 3746
		maxLineLength = this.settings.width;                                                                                 // 3747
		while (fragments.length) {                                                                                           // 3748
			fragment = fragments.shift();                                                                                       // 3749
			style = styles.shift();                                                                                             // 3750
			if (fragment) {                                                                                                     // 3751
				ff = style["font-family"];                                                                                         // 3752
				fs = style["font-style"];                                                                                          // 3753
				fontMetrics = fontMetricsCache[ff + fs];                                                                           // 3754
				if (!fontMetrics) {                                                                                                // 3755
					fontMetrics = this.pdf.internal.getFont(ff, fs).metadata.Unicode;                                                 // 3756
					fontMetricsCache[ff + fs] = fontMetrics;                                                                          // 3757
				}                                                                                                                  // 3758
				fragmentSpecificMetrics = {                                                                                        // 3759
					widths : fontMetrics.widths,                                                                                      // 3760
					kerning : fontMetrics.kerning,                                                                                    // 3761
					fontSize : style["font-size"] * defaultFontSize,                                                                  // 3762
					textIndent : currentLineLength                                                                                    // 3763
				};                                                                                                                 // 3764
				fragmentLength = this.pdf.getStringUnitWidth(fragment, fragmentSpecificMetrics) * fragmentSpecificMetrics.fontSize / k;
				if (currentLineLength + fragmentLength > maxLineLength) {                                                          // 3766
					fragmentChopped = this.pdf.splitTextToSize(fragment, maxLineLength, fragmentSpecificMetrics);                     // 3767
					line.push([fragmentChopped.shift(), style]);                                                                      // 3768
					while (fragmentChopped.length) {                                                                                  // 3769
						line = [[fragmentChopped.shift(), style]];                                                                       // 3770
						lines.push(line);                                                                                                // 3771
					}                                                                                                                 // 3772
					currentLineLength = this.pdf.getStringUnitWidth(line[0][0], fragmentSpecificMetrics) * fragmentSpecificMetrics.fontSize / k;
				} else {                                                                                                           // 3774
					line.push([fragment, style]);                                                                                     // 3775
					currentLineLength += fragmentLength;                                                                              // 3776
				}                                                                                                                  // 3777
			}                                                                                                                   // 3778
		}                                                                                                                    // 3779
                                                                                                                       // 3780
		//if text alignment was set, set margin/indent of each line                                                          // 3781
		if (style['text-align'] !== undefined && (style['text-align'] === 'center' || style['text-align'] === 'right' || style['text-align'] === 'justify')) {
			for (var i = 0; i < lines.length; ++i) {                                                                            // 3783
				var length = this.pdf.getStringUnitWidth(lines[i][0][0], fragmentSpecificMetrics) * fragmentSpecificMetrics.fontSize / k;
				//if there is more than on line we have to clone the style object as all lines hold a reference on this object     // 3785
				if (i > 0) {                                                                                                       // 3786
					lines[i][0][1] = clone(lines[i][0][1]);                                                                           // 3787
				}                                                                                                                  // 3788
				var space = (maxLineLength - length);                                                                              // 3789
                                                                                                                       // 3790
				if (style['text-align'] === 'right') {                                                                             // 3791
					lines[i][0][1]['margin-left'] = space;                                                                            // 3792
					//if alignment is not right, it has to be center so split the space to the left and the right                     // 3793
				} else if (style['text-align'] === 'center') {                                                                     // 3794
					lines[i][0][1]['margin-left'] = space / 2;                                                                        // 3795
					//if justify was set, calculate the word spacing and define in by using the css property                          // 3796
				} else if (style['text-align'] === 'justify') {                                                                    // 3797
					var countSpaces = lines[i][0][0].split(' ').length - 1;                                                           // 3798
					lines[i][0][1]['word-spacing'] = space / countSpaces;                                                             // 3799
					//ignore the last line in justify mode                                                                            // 3800
					if (i === (lines.length - 1)) {                                                                                   // 3801
						lines[i][0][1]['word-spacing'] = 0;                                                                              // 3802
					}                                                                                                                 // 3803
				}                                                                                                                  // 3804
			}                                                                                                                   // 3805
		}                                                                                                                    // 3806
                                                                                                                       // 3807
		return lines;                                                                                                        // 3808
	};                                                                                                                    // 3809
	Renderer.prototype.RenderTextFragment = function (text, style) {                                                      // 3810
		var defaultFontSize,                                                                                                 // 3811
		font,                                                                                                                // 3812
		maxLineHeight;                                                                                                       // 3813
                                                                                                                       // 3814
		maxLineHeight = 0;                                                                                                   // 3815
		defaultFontSize = 12;                                                                                                // 3816
                                                                                                                       // 3817
		if (this.pdf.internal.pageSize.height - this.pdf.margins_doc.bottom < this.y + this.pdf.internal.getFontSize()) {    // 3818
			this.pdf.internal.write("ET", "Q");                                                                                 // 3819
			this.pdf.addPage();                                                                                                 // 3820
			this.y = this.pdf.margins_doc.top;                                                                                  // 3821
			this.pdf.internal.write("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");
			//move cursor by one line on new page                                                                               // 3823
			maxLineHeight = Math.max(maxLineHeight, style["line-height"], style["font-size"]);                                  // 3824
			this.pdf.internal.write(0, (-1 * defaultFontSize * maxLineHeight).toFixed(2), "Td");                                // 3825
		}                                                                                                                    // 3826
                                                                                                                       // 3827
		font = this.pdf.internal.getFont(style["font-family"], style["font-style"]);                                         // 3828
                                                                                                                       // 3829
		//set the word spacing for e.g. justify style                                                                        // 3830
		if (style['word-spacing'] !== undefined && style['word-spacing'] > 0) {                                              // 3831
			this.pdf.internal.write(style['word-spacing'].toFixed(2), "Tw");                                                    // 3832
		}                                                                                                                    // 3833
                                                                                                                       // 3834
		this.pdf.internal.write("/" + font.id, (defaultFontSize * style["font-size"]).toFixed(2), "Tf", "(" + this.pdf.internal.pdfEscape(text) + ") Tj");
                                                                                                                       // 3836
		//set the word spacing back to neutral => 0                                                                          // 3837
		if (style['word-spacing'] !== undefined) {                                                                           // 3838
			this.pdf.internal.write(0, "Tw");                                                                                   // 3839
		}                                                                                                                    // 3840
	};                                                                                                                    // 3841
	Renderer.prototype.renderParagraph = function (cb) {                                                                  // 3842
		var blockstyle,                                                                                                      // 3843
		defaultFontSize,                                                                                                     // 3844
		fontToUnitRatio,                                                                                                     // 3845
		fragments,                                                                                                           // 3846
		i,                                                                                                                   // 3847
		l,                                                                                                                   // 3848
		line,                                                                                                                // 3849
		lines,                                                                                                               // 3850
		maxLineHeight,                                                                                                       // 3851
		out,                                                                                                                 // 3852
		paragraphspacing_after,                                                                                              // 3853
		paragraphspacing_before,                                                                                             // 3854
		priorblockstype,                                                                                                     // 3855
		styles,                                                                                                              // 3856
		fontSize;                                                                                                            // 3857
		fragments = PurgeWhiteSpace(this.paragraph.text);                                                                    // 3858
		styles = this.paragraph.style;                                                                                       // 3859
		blockstyle = this.paragraph.blockstyle;                                                                              // 3860
		priorblockstype = this.paragraph.blockstyle || {};                                                                   // 3861
		this.paragraph = {                                                                                                   // 3862
			text : [],                                                                                                          // 3863
			style : [],                                                                                                         // 3864
			blockstyle : {},                                                                                                    // 3865
			priorblockstyle : blockstyle                                                                                        // 3866
		};                                                                                                                   // 3867
		if (!fragments.join("").trim()) {                                                                                    // 3868
			return;                                                                                                             // 3869
		}                                                                                                                    // 3870
		lines = this.splitFragmentsIntoLines(fragments, styles);                                                             // 3871
		line = void 0;                                                                                                       // 3872
		maxLineHeight = void 0;                                                                                              // 3873
		defaultFontSize = 12;                                                                                                // 3874
		fontToUnitRatio = defaultFontSize / this.pdf.internal.scaleFactor;                                                   // 3875
		paragraphspacing_before = (Math.max((blockstyle["margin-top"] || 0) - (priorblockstype["margin-bottom"] || 0), 0) + (blockstyle["padding-top"] || 0)) * fontToUnitRatio;
		paragraphspacing_after = ((blockstyle["margin-bottom"] || 0) + (blockstyle["padding-bottom"] || 0)) * fontToUnitRatio;
		out = this.pdf.internal.write;                                                                                       // 3878
		i = void 0;                                                                                                          // 3879
		l = void 0;                                                                                                          // 3880
		this.y += paragraphspacing_before;                                                                                   // 3881
		out("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");
                                                                                                                       // 3883
		//stores the current indent of cursor position                                                                       // 3884
		var currentIndent = 0;                                                                                               // 3885
                                                                                                                       // 3886
		while (lines.length) {                                                                                               // 3887
			line = lines.shift();                                                                                               // 3888
			maxLineHeight = 0;                                                                                                  // 3889
			i = 0;                                                                                                              // 3890
			l = line.length;                                                                                                    // 3891
			while (i !== l) {                                                                                                   // 3892
				if (line[i][0].trim()) {                                                                                           // 3893
					maxLineHeight = Math.max(maxLineHeight, line[i][1]["line-height"], line[i][1]["font-size"]);                      // 3894
					fontSize = line[i][1]["font-size"] * 7;                                                                           // 3895
				}                                                                                                                  // 3896
				i++;                                                                                                               // 3897
			}                                                                                                                   // 3898
			//if we have to move the cursor to adapt the indent                                                                 // 3899
			var indentMove = 0;                                                                                                 // 3900
			//if a margin was added (by e.g. a text-alignment), move the cursor                                                 // 3901
			if (line[0][1]["margin-left"] !== undefined && line[0][1]["margin-left"] > 0) {                                     // 3902
				wantedIndent = this.pdf.internal.getCoordinateString(line[0][1]["margin-left"]);                                   // 3903
				indentMove = wantedIndent - currentIndent;                                                                         // 3904
				currentIndent = wantedIndent;                                                                                      // 3905
			}                                                                                                                   // 3906
			//move the cursor                                                                                                   // 3907
			out(indentMove, (-1 * defaultFontSize * maxLineHeight).toFixed(2), "Td");                                           // 3908
			i = 0;                                                                                                              // 3909
			l = line.length;                                                                                                    // 3910
			while (i !== l) {                                                                                                   // 3911
				if (line[i][0]) {                                                                                                  // 3912
					this.RenderTextFragment(line[i][0], line[i][1]);                                                                  // 3913
				}                                                                                                                  // 3914
				i++;                                                                                                               // 3915
			}                                                                                                                   // 3916
			this.y += maxLineHeight * fontToUnitRatio;                                                                          // 3917
                                                                                                                       // 3918
			//if some watcher function was executed sucessful, so e.g. margin and widths were changed,                          // 3919
			//reset line drawing and calculate position and lines again                                                         // 3920
			//e.g. to stop text floating around an image                                                                        // 3921
			if (this.executeWatchFunctions(line[0][1]) && lines.length > 0) {                                                   // 3922
				var localFragments = [];                                                                                           // 3923
				var localStyles = [];                                                                                              // 3924
				//create fragement array of                                                                                        // 3925
				lines.forEach(function(localLine) {                                                                                // 3926
					var i = 0;                                                                                                        // 3927
					var l = localLine.length;                                                                                         // 3928
					while (i !== l) {                                                                                                 // 3929
						if (localLine[i][0]) {                                                                                           // 3930
							localFragments.push(localLine[i][0]+' ');                                                                       // 3931
							localStyles.push(localLine[i][1]);                                                                              // 3932
						}                                                                                                                // 3933
						++i;                                                                                                             // 3934
					}                                                                                                                 // 3935
				});                                                                                                                // 3936
				//split lines again due to possible coordinate changes                                                             // 3937
				lines = this.splitFragmentsIntoLines(PurgeWhiteSpace(localFragments), localStyles);                                // 3938
				//reposition the current cursor                                                                                    // 3939
				out("ET", "Q");                                                                                                    // 3940
				out("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");
			}                                                                                                                   // 3942
                                                                                                                       // 3943
		}                                                                                                                    // 3944
		if (cb && typeof cb === "function") {                                                                                // 3945
			cb.call(this, this.x - 9, this.y - fontSize / 2);                                                                   // 3946
		}                                                                                                                    // 3947
		out("ET", "Q");                                                                                                      // 3948
		return this.y += paragraphspacing_after;                                                                             // 3949
	};                                                                                                                    // 3950
	Renderer.prototype.setBlockBoundary = function (cb) {                                                                 // 3951
		return this.renderParagraph(cb);                                                                                     // 3952
	};                                                                                                                    // 3953
	Renderer.prototype.setBlockStyle = function (css) {                                                                   // 3954
		return this.paragraph.blockstyle = css;                                                                              // 3955
	};                                                                                                                    // 3956
	Renderer.prototype.addText = function (text, css) {                                                                   // 3957
		this.paragraph.text.push(text);                                                                                      // 3958
		return this.paragraph.style.push(css);                                                                               // 3959
	};                                                                                                                    // 3960
	FontNameDB = {                                                                                                        // 3961
		helvetica         : "helvetica",                                                                                     // 3962
		"sans-serif"      : "helvetica",                                                                                     // 3963
		"times new roman" : "times",                                                                                         // 3964
		serif             : "times",                                                                                         // 3965
		times             : "times",                                                                                         // 3966
		monospace         : "courier",                                                                                       // 3967
		courier           : "courier"                                                                                        // 3968
	};                                                                                                                    // 3969
	FontWeightMap = {                                                                                                     // 3970
		100 : "normal",                                                                                                      // 3971
		200 : "normal",                                                                                                      // 3972
		300 : "normal",                                                                                                      // 3973
		400 : "normal",                                                                                                      // 3974
		500 : "bold",                                                                                                        // 3975
		600 : "bold",                                                                                                        // 3976
		700 : "bold",                                                                                                        // 3977
		800 : "bold",                                                                                                        // 3978
		900 : "bold",                                                                                                        // 3979
		normal  : "normal",                                                                                                  // 3980
		bold    : "bold",                                                                                                    // 3981
		bolder  : "bold",                                                                                                    // 3982
		lighter : "normal"                                                                                                   // 3983
	};                                                                                                                    // 3984
	FontStyleMap = {                                                                                                      // 3985
		normal  : "normal",                                                                                                  // 3986
		italic  : "italic",                                                                                                  // 3987
		oblique : "italic"                                                                                                   // 3988
	};                                                                                                                    // 3989
	TextAlignMap = {                                                                                                      // 3990
		left    : "left",                                                                                                    // 3991
		right   : "right",                                                                                                   // 3992
		center  : "center",                                                                                                  // 3993
		justify : "justify"                                                                                                  // 3994
	};                                                                                                                    // 3995
	FloatMap = {                                                                                                          // 3996
		none : 'none',                                                                                                       // 3997
		right: 'right',                                                                                                      // 3998
		left: 'left'                                                                                                         // 3999
	};                                                                                                                    // 4000
	ClearMap = {                                                                                                          // 4001
	  none : 'none',                                                                                                      // 4002
	  both : 'both'                                                                                                       // 4003
	};                                                                                                                    // 4004
	UnitedNumberMap = {                                                                                                   // 4005
		normal : 1                                                                                                           // 4006
	};                                                                                                                    // 4007
	/**                                                                                                                   // 4008
	 * Converts HTML-formatted text into formatted PDF text.                                                              // 4009
	 *                                                                                                                    // 4010
	 * Notes:                                                                                                             // 4011
	 * 2012-07-18                                                                                                         // 4012
	 * Plugin relies on having browser, DOM around. The HTML is pushed into dom and traversed.                            // 4013
	 * Plugin relies on jQuery for CSS extraction.                                                                        // 4014
	 * Targeting HTML output from Markdown templating, which is a very simple                                             // 4015
	 * markup - div, span, em, strong, p. No br-based paragraph separation supported explicitly (but still may work.)     // 4016
	 * Images, tables are NOT supported.                                                                                  // 4017
	 *                                                                                                                    // 4018
	 * @public                                                                                                            // 4019
	 * @function                                                                                                          // 4020
	 * @param HTML {String or DOM Element} HTML-formatted text, or pointer to DOM element that is to be rendered into PDF.
	 * @param x {Number} starting X coordinate in jsPDF instance's declared units.                                        // 4022
	 * @param y {Number} starting Y coordinate in jsPDF instance's declared units.                                        // 4023
	 * @param settings {Object} Additional / optional variables controlling parsing, rendering.                           // 4024
	 * @returns {Object} jsPDF instance                                                                                   // 4025
	 */                                                                                                                   // 4026
	jsPDFAPI.fromHTML = function (HTML, x, y, settings, callback, margins) {                                              // 4027
		"use strict";                                                                                                        // 4028
                                                                                                                       // 4029
		this.margins_doc = margins || {                                                                                      // 4030
			top : 0,                                                                                                            // 4031
			bottom : 0                                                                                                          // 4032
		};                                                                                                                   // 4033
		if (!settings)                                                                                                       // 4034
			settings = {};                                                                                                      // 4035
		if (!settings.elementHandlers)                                                                                       // 4036
			settings.elementHandlers = {};                                                                                      // 4037
                                                                                                                       // 4038
		return process(this, HTML, isNaN(x) ? 4 : x, isNaN(y) ? 4 : y, settings, callback);                                  // 4039
	};                                                                                                                    // 4040
})(jsPDF.API);                                                                                                         // 4041
/** ====================================================================                                               // 4042
 * jsPDF JavaScript plugin                                                                                             // 4043
 * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com                                                         // 4044
 *                                                                                                                     // 4045
 * Permission is hereby granted, free of charge, to any person obtaining                                               // 4046
 * a copy of this software and associated documentation files (the                                                     // 4047
 * "Software"), to deal in the Software without restriction, including                                                 // 4048
 * without limitation the rights to use, copy, modify, merge, publish,                                                 // 4049
 * distribute, sublicense, and/or sell copies of the Software, and to                                                  // 4050
 * permit persons to whom the Software is furnished to do so, subject to                                               // 4051
 * the following conditions:                                                                                           // 4052
 *                                                                                                                     // 4053
 * The above copyright notice and this permission notice shall be                                                      // 4054
 * included in all copies or substantial portions of the Software.                                                     // 4055
 *                                                                                                                     // 4056
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,                                                     // 4057
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                  // 4058
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                                                               // 4059
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE                                              // 4060
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION                                              // 4061
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION                                               // 4062
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                                     // 4063
 * ====================================================================                                                // 4064
 */                                                                                                                    // 4065
                                                                                                                       // 4066
/*global jsPDF */                                                                                                      // 4067
                                                                                                                       // 4068
(function (jsPDFAPI) {                                                                                                 // 4069
    'use strict';                                                                                                      // 4070
    var jsNamesObj, jsJsObj, text;                                                                                     // 4071
    jsPDFAPI.addJS = function (txt) {                                                                                  // 4072
        text = txt;                                                                                                    // 4073
        this.internal.events.subscribe(                                                                                // 4074
            'postPutResources',                                                                                        // 4075
            function (txt) {                                                                                           // 4076
                jsNamesObj = this.internal.newObject();                                                                // 4077
                this.internal.write('<< /Names [(EmbeddedJS) ' + (jsNamesObj + 1) + ' 0 R] >>', 'endobj');             // 4078
                jsJsObj = this.internal.newObject();                                                                   // 4079
                this.internal.write('<< /S /JavaScript /JS (', text, ') >>', 'endobj');                                // 4080
            }                                                                                                          // 4081
        );                                                                                                             // 4082
        this.internal.events.subscribe(                                                                                // 4083
            'putCatalog',                                                                                              // 4084
            function () {                                                                                              // 4085
                if (jsNamesObj !== undefined && jsJsObj !== undefined) {                                               // 4086
                    this.internal.write('/Names <</JavaScript ' + jsNamesObj + ' 0 R>>');                              // 4087
                }                                                                                                      // 4088
            }                                                                                                          // 4089
        );                                                                                                             // 4090
        return this;                                                                                                   // 4091
    };                                                                                                                 // 4092
}(jsPDF.API));                                                                                                         // 4093
/**@preserve                                                                                                           // 4094
 *  ====================================================================                                               // 4095
 * jsPDF PNG PlugIn                                                                                                    // 4096
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb                                                        // 4097
 *                                                                                                                     // 4098
 * Permission is hereby granted, free of charge, to any person obtaining                                               // 4099
 * a copy of this software and associated documentation files (the                                                     // 4100
 * "Software"), to deal in the Software without restriction, including                                                 // 4101
 * without limitation the rights to use, copy, modify, merge, publish,                                                 // 4102
 * distribute, sublicense, and/or sell copies of the Software, and to                                                  // 4103
 * permit persons to whom the Software is furnished to do so, subject to                                               // 4104
 * the following conditions:                                                                                           // 4105
 *                                                                                                                     // 4106
 * The above copyright notice and this permission notice shall be                                                      // 4107
 * included in all copies or substantial portions of the Software.                                                     // 4108
 *                                                                                                                     // 4109
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,                                                     // 4110
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                  // 4111
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                                                               // 4112
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE                                              // 4113
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION                                              // 4114
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION                                               // 4115
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                                     // 4116
 * ====================================================================                                                // 4117
 */                                                                                                                    // 4118
                                                                                                                       // 4119
(function(jsPDFAPI) {                                                                                                  // 4120
'use strict'                                                                                                           // 4121
	                                                                                                                      // 4122
	/*                                                                                                                    // 4123
	 * @see http://www.w3.org/TR/PNG-Chunks.html                                                                          // 4124
	 *                                                                                                                    // 4125
	 Color    Allowed      Interpretation                                                                                 // 4126
	 Type     Bit Depths                                                                                                  // 4127
	                                                                                                                      // 4128
	   0       1,2,4,8,16  Each pixel is a grayscale sample.                                                              // 4129
	                                                                                                                      // 4130
	   2       8,16        Each pixel is an R,G,B triple.                                                                 // 4131
	                                                                                                                      // 4132
	   3       1,2,4,8     Each pixel is a palette index;                                                                 // 4133
	                       a PLTE chunk must appear.                                                                      // 4134
	                                                                                                                      // 4135
	   4       8,16        Each pixel is a grayscale sample,                                                              // 4136
	                       followed by an alpha sample.                                                                   // 4137
	                                                                                                                      // 4138
	   6       8,16        Each pixel is an R,G,B triple,                                                                 // 4139
	                       followed by an alpha sample.                                                                   // 4140
	*/                                                                                                                    // 4141
	                                                                                                                      // 4142
	/*                                                                                                                    // 4143
	 * PNG filter method types                                                                                            // 4144
	 *                                                                                                                    // 4145
	 * @see http://www.w3.org/TR/PNG-Filters.html                                                                         // 4146
	 * @see http://www.libpng.org/pub/png/book/chapter09.html                                                             // 4147
	 *                                                                                                                    // 4148
	 * This is what the value 'Predictor' in decode params relates to                                                     // 4149
	 *                                                                                                                    // 4150
	 * 15 is "optimal prediction", which means the prediction algorithm can change from line to line.                     // 4151
	 * In that case, you actually have to read the first byte off each line for the prediction algorthim (which should be 0-4, corresponding to PDF 10-14) and select the appropriate unprediction algorithm based on that byte.
	 *                                                                                                                    // 4153
	   0       None                                                                                                       // 4154
	   1       Sub                                                                                                        // 4155
	   2       Up                                                                                                         // 4156
	   3       Average                                                                                                    // 4157
	   4       Paeth                                                                                                      // 4158
	 */                                                                                                                   // 4159
	                                                                                                                      // 4160
	var doesNotHavePngJS = function() {                                                                                   // 4161
		return typeof PNG !== 'function' || typeof FlateStream !== 'function';                                               // 4162
	}                                                                                                                     // 4163
	, canCompress = function(value) {                                                                                     // 4164
		return value !== jsPDFAPI.image_compression.NONE && hasCompressionJS();                                              // 4165
	}                                                                                                                     // 4166
	, hasCompressionJS = function() {                                                                                     // 4167
		var inst = typeof Deflater === 'function';                                                                           // 4168
		if(!inst)                                                                                                            // 4169
			throw new Error("requires deflate.js for compression")                                                              // 4170
		return inst;                                                                                                         // 4171
	}                                                                                                                     // 4172
	, compressBytes = function(bytes, lineLength, colorsPerPixel, compression) {                                          // 4173
		                                                                                                                     // 4174
		var level = 5,                                                                                                       // 4175
			filter_method = filterUp;                                                                                           // 4176
		                                                                                                                     // 4177
		switch(compression) {                                                                                                // 4178
		                                                                                                                     // 4179
			case jsPDFAPI.image_compression.FAST:                                                                               // 4180
				                                                                                                                   // 4181
				level = 3;                                                                                                         // 4182
				filter_method = filterSub;                                                                                         // 4183
				break;                                                                                                             // 4184
				                                                                                                                   // 4185
			case jsPDFAPI.image_compression.MEDIUM:                                                                             // 4186
				                                                                                                                   // 4187
				level = 6;                                                                                                         // 4188
				filter_method = filterAverage;                                                                                     // 4189
				break;                                                                                                             // 4190
				                                                                                                                   // 4191
			case jsPDFAPI.image_compression.SLOW:                                                                               // 4192
				                                                                                                                   // 4193
				level = 9;                                                                                                         // 4194
				filter_method = filterPaeth;//uses to sum to choose best filter for each line                                      // 4195
				break;                                                                                                             // 4196
		}                                                                                                                    // 4197
		                                                                                                                     // 4198
		bytes = applyPngFilterMethod(bytes, lineLength, colorsPerPixel, filter_method);                                      // 4199
		                                                                                                                     // 4200
		var header = new Uint8Array(createZlibHeader(level));                                                                // 4201
		var checksum = adler32(bytes);                                                                                       // 4202
		                                                                                                                     // 4203
		var deflate = new Deflater(level);                                                                                   // 4204
		var a = deflate.append(bytes);                                                                                       // 4205
		var cBytes = deflate.flush();                                                                                        // 4206
		                                                                                                                     // 4207
		var len = header.length + a.length + cBytes.length;                                                                  // 4208
		                                                                                                                     // 4209
		var cmpd = new Uint8Array(len + 4);                                                                                  // 4210
		cmpd.set(header);                                                                                                    // 4211
		cmpd.set(a, header.length);                                                                                          // 4212
		cmpd.set(cBytes, header.length + a.length);                                                                          // 4213
		                                                                                                                     // 4214
		cmpd[len++] = (checksum >>> 24) & 0xff;                                                                              // 4215
		cmpd[len++] = (checksum >>> 16) & 0xff;                                                                              // 4216
		cmpd[len++] = (checksum >>> 8) & 0xff;                                                                               // 4217
		cmpd[len++] = checksum & 0xff;                                                                                       // 4218
		                                                                                                                     // 4219
		return jsPDFAPI.arrayBufferToBinaryString(cmpd);                                                                     // 4220
	}                                                                                                                     // 4221
	, createZlibHeader = function(bytes, level){                                                                          // 4222
		/*                                                                                                                   // 4223
		 * @see http://www.ietf.org/rfc/rfc1950.txt for zlib header                                                          // 4224
		 */                                                                                                                  // 4225
		var cm = 8;                                                                                                          // 4226
        var cinfo = Math.LOG2E * Math.log(0x8000) - 8;                                                                 // 4227
        var cmf = (cinfo << 4) | cm;                                                                                   // 4228
                                                                                                                       // 4229
        var hdr = cmf << 8;                                                                                            // 4230
        var flevel = Math.min(3, ((level - 1) & 0xff) >> 1);                                                           // 4231
                                                                                                                       // 4232
        hdr |= (flevel << 6);                                                                                          // 4233
        hdr |= 0;//FDICT                                                                                               // 4234
        hdr += 31 - (hdr % 31);                                                                                        // 4235
                                                                                                                       // 4236
        return [cmf, (hdr & 0xff) & 0xff];                                                                             // 4237
	}                                                                                                                     // 4238
	, adler32 = function(array, param) {                                                                                  // 4239
		var adler = 1;                                                                                                       // 4240
	    var s1 = adler & 0xffff,                                                                                          // 4241
	        s2 = (adler >>> 16) & 0xffff;                                                                                 // 4242
	    var len = array.length;                                                                                           // 4243
	    var tlen;                                                                                                         // 4244
	    var i = 0;                                                                                                        // 4245
                                                                                                                       // 4246
	    while (len > 0) {                                                                                                 // 4247
	      tlen = len > param ? param : len;                                                                               // 4248
	      len -= tlen;                                                                                                    // 4249
	      do {                                                                                                            // 4250
	        s1 += array[i++];                                                                                             // 4251
	        s2 += s1;                                                                                                     // 4252
	      } while (--tlen);                                                                                               // 4253
                                                                                                                       // 4254
	      s1 %= 65521;                                                                                                    // 4255
	      s2 %= 65521;                                                                                                    // 4256
	    }                                                                                                                 // 4257
                                                                                                                       // 4258
	    return ((s2 << 16) | s1) >>> 0;                                                                                   // 4259
	}                                                                                                                     // 4260
	, applyPngFilterMethod = function(bytes, lineLength, colorsPerPixel, filter_method) {                                 // 4261
		var lines = bytes.length / lineLength,                                                                               // 4262
			result = new Uint8Array(bytes.length + lines),                                                                      // 4263
			filter_methods = getFilterMethods(),                                                                                // 4264
			i = 0, line, prevLine, offset;                                                                                      // 4265
		                                                                                                                     // 4266
		for(; i < lines; i++) {                                                                                              // 4267
			offset = i * lineLength;                                                                                            // 4268
			line = bytes.subarray(offset, offset + lineLength);                                                                 // 4269
			                                                                                                                    // 4270
			if(filter_method) {                                                                                                 // 4271
				result.set(filter_method(line, colorsPerPixel, prevLine), offset + i);                                             // 4272
				                                                                                                                   // 4273
			}else{                                                                                                              // 4274
			                                                                                                                    // 4275
				var j = 0,                                                                                                         // 4276
					len = filter_methods.length,                                                                                      // 4277
					results = [];                                                                                                     // 4278
				                                                                                                                   // 4279
				for(; j < len; j++)                                                                                                // 4280
					results[j] = filter_methods[j](line, colorsPerPixel, prevLine);                                                   // 4281
				                                                                                                                   // 4282
				var ind = getIndexOfSmallestSum(results.concat());                                                                 // 4283
				                                                                                                                   // 4284
				result.set(results[ind], offset + i);                                                                              // 4285
			}                                                                                                                   // 4286
			                                                                                                                    // 4287
			prevLine = line;                                                                                                    // 4288
		}                                                                                                                    // 4289
		                                                                                                                     // 4290
		return result;                                                                                                       // 4291
	}                                                                                                                     // 4292
	, filterNone = function(line, colorsPerPixel, prevLine) {                                                             // 4293
		/*var result = new Uint8Array(line.length + 1);                                                                      // 4294
		result[0] = 0;                                                                                                       // 4295
		result.set(line, 1);*/                                                                                               // 4296
		                                                                                                                     // 4297
		var result = Array.apply([], line);                                                                                  // 4298
		result.unshift(0);                                                                                                   // 4299
                                                                                                                       // 4300
		return result;                                                                                                       // 4301
	}                                                                                                                     // 4302
	, filterSub = function(line, colorsPerPixel, prevLine) {                                                              // 4303
		var result = [],                                                                                                     // 4304
			i = 0,                                                                                                              // 4305
			len = line.length,                                                                                                  // 4306
			left;                                                                                                               // 4307
		                                                                                                                     // 4308
		result[0] = 1;                                                                                                       // 4309
		                                                                                                                     // 4310
		for(; i < len; i++) {                                                                                                // 4311
			left = line[i - colorsPerPixel] || 0;                                                                               // 4312
			result[i + 1] = (line[i] - left + 0x0100) & 0xff;                                                                   // 4313
		}                                                                                                                    // 4314
		                                                                                                                     // 4315
		return result;                                                                                                       // 4316
	}                                                                                                                     // 4317
	, filterUp = function(line, colorsPerPixel, prevLine) {                                                               // 4318
		var result = [],                                                                                                     // 4319
			i = 0,                                                                                                              // 4320
			len = line.length,                                                                                                  // 4321
			up;                                                                                                                 // 4322
		                                                                                                                     // 4323
		result[0] = 2;                                                                                                       // 4324
		                                                                                                                     // 4325
		for(; i < len; i++) {                                                                                                // 4326
			up = prevLine && prevLine[i] || 0;                                                                                  // 4327
			result[i + 1] = (line[i] - up + 0x0100) & 0xff;                                                                     // 4328
		}                                                                                                                    // 4329
		                                                                                                                     // 4330
		return result;                                                                                                       // 4331
	}                                                                                                                     // 4332
	, filterAverage = function(line, colorsPerPixel, prevLine) {                                                          // 4333
		var result = [],                                                                                                     // 4334
			i = 0,                                                                                                              // 4335
			len = line.length,                                                                                                  // 4336
			left,                                                                                                               // 4337
			up;                                                                                                                 // 4338
	                                                                                                                      // 4339
		result[0] = 3;                                                                                                       // 4340
		                                                                                                                     // 4341
		for(; i < len; i++) {                                                                                                // 4342
			left = line[i - colorsPerPixel] || 0;                                                                               // 4343
			up = prevLine && prevLine[i] || 0;                                                                                  // 4344
			result[i + 1] = (line[i] + 0x0100 - ((left + up) >>> 1)) & 0xff;                                                    // 4345
		}                                                                                                                    // 4346
		                                                                                                                     // 4347
		return result;                                                                                                       // 4348
	}                                                                                                                     // 4349
	, filterPaeth = function(line, colorsPerPixel, prevLine) {                                                            // 4350
		var result = [],                                                                                                     // 4351
			i = 0,                                                                                                              // 4352
			len = line.length,                                                                                                  // 4353
			left,                                                                                                               // 4354
			up,                                                                                                                 // 4355
			upLeft,                                                                                                             // 4356
			paeth;                                                                                                              // 4357
		                                                                                                                     // 4358
		result[0] = 4;                                                                                                       // 4359
		                                                                                                                     // 4360
		for(; i < len; i++) {                                                                                                // 4361
			left = line[i - colorsPerPixel] || 0;                                                                               // 4362
			up = prevLine && prevLine[i] || 0;                                                                                  // 4363
			upLeft = prevLine && prevLine[i - colorsPerPixel] || 0;                                                             // 4364
			paeth = paethPredictor(left, up, upLeft);                                                                           // 4365
			result[i + 1] = (line[i] - paeth + 0x0100) & 0xff;                                                                  // 4366
		}                                                                                                                    // 4367
		                                                                                                                     // 4368
		return result;                                                                                                       // 4369
	}                                                                                                                     // 4370
	,paethPredictor = function(left, up, upLeft) {                                                                        // 4371
                                                                                                                       // 4372
		var p = left + up - upLeft,                                                                                          // 4373
	        pLeft = Math.abs(p - left),                                                                                   // 4374
	        pUp = Math.abs(p - up),                                                                                       // 4375
	        pUpLeft = Math.abs(p - upLeft);                                                                               // 4376
		                                                                                                                     // 4377
		return (pLeft <= pUp && pLeft <= pUpLeft) ? left : (pUp <= pUpLeft) ? up : upLeft;                                   // 4378
	}                                                                                                                     // 4379
	, getFilterMethods = function() {                                                                                     // 4380
		return [filterNone, filterSub, filterUp, filterAverage, filterPaeth];                                                // 4381
	}                                                                                                                     // 4382
	,getIndexOfSmallestSum = function(arrays) {                                                                           // 4383
		var i = 0,                                                                                                           // 4384
			len = arrays.length,                                                                                                // 4385
			sum, min, ind;                                                                                                      // 4386
		                                                                                                                     // 4387
		while(i < len) {                                                                                                     // 4388
			sum = absSum(arrays[i].slice(1));                                                                                   // 4389
			                                                                                                                    // 4390
			if(sum < min || !min) {                                                                                             // 4391
				min = sum;                                                                                                         // 4392
				ind = i;                                                                                                           // 4393
			}                                                                                                                   // 4394
			                                                                                                                    // 4395
			i++;                                                                                                                // 4396
		}                                                                                                                    // 4397
		                                                                                                                     // 4398
		return ind;                                                                                                          // 4399
	}                                                                                                                     // 4400
	, absSum = function(array) {                                                                                          // 4401
		var i = 0,                                                                                                           // 4402
			len = array.length,                                                                                                 // 4403
			sum = 0;                                                                                                            // 4404
	                                                                                                                      // 4405
		while(i < len)                                                                                                       // 4406
			sum += Math.abs(array[i++]);                                                                                        // 4407
			                                                                                                                    // 4408
		return sum;                                                                                                          // 4409
	}                                                                                                                     // 4410
	, logImg = function(img) {                                                                                            // 4411
		console.log("width: " + img.width);                                                                                  // 4412
		console.log("height: " + img.height);                                                                                // 4413
		console.log("bits: " + img.bits);                                                                                    // 4414
		console.log("colorType: " + img.colorType);                                                                          // 4415
		console.log("transparency:");                                                                                        // 4416
		console.log(img.transparency);                                                                                       // 4417
		console.log("text:");                                                                                                // 4418
		console.log(img.text);                                                                                               // 4419
		console.log("compressionMethod: " + img.compressionMethod);                                                          // 4420
		console.log("filterMethod: " + img.filterMethod);                                                                    // 4421
		console.log("interlaceMethod: " + img.interlaceMethod);                                                              // 4422
		console.log("imgData:");                                                                                             // 4423
		console.log(img.imgData);                                                                                            // 4424
		console.log("palette:");                                                                                             // 4425
		console.log(img.palette);                                                                                            // 4426
		console.log("colors: " + img.colors);                                                                                // 4427
		console.log("colorSpace: " + img.colorSpace);                                                                        // 4428
		console.log("pixelBitlength: " + img.pixelBitlength);                                                                // 4429
		console.log("hasAlphaChannel: " + img.hasAlphaChannel);                                                              // 4430
	};                                                                                                                    // 4431
	                                                                                                                      // 4432
	                                                                                                                      // 4433
	                                                                                                                      // 4434
	                                                                                                                      // 4435
	jsPDFAPI.processPNG = function(imageData, imageIndex, alias, compression, dataAsBinaryString) {                       // 4436
		'use strict'                                                                                                         // 4437
		                                                                                                                     // 4438
		var colorSpace = this.color_spaces.DEVICE_RGB,                                                                       // 4439
			decode = this.decode.FLATE_DECODE,                                                                                  // 4440
			bpc = 8,                                                                                                            // 4441
			img, dp, trns,                                                                                                      // 4442
			colors, pal, smask;                                                                                                 // 4443
		                                                                                                                     // 4444
	/*	if(this.isString(imageData)) {                                                                                     // 4445
			                                                                                                                    // 4446
		}*/                                                                                                                  // 4447
		                                                                                                                     // 4448
		if(this.isArrayBuffer(imageData))                                                                                    // 4449
			imageData = new Uint8Array(imageData);                                                                              // 4450
		                                                                                                                     // 4451
		if(this.isArrayBufferView(imageData)) {                                                                              // 4452
			                                                                                                                    // 4453
			if(doesNotHavePngJS())                                                                                              // 4454
				throw new Error("PNG support requires png.js and zlib.js");                                                        // 4455
				                                                                                                                   // 4456
			img = new PNG(imageData);                                                                                           // 4457
			imageData = img.imgData;                                                                                            // 4458
			bpc = img.bits;                                                                                                     // 4459
			colorSpace = img.colorSpace;                                                                                        // 4460
			colors = img.colors;                                                                                                // 4461
			                                                                                                                    // 4462
			//logImg(img);                                                                                                      // 4463
			                                                                                                                    // 4464
			/*                                                                                                                  // 4465
			 * colorType 6 - Each pixel is an R,G,B triple, followed by an alpha sample.                                        // 4466
			 *                                                                                                                  // 4467
			 * colorType 4 - Each pixel is a grayscale sample, followed by an alpha sample.                                     // 4468
			 *                                                                                                                  // 4469
			 * Extract alpha to create two separate images, using the alpha as a sMask                                          // 4470
			 */                                                                                                                 // 4471
			if([4,6].indexOf(img.colorType) !== -1) {                                                                           // 4472
				                                                                                                                   // 4473
				/*                                                                                                                 // 4474
				 * processes 8 bit RGBA and grayscale + alpha images                                                               // 4475
				 */                                                                                                                // 4476
				if(img.bits === 8) {                                                                                               // 4477
				                                                                                                                   // 4478
				        var pixels = img.pixelBitlength == 32 ? new Uint32Array(img.decodePixels().buffer) : img.pixelBitlength == 16 ? new Uint16Array(img.decodePixels().buffer) : new Uint8Array(img.decodePixels().buffer),
						len = pixels.length,                                                                                             // 4480
						imgData = new Uint8Array(len * img.colors),                                                                      // 4481
						alphaData = new Uint8Array(len),                                                                                 // 4482
						pDiff = img.pixelBitlength - img.bits,                                                                           // 4483
						i = 0, n = 0, pixel, pbl;                                                                                        // 4484
				                                                                                                                   // 4485
					for(; i < len; i++) {                                                                                             // 4486
						pixel = pixels[i];                                                                                               // 4487
						pbl = 0;                                                                                                         // 4488
						                                                                                                                 // 4489
						while(pbl < pDiff) {                                                                                             // 4490
							                                                                                                                // 4491
							imgData[n++] = ( pixel >>> pbl ) & 0xff;                                                                        // 4492
							pbl = pbl + img.bits;                                                                                           // 4493
						}                                                                                                                // 4494
						                                                                                                                 // 4495
						alphaData[i] = ( pixel >>> pbl ) & 0xff;                                                                         // 4496
					}                                                                                                                 // 4497
				}                                                                                                                  // 4498
				                                                                                                                   // 4499
				/*                                                                                                                 // 4500
				 * processes 16 bit RGBA and grayscale + alpha images                                                              // 4501
				 */                                                                                                                // 4502
				if(img.bits === 16) {                                                                                              // 4503
					                                                                                                                  // 4504
					var pixels = new Uint32Array(img.decodePixels().buffer),                                                          // 4505
						len = pixels.length,                                                                                             // 4506
						imgData = new Uint8Array((len * (32 / img.pixelBitlength) ) * img.colors),                                       // 4507
						alphaData = new Uint8Array(len * (32 / img.pixelBitlength) ),                                                    // 4508
						hasColors = img.colors > 1,                                                                                      // 4509
						i = 0, n = 0, a = 0, pixel;                                                                                      // 4510
					                                                                                                                  // 4511
					while(i < len) {                                                                                                  // 4512
						pixel = pixels[i++];                                                                                             // 4513
						                                                                                                                 // 4514
						imgData[n++] = (pixel >>> 0) & 0xFF;                                                                             // 4515
						                                                                                                                 // 4516
						if(hasColors) {                                                                                                  // 4517
							imgData[n++] = (pixel >>> 16) & 0xFF;                                                                           // 4518
							                                                                                                                // 4519
							pixel = pixels[i++];                                                                                            // 4520
							imgData[n++] = (pixel >>> 0) & 0xFF;                                                                            // 4521
						}                                                                                                                // 4522
						                                                                                                                 // 4523
						alphaData[a++] = (pixel >>> 16) & 0xFF;                                                                          // 4524
					}                                                                                                                 // 4525
					                                                                                                                  // 4526
					bpc = 8;                                                                                                          // 4527
				}                                                                                                                  // 4528
				                                                                                                                   // 4529
				if(canCompress(compression)) {                                                                                     // 4530
										                                                                                                             // 4531
					imageData = compressBytes(imgData, img.width * img.colors, img.colors, compression);                              // 4532
					smask = compressBytes(alphaData, img.width, 1, compression);                                                      // 4533
					                                                                                                                  // 4534
				}else{                                                                                                             // 4535
					                                                                                                                  // 4536
					imageData = imgData;                                                                                              // 4537
					smask = alphaData;                                                                                                // 4538
					decode = null;                                                                                                    // 4539
				}                                                                                                                  // 4540
			}                                                                                                                   // 4541
			                                                                                                                    // 4542
			/*                                                                                                                  // 4543
			 * Indexed png. Each pixel is a palette index.                                                                      // 4544
			 */                                                                                                                 // 4545
			if(img.colorType === 3) {                                                                                           // 4546
				                                                                                                                   // 4547
				colorSpace = this.color_spaces.INDEXED;                                                                            // 4548
				pal = img.palette;                                                                                                 // 4549
				                                                                                                                   // 4550
				if(img.transparency.indexed) {                                                                                     // 4551
					                                                                                                                  // 4552
					var trans = img.transparency.indexed;                                                                             // 4553
					                                                                                                                  // 4554
					var total = 0,                                                                                                    // 4555
						i = 0,                                                                                                           // 4556
						len = trans.length;                                                                                              // 4557
                                                                                                                       // 4558
					for(; i<len; ++i)                                                                                                 // 4559
					    total += trans[i];                                                                                            // 4560
					                                                                                                                  // 4561
					total = total / 255;                                                                                              // 4562
					                                                                                                                  // 4563
					/*                                                                                                                // 4564
					 * a single color is specified as 100% transparent (0),                                                           // 4565
					 * so we set trns to use a /Mask with that index                                                                  // 4566
					 */                                                                                                               // 4567
					if(total === len - 1 && trans.indexOf(0) !== -1) {                                                                // 4568
						trns = [trans.indexOf(0)];                                                                                       // 4569
					                                                                                                                  // 4570
					/*                                                                                                                // 4571
					 * there's more than one colour within the palette that specifies                                                 // 4572
					 * a transparency value less than 255, so we unroll the pixels to create an image sMask                           // 4573
					 */                                                                                                               // 4574
					}else if(total !== len){                                                                                          // 4575
						                                                                                                                 // 4576
						var pixels = img.decodePixels(),                                                                                 // 4577
							alphaData = new Uint8Array(pixels.length),                                                                      // 4578
							i = 0,                                                                                                          // 4579
							len = pixels.length;                                                                                            // 4580
						                                                                                                                 // 4581
						for(; i < len; i++)                                                                                              // 4582
							alphaData[i] = trans[pixels[i]];                                                                                // 4583
						                                                                                                                 // 4584
						smask = compressBytes(alphaData, img.width, 1);                                                                  // 4585
					}                                                                                                                 // 4586
				}                                                                                                                  // 4587
			}                                                                                                                   // 4588
			                                                                                                                    // 4589
			if(decode === this.decode.FLATE_DECODE)                                                                             // 4590
				dp = '/Predictor 15 /Colors '+ colors +' /BitsPerComponent '+ bpc +' /Columns '+ img.width;                        // 4591
			else                                                                                                                // 4592
				//remove 'Predictor' as it applies to the type of png filter applied to its IDAT - we only apply with compression  // 4593
				dp = '/Colors '+ colors +' /BitsPerComponent '+ bpc +' /Columns '+ img.width;                                      // 4594
			                                                                                                                    // 4595
			if(this.isArrayBuffer(imageData) || this.isArrayBufferView(imageData))                                              // 4596
				imageData = this.arrayBufferToBinaryString(imageData);                                                             // 4597
			                                                                                                                    // 4598
			if(smask && this.isArrayBuffer(smask) || this.isArrayBufferView(smask))                                             // 4599
				smask = this.arrayBufferToBinaryString(smask);                                                                     // 4600
			                                                                                                                    // 4601
			return this.createImageInfo(imageData, img.width, img.height, colorSpace,                                           // 4602
										bpc, decode, imageIndex, alias, dp, trns, pal, smask);                                                       // 4603
		}                                                                                                                    // 4604
		                                                                                                                     // 4605
		throw new Error("Unsupported PNG image data, try using JPEG instead.");                                              // 4606
	}                                                                                                                     // 4607
                                                                                                                       // 4608
})(jsPDF.API)                                                                                                          // 4609
/** @preserve                                                                                                          // 4610
jsPDF Silly SVG plugin                                                                                                 // 4611
Copyright (c) 2012 Willow Systems Corporation, willow-systems.com                                                      // 4612
*/                                                                                                                     // 4613
/**                                                                                                                    // 4614
 * Permission is hereby granted, free of charge, to any person obtaining                                               // 4615
 * a copy of this software and associated documentation files (the                                                     // 4616
 * "Software"), to deal in the Software without restriction, including                                                 // 4617
 * without limitation the rights to use, copy, modify, merge, publish,                                                 // 4618
 * distribute, sublicense, and/or sell copies of the Software, and to                                                  // 4619
 * permit persons to whom the Software is furnished to do so, subject to                                               // 4620
 * the following conditions:                                                                                           // 4621
 *                                                                                                                     // 4622
 * The above copyright notice and this permission notice shall be                                                      // 4623
 * included in all copies or substantial portions of the Software.                                                     // 4624
 *                                                                                                                     // 4625
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,                                                     // 4626
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                  // 4627
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                                                               // 4628
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE                                              // 4629
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION                                              // 4630
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION                                               // 4631
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                                     // 4632
 * ====================================================================                                                // 4633
 */                                                                                                                    // 4634
                                                                                                                       // 4635
;(function(jsPDFAPI) {                                                                                                 // 4636
'use strict'                                                                                                           // 4637
                                                                                                                       // 4638
/**                                                                                                                    // 4639
Parses SVG XML and converts only some of the SVG elements into                                                         // 4640
PDF elements.                                                                                                          // 4641
                                                                                                                       // 4642
Supports:                                                                                                              // 4643
 paths                                                                                                                 // 4644
                                                                                                                       // 4645
@public                                                                                                                // 4646
@function                                                                                                              // 4647
@param                                                                                                                 // 4648
@returns {Type}                                                                                                        // 4649
*/                                                                                                                     // 4650
jsPDFAPI.addSVG = function(svgtext, x, y, w, h) {                                                                      // 4651
	// 'this' is _jsPDF object returned when jsPDF is inited (new jsPDF())                                                // 4652
                                                                                                                       // 4653
	var undef                                                                                                             // 4654
                                                                                                                       // 4655
	if (x === undef || y === undef) {                                                                                     // 4656
		throw new Error("addSVG needs values for 'x' and 'y'");                                                              // 4657
	}                                                                                                                     // 4658
                                                                                                                       // 4659
    function InjectCSS(cssbody, document) {                                                                            // 4660
        var styletag = document.createElement('style');                                                                // 4661
        styletag.type = 'text/css';                                                                                    // 4662
        if (styletag.styleSheet) {                                                                                     // 4663
        	// ie                                                                                                         // 4664
            styletag.styleSheet.cssText = cssbody;                                                                     // 4665
        } else {                                                                                                       // 4666
        	// others                                                                                                     // 4667
            styletag.appendChild(document.createTextNode(cssbody));                                                    // 4668
        }                                                                                                              // 4669
        document.getElementsByTagName("head")[0].appendChild(styletag);                                                // 4670
    }                                                                                                                  // 4671
                                                                                                                       // 4672
	function createWorkerNode(document){                                                                                  // 4673
                                                                                                                       // 4674
		var frameID = 'childframe' // Date.now().toString() + '_' + (Math.random() * 100).toString()                         // 4675
		, frame = document.createElement('iframe')                                                                           // 4676
                                                                                                                       // 4677
		InjectCSS(                                                                                                           // 4678
			'.jsPDF_sillysvg_iframe {display:none;position:absolute;}'                                                          // 4679
			, document                                                                                                          // 4680
		)                                                                                                                    // 4681
                                                                                                                       // 4682
		frame.name = frameID                                                                                                 // 4683
		frame.setAttribute("width", 0)                                                                                       // 4684
		frame.setAttribute("height", 0)                                                                                      // 4685
		frame.setAttribute("frameborder", "0")                                                                               // 4686
		frame.setAttribute("scrolling", "no")                                                                                // 4687
		frame.setAttribute("seamless", "seamless")                                                                           // 4688
		frame.setAttribute("class", "jsPDF_sillysvg_iframe")                                                                 // 4689
		                                                                                                                     // 4690
		document.body.appendChild(frame)                                                                                     // 4691
                                                                                                                       // 4692
		return frame                                                                                                         // 4693
	}                                                                                                                     // 4694
                                                                                                                       // 4695
	function attachSVGToWorkerNode(svgtext, frame){                                                                       // 4696
		var framedoc = ( frame.contentWindow || frame.contentDocument ).document                                             // 4697
		framedoc.write(svgtext)                                                                                              // 4698
		framedoc.close()                                                                                                     // 4699
		return framedoc.getElementsByTagName('svg')[0]                                                                       // 4700
	}                                                                                                                     // 4701
                                                                                                                       // 4702
	function convertPathToPDFLinesArgs(path){                                                                             // 4703
		'use strict'                                                                                                         // 4704
		// we will use 'lines' method call. it needs:                                                                        // 4705
		// - starting coordinate pair                                                                                        // 4706
		// - array of arrays of vector shifts (2-len for line, 6 len for bezier)                                             // 4707
		// - scale array [horizontal, vertical] ratios                                                                       // 4708
		// - style (stroke, fill, both)                                                                                      // 4709
                                                                                                                       // 4710
		var x = parseFloat(path[1])                                                                                          // 4711
		, y = parseFloat(path[2])                                                                                            // 4712
		, vectors = []                                                                                                       // 4713
		, position = 3                                                                                                       // 4714
		, len = path.length                                                                                                  // 4715
                                                                                                                       // 4716
		while (position < len){                                                                                              // 4717
			if (path[position] === 'c'){                                                                                        // 4718
				vectors.push([                                                                                                     // 4719
					parseFloat(path[position + 1])                                                                                    // 4720
					, parseFloat(path[position + 2])                                                                                  // 4721
					, parseFloat(path[position + 3])                                                                                  // 4722
					, parseFloat(path[position + 4])                                                                                  // 4723
					, parseFloat(path[position + 5])                                                                                  // 4724
					, parseFloat(path[position + 6])                                                                                  // 4725
				])                                                                                                                 // 4726
				position += 7                                                                                                      // 4727
			} else if (path[position] === 'l') {                                                                                // 4728
				vectors.push([                                                                                                     // 4729
					parseFloat(path[position + 1])                                                                                    // 4730
					, parseFloat(path[position + 2])                                                                                  // 4731
				])                                                                                                                 // 4732
				position += 3                                                                                                      // 4733
			} else {                                                                                                            // 4734
				position += 1                                                                                                      // 4735
			}                                                                                                                   // 4736
		}                                                                                                                    // 4737
		return [x,y,vectors]                                                                                                 // 4738
	}                                                                                                                     // 4739
                                                                                                                       // 4740
	var workernode = createWorkerNode(document)                                                                           // 4741
	, svgnode = attachSVGToWorkerNode(svgtext, workernode)                                                                // 4742
	, scale = [1,1]                                                                                                       // 4743
	, svgw = parseFloat(svgnode.getAttribute('width'))                                                                    // 4744
	, svgh = parseFloat(svgnode.getAttribute('height'))                                                                   // 4745
                                                                                                                       // 4746
	if (svgw && svgh) {                                                                                                   // 4747
		// setting both w and h makes image stretch to size.                                                                 // 4748
		// this may distort the image, but fits your demanded size                                                           // 4749
		if (w && h) {                                                                                                        // 4750
			scale = [w / svgw, h / svgh]                                                                                        // 4751
		}                                                                                                                    // 4752
		// if only one is set, that value is set as max and SVG                                                              // 4753
		// is scaled proportionately.                                                                                        // 4754
		else if (w) {                                                                                                        // 4755
			scale = [w / svgw, w / svgw]                                                                                        // 4756
		} else if (h) {                                                                                                      // 4757
			scale = [h / svgh, h / svgh]                                                                                        // 4758
		}                                                                                                                    // 4759
	}                                                                                                                     // 4760
                                                                                                                       // 4761
	var i, l, tmp                                                                                                         // 4762
	, linesargs                                                                                                           // 4763
	, items = svgnode.childNodes                                                                                          // 4764
	for (i = 0, l = items.length; i < l; i++) {                                                                           // 4765
		tmp = items[i]                                                                                                       // 4766
		if (tmp.tagName && tmp.tagName.toUpperCase() === 'PATH') {                                                           // 4767
			linesargs = convertPathToPDFLinesArgs( tmp.getAttribute("d").split(' ') )                                           // 4768
			// path start x coordinate                                                                                          // 4769
			linesargs[0] = linesargs[0] * scale[0] + x // where x is upper left X of image                                      // 4770
			// path start y coordinate                                                                                          // 4771
			linesargs[1] = linesargs[1] * scale[1] + y // where y is upper left Y of image                                      // 4772
			// the rest of lines are vectors. these will adjust with scale value auto.                                          // 4773
			this.lines.call(                                                                                                    // 4774
				this                                                                                                               // 4775
				, linesargs[2] // lines                                                                                            // 4776
				, linesargs[0] // starting x                                                                                       // 4777
				, linesargs[1] // starting y                                                                                       // 4778
				, scale                                                                                                            // 4779
			)                                                                                                                   // 4780
		}                                                                                                                    // 4781
	}                                                                                                                     // 4782
                                                                                                                       // 4783
	// clean up                                                                                                           // 4784
	// workernode.parentNode.removeChild(workernode)                                                                      // 4785
                                                                                                                       // 4786
	return this                                                                                                           // 4787
}                                                                                                                      // 4788
                                                                                                                       // 4789
})(jsPDF.API);                                                                                                         // 4790
/** @preserve                                                                                                          // 4791
 * jsPDF split_text_to_size plugin - MIT license.                                                                      // 4792
 * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com                                                   // 4793
 *               2014 Diego Casorran, https://github.com/diegocr                                                       // 4794
 */                                                                                                                    // 4795
/**                                                                                                                    // 4796
 * Permission is hereby granted, free of charge, to any person obtaining                                               // 4797
 * a copy of this software and associated documentation files (the                                                     // 4798
 * "Software"), to deal in the Software without restriction, including                                                 // 4799
 * without limitation the rights to use, copy, modify, merge, publish,                                                 // 4800
 * distribute, sublicense, and/or sell copies of the Software, and to                                                  // 4801
 * permit persons to whom the Software is furnished to do so, subject to                                               // 4802
 * the following conditions:                                                                                           // 4803
 *                                                                                                                     // 4804
 * The above copyright notice and this permission notice shall be                                                      // 4805
 * included in all copies or substantial portions of the Software.                                                     // 4806
 *                                                                                                                     // 4807
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,                                                     // 4808
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                  // 4809
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                                                               // 4810
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE                                              // 4811
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION                                              // 4812
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION                                               // 4813
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                                     // 4814
 * ====================================================================                                                // 4815
 */                                                                                                                    // 4816
                                                                                                                       // 4817
;(function(API) {                                                                                                      // 4818
'use strict'                                                                                                           // 4819
                                                                                                                       // 4820
/**                                                                                                                    // 4821
Returns an array of length matching length of the 'word' string, with each                                             // 4822
cell ocupied by the width of the char in that position.                                                                // 4823
                                                                                                                       // 4824
@function                                                                                                              // 4825
@param word {String}                                                                                                   // 4826
@param widths {Object}                                                                                                 // 4827
@param kerning {Object}                                                                                                // 4828
@returns {Array}                                                                                                       // 4829
*/                                                                                                                     // 4830
var getCharWidthsArray = API.getCharWidthsArray = function(text, options){                                             // 4831
                                                                                                                       // 4832
	if (!options) {                                                                                                       // 4833
		options = {}                                                                                                         // 4834
	}                                                                                                                     // 4835
                                                                                                                       // 4836
	var widths = options.widths ? options.widths : this.internal.getFont().metadata.Unicode.widths                        // 4837
	, widthsFractionOf = widths.fof ? widths.fof : 1                                                                      // 4838
	, kerning = options.kerning ? options.kerning : this.internal.getFont().metadata.Unicode.kerning                      // 4839
	, kerningFractionOf = kerning.fof ? kerning.fof : 1                                                                   // 4840
                                                                                                                       // 4841
	// console.log("widths, kergnings", widths, kerning)                                                                  // 4842
                                                                                                                       // 4843
	var i, l                                                                                                              // 4844
	, char_code                                                                                                           // 4845
	, prior_char_code = 0 // for kerning                                                                                  // 4846
	, default_char_width = widths[0] || widthsFractionOf                                                                  // 4847
	, output = []                                                                                                         // 4848
                                                                                                                       // 4849
	for (i = 0, l = text.length; i < l; i++) {                                                                            // 4850
		char_code = text.charCodeAt(i)                                                                                       // 4851
		output.push(                                                                                                         // 4852
			( widths[char_code] || default_char_width ) / widthsFractionOf +                                                    // 4853
			( kerning[char_code] && kerning[char_code][prior_char_code] || 0 ) / kerningFractionOf                              // 4854
		)                                                                                                                    // 4855
		prior_char_code = char_code                                                                                          // 4856
	}                                                                                                                     // 4857
                                                                                                                       // 4858
	return output                                                                                                         // 4859
}                                                                                                                      // 4860
var getArraySum = function(array){                                                                                     // 4861
	var i = array.length                                                                                                  // 4862
	, output = 0                                                                                                          // 4863
	while(i){                                                                                                             // 4864
		;i--;                                                                                                                // 4865
		output += array[i]                                                                                                   // 4866
	}                                                                                                                     // 4867
	return output                                                                                                         // 4868
}                                                                                                                      // 4869
/**                                                                                                                    // 4870
Returns a widths of string in a given font, if the font size is set as 1 point.                                        // 4871
                                                                                                                       // 4872
In other words, this is "proportional" value. For 1 unit of font size, the length                                      // 4873
of the string will be that much.                                                                                       // 4874
                                                                                                                       // 4875
Multiply by font size to get actual width in *points*                                                                  // 4876
Then divide by 72 to get inches or divide by (72/25.6) to get 'mm' etc.                                                // 4877
                                                                                                                       // 4878
@public                                                                                                                // 4879
@function                                                                                                              // 4880
@param                                                                                                                 // 4881
@returns {Type}                                                                                                        // 4882
*/                                                                                                                     // 4883
var getStringUnitWidth = API.getStringUnitWidth = function(text, options) {                                            // 4884
	return getArraySum(getCharWidthsArray.call(this, text, options))                                                      // 4885
}                                                                                                                      // 4886
                                                                                                                       // 4887
/**                                                                                                                    // 4888
returns array of lines                                                                                                 // 4889
*/                                                                                                                     // 4890
var splitLongWord = function(word, widths_array, firstLineMaxLen, maxLen){                                             // 4891
	var answer = []                                                                                                       // 4892
                                                                                                                       // 4893
	// 1st, chop off the piece that can fit on the hanging line.                                                          // 4894
	var i = 0                                                                                                             // 4895
	, l = word.length                                                                                                     // 4896
	, workingLen = 0                                                                                                      // 4897
	while (i !== l && workingLen + widths_array[i] < firstLineMaxLen){                                                    // 4898
		workingLen += widths_array[i]                                                                                        // 4899
		;i++;                                                                                                                // 4900
	}                                                                                                                     // 4901
	// this is first line.                                                                                                // 4902
	answer.push(word.slice(0, i))                                                                                         // 4903
                                                                                                                       // 4904
	// 2nd. Split the rest into maxLen pieces.                                                                            // 4905
	var startOfLine = i                                                                                                   // 4906
	workingLen = 0                                                                                                        // 4907
	while (i !== l){                                                                                                      // 4908
		if (workingLen + widths_array[i] > maxLen) {                                                                         // 4909
			answer.push(word.slice(startOfLine, i))                                                                             // 4910
			workingLen = 0                                                                                                      // 4911
			startOfLine = i                                                                                                     // 4912
		}                                                                                                                    // 4913
		workingLen += widths_array[i]                                                                                        // 4914
		;i++;                                                                                                                // 4915
	}                                                                                                                     // 4916
	if (startOfLine !== i) {                                                                                              // 4917
		answer.push(word.slice(startOfLine, i))                                                                              // 4918
	}                                                                                                                     // 4919
                                                                                                                       // 4920
	return answer                                                                                                         // 4921
}                                                                                                                      // 4922
                                                                                                                       // 4923
// Note, all sizing inputs for this function must be in "font measurement units"                                       // 4924
// By default, for PDF, it's "point".                                                                                  // 4925
var splitParagraphIntoLines = function(text, maxlen, options){                                                         // 4926
	// at this time works only on Western scripts, ones with space char                                                   // 4927
	// separating the words. Feel free to expand.                                                                         // 4928
                                                                                                                       // 4929
	if (!options) {                                                                                                       // 4930
		options = {}                                                                                                         // 4931
	}                                                                                                                     // 4932
                                                                                                                       // 4933
	var line = []                                                                                                         // 4934
	, lines = [line]                                                                                                      // 4935
	, line_length = options.textIndent || 0                                                                               // 4936
	, separator_length = 0                                                                                                // 4937
	, current_word_length = 0                                                                                             // 4938
	, word                                                                                                                // 4939
	, widths_array                                                                                                        // 4940
	, words = text.split(' ')                                                                                             // 4941
	, spaceCharWidth = getCharWidthsArray(' ', options)[0]                                                                // 4942
	, i, l, tmp, lineIndent                                                                                               // 4943
                                                                                                                       // 4944
	if(options.lineIndent === -1) {                                                                                       // 4945
		lineIndent = words[0].length +2;                                                                                     // 4946
	} else {                                                                                                              // 4947
		lineIndent = options.lineIndent || 0;                                                                                // 4948
	}                                                                                                                     // 4949
	if(lineIndent) {                                                                                                      // 4950
		var pad = Array(lineIndent).join(" "), wrds = [];                                                                    // 4951
		words.map(function(wrd) {                                                                                            // 4952
			wrd = wrd.split(/\s*\n/);                                                                                           // 4953
			if(wrd.length > 1) {                                                                                                // 4954
				wrds = wrds.concat(wrd.map(function(wrd, idx) {                                                                    // 4955
					return (idx && wrd.length ? "\n":"") + wrd;                                                                       // 4956
				}));                                                                                                               // 4957
			} else {                                                                                                            // 4958
				wrds.push(wrd[0]);                                                                                                 // 4959
			}                                                                                                                   // 4960
		});                                                                                                                  // 4961
		words = wrds;                                                                                                        // 4962
		lineIndent = getStringUnitWidth(pad, options);                                                                       // 4963
	}                                                                                                                     // 4964
                                                                                                                       // 4965
	for (i = 0, l = words.length; i < l; i++) {                                                                           // 4966
		var force = 0;                                                                                                       // 4967
                                                                                                                       // 4968
		word = words[i]                                                                                                      // 4969
		if(lineIndent && word[0] == "\n") {                                                                                  // 4970
			word = word.substr(1);                                                                                              // 4971
			force = 1;                                                                                                          // 4972
		}                                                                                                                    // 4973
		widths_array = getCharWidthsArray(word, options)                                                                     // 4974
		current_word_length = getArraySum(widths_array)                                                                      // 4975
                                                                                                                       // 4976
		if (line_length + separator_length + current_word_length > maxlen || force) {                                        // 4977
			if (current_word_length > maxlen) {                                                                                 // 4978
				// this happens when you have space-less long URLs for example.                                                    // 4979
				// we just chop these to size. We do NOT insert hiphens                                                            // 4980
				tmp = splitLongWord(word, widths_array, maxlen - (line_length + separator_length), maxlen)                         // 4981
				// first line we add to existing line object                                                                       // 4982
				line.push(tmp.shift()) // it's ok to have extra space indicator there                                              // 4983
				// last line we make into new line object                                                                          // 4984
				line = [tmp.pop()]                                                                                                 // 4985
				// lines in the middle we apped to lines object as whole lines                                                     // 4986
				while(tmp.length){                                                                                                 // 4987
					lines.push([tmp.shift()]) // single fragment occupies whole line                                                  // 4988
				}                                                                                                                  // 4989
				current_word_length = getArraySum( widths_array.slice(word.length - line[0].length) )                              // 4990
			} else {                                                                                                            // 4991
				// just put it on a new line                                                                                       // 4992
				line = [word]                                                                                                      // 4993
			}                                                                                                                   // 4994
                                                                                                                       // 4995
			// now we attach new line to lines                                                                                  // 4996
			lines.push(line)                                                                                                    // 4997
			line_length = current_word_length + lineIndent                                                                      // 4998
			separator_length = spaceCharWidth                                                                                   // 4999
                                                                                                                       // 5000
		} else {                                                                                                             // 5001
			line.push(word)                                                                                                     // 5002
                                                                                                                       // 5003
			line_length += separator_length + current_word_length                                                               // 5004
			separator_length = spaceCharWidth                                                                                   // 5005
		}                                                                                                                    // 5006
	}                                                                                                                     // 5007
                                                                                                                       // 5008
	if(lineIndent) {                                                                                                      // 5009
		var postProcess = function(ln, idx) {                                                                                // 5010
			return (idx ? pad : '') + ln.join(" ");                                                                             // 5011
		};                                                                                                                   // 5012
	} else {                                                                                                              // 5013
		var postProcess = function(ln) { return ln.join(" ")};                                                               // 5014
	}                                                                                                                     // 5015
                                                                                                                       // 5016
	return lines.map(postProcess);                                                                                        // 5017
}                                                                                                                      // 5018
                                                                                                                       // 5019
/**                                                                                                                    // 5020
Splits a given string into an array of strings. Uses 'size' value                                                      // 5021
(in measurement units declared as default for the jsPDF instance)                                                      // 5022
and the font's "widths" and "Kerning" tables, where availabe, to                                                       // 5023
determine display length of a given string for a given font.                                                           // 5024
                                                                                                                       // 5025
We use character's 100% of unit size (height) as width when Width                                                      // 5026
table or other default width is not available.                                                                         // 5027
                                                                                                                       // 5028
@public                                                                                                                // 5029
@function                                                                                                              // 5030
@param text {String} Unencoded, regular JavaScript (Unicode, UTF-16 / UCS-2) string.                                   // 5031
@param size {Number} Nominal number, measured in units default to this instance of jsPDF.                              // 5032
@param options {Object} Optional flags needed for chopper to do the right thing.                                       // 5033
@returns {Array} with strings chopped to size.                                                                         // 5034
*/                                                                                                                     // 5035
API.splitTextToSize = function(text, maxlen, options) {                                                                // 5036
	'use strict'                                                                                                          // 5037
                                                                                                                       // 5038
	if (!options) {                                                                                                       // 5039
		options = {}                                                                                                         // 5040
	}                                                                                                                     // 5041
                                                                                                                       // 5042
	var fsize = options.fontSize || this.internal.getFontSize()                                                           // 5043
	, newOptions = (function(options){                                                                                    // 5044
		var widths = {0:1}                                                                                                   // 5045
		, kerning = {}                                                                                                       // 5046
                                                                                                                       // 5047
		if (!options.widths || !options.kerning) {                                                                           // 5048
			var f = this.internal.getFont(options.fontName, options.fontStyle)                                                  // 5049
			, encoding = 'Unicode'                                                                                              // 5050
			// NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE                                                                          // 5051
			// Actual JavaScript-native String's 16bit char codes used.                                                         // 5052
			// no multi-byte logic here                                                                                         // 5053
                                                                                                                       // 5054
			if (f.metadata[encoding]) {                                                                                         // 5055
				return {                                                                                                           // 5056
					widths: f.metadata[encoding].widths || widths                                                                     // 5057
					, kerning: f.metadata[encoding].kerning || kerning                                                                // 5058
				}                                                                                                                  // 5059
			}                                                                                                                   // 5060
		} else {                                                                                                             // 5061
			return 	{                                                                                                           // 5062
				widths: options.widths                                                                                             // 5063
				, kerning: options.kerning                                                                                         // 5064
			}                                                                                                                   // 5065
		}                                                                                                                    // 5066
                                                                                                                       // 5067
		// then use default values                                                                                           // 5068
		return 	{                                                                                                            // 5069
			widths: widths                                                                                                      // 5070
			, kerning: kerning                                                                                                  // 5071
		}                                                                                                                    // 5072
	}).call(this, options)                                                                                                // 5073
                                                                                                                       // 5074
	// first we split on end-of-line chars                                                                                // 5075
	var paragraphs                                                                                                        // 5076
	if(Array.isArray(text)) {                                                                                             // 5077
		paragraphs = text;                                                                                                   // 5078
	} else {                                                                                                              // 5079
		paragraphs = text.split(/\r?\n/);                                                                                    // 5080
	}                                                                                                                     // 5081
                                                                                                                       // 5082
	// now we convert size (max length of line) into "font size units"                                                    // 5083
	// at present time, the "font size unit" is always 'point'                                                            // 5084
	// 'proportional' means, "in proportion to font size"                                                                 // 5085
	var fontUnit_maxLen = 1.0 * this.internal.scaleFactor * maxlen / fsize                                                // 5086
	// at this time, fsize is always in "points" regardless of the default measurement unit of the doc.                   // 5087
	// this may change in the future?                                                                                     // 5088
	// until then, proportional_maxlen is likely to be in 'points'                                                        // 5089
                                                                                                                       // 5090
	// If first line is to be indented (shorter or longer) than maxLen                                                    // 5091
	// we indicate that by using CSS-style "text-indent" option.                                                          // 5092
	// here it's in font units too (which is likely 'points')                                                             // 5093
	// it can be negative (which makes the first line longer than maxLen)                                                 // 5094
	newOptions.textIndent = options.textIndent ?                                                                          // 5095
		options.textIndent * 1.0 * this.internal.scaleFactor / fsize :                                                       // 5096
		0                                                                                                                    // 5097
	newOptions.lineIndent = options.lineIndent;                                                                           // 5098
                                                                                                                       // 5099
	var i, l                                                                                                              // 5100
	, output = []                                                                                                         // 5101
	for (i = 0, l = paragraphs.length; i < l; i++) {                                                                      // 5102
		output = output.concat(                                                                                              // 5103
			splitParagraphIntoLines(                                                                                            // 5104
				paragraphs[i]                                                                                                      // 5105
				, fontUnit_maxLen                                                                                                  // 5106
				, newOptions                                                                                                       // 5107
			)                                                                                                                   // 5108
		)                                                                                                                    // 5109
	}                                                                                                                     // 5110
                                                                                                                       // 5111
	return output                                                                                                         // 5112
}                                                                                                                      // 5113
                                                                                                                       // 5114
})(jsPDF.API);                                                                                                         // 5115
/** @preserve                                                                                                          // 5116
jsPDF standard_fonts_metrics plugin                                                                                    // 5117
Copyright (c) 2012 Willow Systems Corporation, willow-systems.com                                                      // 5118
MIT license.                                                                                                           // 5119
*/                                                                                                                     // 5120
/**                                                                                                                    // 5121
 * Permission is hereby granted, free of charge, to any person obtaining                                               // 5122
 * a copy of this software and associated documentation files (the                                                     // 5123
 * "Software"), to deal in the Software without restriction, including                                                 // 5124
 * without limitation the rights to use, copy, modify, merge, publish,                                                 // 5125
 * distribute, sublicense, and/or sell copies of the Software, and to                                                  // 5126
 * permit persons to whom the Software is furnished to do so, subject to                                               // 5127
 * the following conditions:                                                                                           // 5128
 *                                                                                                                     // 5129
 * The above copyright notice and this permission notice shall be                                                      // 5130
 * included in all copies or substantial portions of the Software.                                                     // 5131
 *                                                                                                                     // 5132
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,                                                     // 5133
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                  // 5134
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                                                               // 5135
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE                                              // 5136
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION                                              // 5137
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION                                               // 5138
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                                     // 5139
 * ====================================================================                                                // 5140
 */                                                                                                                    // 5141
                                                                                                                       // 5142
;(function(API) {                                                                                                      // 5143
'use strict'                                                                                                           // 5144
                                                                                                                       // 5145
/*                                                                                                                     // 5146
# reference (Python) versions of 'compress' and 'uncompress'                                                           // 5147
# only 'uncompress' function is featured lower as JavaScript                                                           // 5148
# if you want to unit test "roundtrip", just transcribe the reference                                                  // 5149
# 'compress' function from Python into JavaScript                                                                      // 5150
                                                                                                                       // 5151
def compress(data):                                                                                                    // 5152
                                                                                                                       // 5153
	keys =   '0123456789abcdef'                                                                                           // 5154
	values = 'klmnopqrstuvwxyz'                                                                                           // 5155
	mapping = dict(zip(keys, values))                                                                                     // 5156
	vals = []                                                                                                             // 5157
	for key in data.keys():                                                                                               // 5158
		value = data[key]                                                                                                    // 5159
		try:                                                                                                                 // 5160
			keystring = hex(key)[2:]                                                                                            // 5161
			keystring = keystring[:-1] + mapping[keystring[-1:]]                                                                // 5162
		except:                                                                                                              // 5163
			keystring = key.join(["'","'"])                                                                                     // 5164
			#print('Keystring is %s' % keystring)                                                                               // 5165
                                                                                                                       // 5166
		try:                                                                                                                 // 5167
			if value < 0:                                                                                                       // 5168
				valuestring = hex(value)[3:]                                                                                       // 5169
				numberprefix = '-'                                                                                                 // 5170
			else:                                                                                                               // 5171
				valuestring = hex(value)[2:]                                                                                       // 5172
				numberprefix = ''                                                                                                  // 5173
			valuestring = numberprefix + valuestring[:-1] + mapping[valuestring[-1:]]                                           // 5174
		except:                                                                                                              // 5175
			if type(value) == dict:                                                                                             // 5176
				valuestring = compress(value)                                                                                      // 5177
			else:                                                                                                               // 5178
				raise Exception("Don't know what to do with value type %s" % type(value))                                          // 5179
                                                                                                                       // 5180
		vals.append(keystring+valuestring)                                                                                   // 5181
	                                                                                                                      // 5182
	return '{' + ''.join(vals) + '}'                                                                                      // 5183
                                                                                                                       // 5184
def uncompress(data):                                                                                                  // 5185
                                                                                                                       // 5186
	decoded = '0123456789abcdef'                                                                                          // 5187
	encoded = 'klmnopqrstuvwxyz'                                                                                          // 5188
	mapping = dict(zip(encoded, decoded))                                                                                 // 5189
                                                                                                                       // 5190
	sign = +1                                                                                                             // 5191
	stringmode = False                                                                                                    // 5192
	stringparts = []                                                                                                      // 5193
                                                                                                                       // 5194
	output = {}                                                                                                           // 5195
                                                                                                                       // 5196
	activeobject = output                                                                                                 // 5197
	parentchain = []                                                                                                      // 5198
                                                                                                                       // 5199
	keyparts = ''                                                                                                         // 5200
	valueparts = ''                                                                                                       // 5201
                                                                                                                       // 5202
	key = None                                                                                                            // 5203
                                                                                                                       // 5204
	ending = set(encoded)                                                                                                 // 5205
                                                                                                                       // 5206
	i = 1                                                                                                                 // 5207
	l = len(data) - 1 # stripping starting, ending {}                                                                     // 5208
	while i != l: # stripping {}                                                                                          // 5209
		# -, {, }, ' are special.                                                                                            // 5210
                                                                                                                       // 5211
		ch = data[i]                                                                                                         // 5212
		i += 1                                                                                                               // 5213
                                                                                                                       // 5214
		if ch == "'":                                                                                                        // 5215
			if stringmode:                                                                                                      // 5216
				# end of string mode                                                                                               // 5217
				stringmode = False                                                                                                 // 5218
				key = ''.join(stringparts)                                                                                         // 5219
			else:                                                                                                               // 5220
				# start of string mode                                                                                             // 5221
				stringmode = True                                                                                                  // 5222
				stringparts = []                                                                                                   // 5223
		elif stringmode == True:                                                                                             // 5224
			#print("Adding %s to stringpart" % ch)                                                                              // 5225
			stringparts.append(ch)                                                                                              // 5226
                                                                                                                       // 5227
		elif ch == '{':                                                                                                      // 5228
			# start of object                                                                                                   // 5229
			parentchain.append( [activeobject, key] )                                                                           // 5230
			activeobject = {}                                                                                                   // 5231
			key = None                                                                                                          // 5232
			#DEBUG = True                                                                                                       // 5233
		elif ch == '}':                                                                                                      // 5234
			# end of object                                                                                                     // 5235
			parent, key = parentchain.pop()                                                                                     // 5236
			parent[key] = activeobject                                                                                          // 5237
			key = None                                                                                                          // 5238
			activeobject = parent                                                                                               // 5239
			#DEBUG = False                                                                                                      // 5240
                                                                                                                       // 5241
		elif ch == '-':                                                                                                      // 5242
			sign = -1                                                                                                           // 5243
		else:                                                                                                                // 5244
			# must be number                                                                                                    // 5245
			if key == None:                                                                                                     // 5246
				#debug("In Key. It is '%s', ch is '%s'" % (keyparts, ch))                                                          // 5247
				if ch in ending:                                                                                                   // 5248
					#debug("End of key")                                                                                              // 5249
					keyparts += mapping[ch]                                                                                           // 5250
					key = int(keyparts, 16) * sign                                                                                    // 5251
					sign = +1                                                                                                         // 5252
					keyparts = ''                                                                                                     // 5253
				else:                                                                                                              // 5254
					keyparts += ch                                                                                                    // 5255
			else:                                                                                                               // 5256
				#debug("In value. It is '%s', ch is '%s'" % (valueparts, ch))                                                      // 5257
				if ch in ending:                                                                                                   // 5258
					#debug("End of value")                                                                                            // 5259
					valueparts += mapping[ch]                                                                                         // 5260
					activeobject[key] = int(valueparts, 16) * sign                                                                    // 5261
					sign = +1                                                                                                         // 5262
					key = None                                                                                                        // 5263
					valueparts = ''                                                                                                   // 5264
				else:                                                                                                              // 5265
					valueparts += ch                                                                                                  // 5266
                                                                                                                       // 5267
			#debug(activeobject)                                                                                                // 5268
                                                                                                                       // 5269
	return output                                                                                                         // 5270
                                                                                                                       // 5271
*/                                                                                                                     // 5272
                                                                                                                       // 5273
/**                                                                                                                    // 5274
Uncompresses data compressed into custom, base16-like format.                                                          // 5275
@public                                                                                                                // 5276
@function                                                                                                              // 5277
@param                                                                                                                 // 5278
@returns {Type}                                                                                                        // 5279
*/                                                                                                                     // 5280
var uncompress = function(data){                                                                                       // 5281
                                                                                                                       // 5282
	var decoded = '0123456789abcdef'                                                                                      // 5283
	, encoded = 'klmnopqrstuvwxyz'                                                                                        // 5284
	, mapping = {}                                                                                                        // 5285
                                                                                                                       // 5286
	for (var i = 0; i < encoded.length; i++){                                                                             // 5287
		mapping[encoded[i]] = decoded[i]                                                                                     // 5288
	}                                                                                                                     // 5289
                                                                                                                       // 5290
	var undef                                                                                                             // 5291
	, output = {}                                                                                                         // 5292
	, sign = 1                                                                                                            // 5293
	, stringparts // undef. will be [] in string mode                                                                     // 5294
	                                                                                                                      // 5295
	, activeobject = output                                                                                               // 5296
	, parentchain = []                                                                                                    // 5297
	, parent_key_pair                                                                                                     // 5298
	, keyparts = ''                                                                                                       // 5299
	, valueparts = ''                                                                                                     // 5300
	, key // undef. will be Truthy when Key is resolved.                                                                  // 5301
	, datalen = data.length - 1 // stripping ending }                                                                     // 5302
	, ch                                                                                                                  // 5303
                                                                                                                       // 5304
	i = 1 // stripping starting {                                                                                         // 5305
	                                                                                                                      // 5306
	while (i != datalen){                                                                                                 // 5307
		// - { } ' are special.                                                                                              // 5308
                                                                                                                       // 5309
		ch = data[i]                                                                                                         // 5310
		i += 1                                                                                                               // 5311
                                                                                                                       // 5312
		if (ch == "'"){                                                                                                      // 5313
			if (stringparts){                                                                                                   // 5314
				// end of string mode                                                                                              // 5315
				key = stringparts.join('')                                                                                         // 5316
				stringparts = undef				                                                                                            // 5317
			} else {                                                                                                            // 5318
				// start of string mode                                                                                            // 5319
				stringparts = []				                                                                                               // 5320
			}                                                                                                                   // 5321
		} else if (stringparts){                                                                                             // 5322
			stringparts.push(ch)                                                                                                // 5323
		} else if (ch == '{'){                                                                                               // 5324
			// start of object                                                                                                  // 5325
			parentchain.push( [activeobject, key] )                                                                             // 5326
			activeobject = {}                                                                                                   // 5327
			key = undef                                                                                                         // 5328
		} else if (ch == '}'){                                                                                               // 5329
			// end of object                                                                                                    // 5330
			parent_key_pair = parentchain.pop()                                                                                 // 5331
			parent_key_pair[0][parent_key_pair[1]] = activeobject                                                               // 5332
			key = undef                                                                                                         // 5333
			activeobject = parent_key_pair[0]                                                                                   // 5334
		} else if (ch == '-'){                                                                                               // 5335
			sign = -1                                                                                                           // 5336
		} else {                                                                                                             // 5337
			// must be number                                                                                                   // 5338
			if (key === undef) {                                                                                                // 5339
				if (mapping.hasOwnProperty(ch)){                                                                                   // 5340
					keyparts += mapping[ch]                                                                                           // 5341
					key = parseInt(keyparts, 16) * sign                                                                               // 5342
					sign = +1                                                                                                         // 5343
					keyparts = ''                                                                                                     // 5344
				} else {                                                                                                           // 5345
					keyparts += ch                                                                                                    // 5346
				}                                                                                                                  // 5347
			} else {                                                                                                            // 5348
				if (mapping.hasOwnProperty(ch)){                                                                                   // 5349
					valueparts += mapping[ch]                                                                                         // 5350
					activeobject[key] = parseInt(valueparts, 16) * sign                                                               // 5351
					sign = +1                                                                                                         // 5352
					key = undef                                                                                                       // 5353
					valueparts = ''                                                                                                   // 5354
				} else {                                                                                                           // 5355
					valueparts += ch					                                                                                             // 5356
				}                                                                                                                  // 5357
			}                                                                                                                   // 5358
		}                                                                                                                    // 5359
	} // end while                                                                                                        // 5360
                                                                                                                       // 5361
	return output                                                                                                         // 5362
}                                                                                                                      // 5363
                                                                                                                       // 5364
// encoding = 'Unicode'                                                                                                // 5365
// NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE. NO clever BOM behavior                                                     // 5366
// Actual 16bit char codes used.                                                                                       // 5367
// no multi-byte logic here                                                                                            // 5368
                                                                                                                       // 5369
// Unicode characters to WinAnsiEncoding:                                                                              // 5370
// {402: 131, 8211: 150, 8212: 151, 8216: 145, 8217: 146, 8218: 130, 8220: 147, 8221: 148, 8222: 132, 8224: 134, 8225: 135, 8226: 149, 8230: 133, 8364: 128, 8240:137, 8249: 139, 8250: 155, 710: 136, 8482: 153, 338: 140, 339: 156, 732: 152, 352: 138, 353: 154, 376: 159, 381: 142, 382: 158}
// as you can see, all Unicode chars are outside of 0-255 range. No char code conflicts.                               // 5372
// this means that you can give Win cp1252 encoded strings to jsPDF for rendering directly                             // 5373
// as well as give strings with some (supported by these fonts) Unicode characters and                                 // 5374
// these will be mapped to win cp1252                                                                                  // 5375
// for example, you can send char code (cp1252) 0x80 or (unicode) 0x20AC, getting "Euro" glyph displayed in both cases.
                                                                                                                       // 5377
var encodingBlock = {                                                                                                  // 5378
	'codePages': ['WinAnsiEncoding']                                                                                      // 5379
	, 'WinAnsiEncoding': uncompress("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
}                                                                                                                      // 5381
, encodings = {'Unicode':{                                                                                             // 5382
	'Courier': encodingBlock                                                                                              // 5383
	, 'Courier-Bold': encodingBlock                                                                                       // 5384
	, 'Courier-BoldOblique': encodingBlock                                                                                // 5385
	, 'Courier-Oblique': encodingBlock                                                                                    // 5386
	, 'Helvetica': encodingBlock                                                                                          // 5387
	, 'Helvetica-Bold': encodingBlock                                                                                     // 5388
	, 'Helvetica-BoldOblique': encodingBlock                                                                              // 5389
	, 'Helvetica-Oblique': encodingBlock                                                                                  // 5390
	, 'Times-Roman': encodingBlock                                                                                        // 5391
	, 'Times-Bold': encodingBlock                                                                                         // 5392
	, 'Times-BoldItalic': encodingBlock                                                                                   // 5393
	, 'Times-Italic': encodingBlock                                                                                       // 5394
//	, 'Symbol'                                                                                                          // 5395
//	, 'ZapfDingbats'                                                                                                    // 5396
}}                                                                                                                     // 5397
/**                                                                                                                    // 5398
Resources:                                                                                                             // 5399
Font metrics data is reprocessed derivative of contents of                                                             // 5400
"Font Metrics for PDF Core 14 Fonts" package, which exhibits the following copyright and license:                      // 5401
                                                                                                                       // 5402
Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated. All Rights Reserved.                      // 5403
                                                                                                                       // 5404
This file and the 14 PostScript(R) AFM files it accompanies may be used,                                               // 5405
copied, and distributed for any purpose and without charge, with or without                                            // 5406
modification, provided that all copyright notices are retained; that the AFM                                           // 5407
files are not distributed without this file; that all modifications to this                                            // 5408
file or any of the AFM files are prominently noted in the modified file(s);                                            // 5409
and that this paragraph is not modified. Adobe Systems has no responsibility                                           // 5410
or obligation to support the use of the AFM files.                                                                     // 5411
                                                                                                                       // 5412
*/                                                                                                                     // 5413
, fontMetrics = {'Unicode':{                                                                                           // 5414
	// all sizing numbers are n/fontMetricsFractionOf = one font size unit                                                // 5415
	// this means that if fontMetricsFractionOf = 1000, and letter A's width is 476, it's                                 // 5416
	// width is 476/1000 or 47.6% of its height (regardless of font size)                                                 // 5417
	// At this time this value applies to "widths" and "kerning" numbers.                                                 // 5418
                                                                                                                       // 5419
	// char code 0 represents "default" (average) width - use it for chars missing in this table.                         // 5420
	// key 'fof' represents the "fontMetricsFractionOf" value                                                             // 5421
                                                                                                                       // 5422
	'Courier-Oblique': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")                                            // 5423
	, 'Times-BoldItalic': uncompress("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}")
	, 'Helvetica-Bold': uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}")
	, 'Courier': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")                                                  // 5426
	, 'Courier-BoldOblique': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")                                      // 5427
	, 'Times-Bold': uncompress("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}")
	//, 'Symbol': uncompress("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}")
	, 'Helvetica': uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
	, 'Helvetica-BoldOblique': uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}")
	//, 'ZapfDingbats': uncompress("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}")                                       // 5432
	, 'Courier-Bold': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")                                             // 5433
	, 'Times-Italic': uncompress("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}")
	, 'Times-Roman': uncompress("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}")
	, 'Helvetica-Oblique': uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
}};                                                                                                                    // 5437
                                                                                                                       // 5438
/*                                                                                                                     // 5439
This event handler is fired when a new jsPDF object is initialized                                                     // 5440
This event handler appends metrics data to standard fonts within                                                       // 5441
that jsPDF instance. The metrics are mapped over Unicode character                                                     // 5442
codes, NOT CIDs or other codes matching the StandardEncoding table of the                                              // 5443
standard PDF fonts.                                                                                                    // 5444
Future:                                                                                                                // 5445
Also included is the encoding maping table, converting Unicode (UCS-2, UTF-16)                                         // 5446
char codes to StandardEncoding character codes. The encoding table is to be used                                       // 5447
somewhere around "pdfEscape" call.                                                                                     // 5448
*/                                                                                                                     // 5449
                                                                                                                       // 5450
API.events.push([                                                                                                      // 5451
	'addFonts'                                                                                                            // 5452
	,function(fontManagementObjects) {                                                                                    // 5453
		// fontManagementObjects is {                                                                                        // 5454
		//	'fonts':font_ID-keyed hash of font objects                                                                        // 5455
		//	, 'dictionary': lookup object, linking ["FontFamily"]['Style'] to font ID                                         // 5456
		//}                                                                                                                  // 5457
		var font                                                                                                             // 5458
		, fontID                                                                                                             // 5459
		, metrics                                                                                                            // 5460
		, unicode_section                                                                                                    // 5461
		, encoding = 'Unicode'                                                                                               // 5462
		, encodingBlock                                                                                                      // 5463
                                                                                                                       // 5464
		for (fontID in fontManagementObjects.fonts){                                                                         // 5465
			if (fontManagementObjects.fonts.hasOwnProperty(fontID)) {                                                           // 5466
				font = fontManagementObjects.fonts[fontID]                                                                         // 5467
                                                                                                                       // 5468
				// // we only ship 'Unicode' mappings and metrics. No need for loop.                                               // 5469
				// // still, leaving this for the future.                                                                          // 5470
                                                                                                                       // 5471
				// for (encoding in fontMetrics){                                                                                  // 5472
				// 	if (fontMetrics.hasOwnProperty(encoding)) {                                                                    // 5473
                                                                                                                       // 5474
						metrics = fontMetrics[encoding][font.PostScriptName]                                                             // 5475
						if (metrics) {                                                                                                   // 5476
							if (font.metadata[encoding]) {                                                                                  // 5477
								unicode_section = font.metadata[encoding]                                                                      // 5478
							} else {                                                                                                        // 5479
								unicode_section = font.metadata[encoding] = {}                                                                 // 5480
							}                                                                                                               // 5481
                                                                                                                       // 5482
							unicode_section.widths = metrics.widths                                                                         // 5483
							unicode_section.kerning = metrics.kerning                                                                       // 5484
						}                                                                                                                // 5485
				// 	}                                                                                                              // 5486
				// }                                                                                                               // 5487
				// for (encoding in encodings){                                                                                    // 5488
				// 	if (encodings.hasOwnProperty(encoding)) {                                                                      // 5489
						encodingBlock = encodings[encoding][font.PostScriptName]                                                         // 5490
						if (encodingBlock) {                                                                                             // 5491
							if (font.metadata[encoding]) {                                                                                  // 5492
								unicode_section = font.metadata[encoding]                                                                      // 5493
							} else {                                                                                                        // 5494
								unicode_section = font.metadata[encoding] = {}                                                                 // 5495
							}                                                                                                               // 5496
                                                                                                                       // 5497
							unicode_section.encoding = encodingBlock                                                                        // 5498
							if (encodingBlock.codePages && encodingBlock.codePages.length) {                                                // 5499
								font.encoding = encodingBlock.codePages[0]                                                                     // 5500
							}                                                                                                               // 5501
						}                                                                                                                // 5502
				// 	}                                                                                                              // 5503
				// }                                                                                                               // 5504
			}                                                                                                                   // 5505
		}                                                                                                                    // 5506
	}                                                                                                                     // 5507
]) // end of adding event handler                                                                                      // 5508
                                                                                                                       // 5509
})(jsPDF.API);                                                                                                         // 5510
/** ====================================================================                                               // 5511
 * jsPDF total_pages plugin                                                                                            // 5512
 * Copyright (c) 2013 Eduardo Menezes de Morais, eduardo.morais@usp.br                                                 // 5513
 *                                                                                                                     // 5514
 * Permission is hereby granted, free of charge, to any person obtaining                                               // 5515
 * a copy of this software and associated documentation files (the                                                     // 5516
 * "Software"), to deal in the Software without restriction, including                                                 // 5517
 * without limitation the rights to use, copy, modify, merge, publish,                                                 // 5518
 * distribute, sublicense, and/or sell copies of the Software, and to                                                  // 5519
 * permit persons to whom the Software is furnished to do so, subject to                                               // 5520
 * the following conditions:                                                                                           // 5521
 *                                                                                                                     // 5522
 * The above copyright notice and this permission notice shall be                                                      // 5523
 * included in all copies or substantial portions of the Software.                                                     // 5524
 *                                                                                                                     // 5525
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,                                                     // 5526
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                  // 5527
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                                                               // 5528
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE                                              // 5529
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION                                              // 5530
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION                                               // 5531
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                                     // 5532
 * ====================================================================                                                // 5533
 */                                                                                                                    // 5534
                                                                                                                       // 5535
(function(jsPDFAPI) {                                                                                                  // 5536
'use strict';                                                                                                          // 5537
                                                                                                                       // 5538
jsPDFAPI.putTotalPages = function(pageExpression) {                                                                    // 5539
	'use strict';                                                                                                         // 5540
        var replaceExpression = new RegExp(pageExpression, 'g');                                                       // 5541
        for (var n = 1; n <= this.internal.getNumberOfPages(); n++) {                                                  // 5542
            for (var i = 0; i < this.internal.pages[n].length; i++)                                                    // 5543
               this.internal.pages[n][i] = this.internal.pages[n][i].replace(replaceExpression, this.internal.getNumberOfPages());
        }                                                                                                              // 5545
	return this;                                                                                                          // 5546
};                                                                                                                     // 5547
                                                                                                                       // 5548
})(jsPDF.API);                                                                                                         // 5549
/* Blob.js                                                                                                             // 5550
 * A Blob implementation.                                                                                              // 5551
 * 2014-07-24                                                                                                          // 5552
 *                                                                                                                     // 5553
 * By Eli Grey, http://eligrey.com                                                                                     // 5554
 * By Devin Samarin, https://github.com/dsamarin                                                                       // 5555
 * License: X11/MIT                                                                                                    // 5556
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md                                                     // 5557
 */                                                                                                                    // 5558
                                                                                                                       // 5559
/*global self, unescape */                                                                                             // 5560
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,                             // 5561
  plusplus: true */                                                                                                    // 5562
                                                                                                                       // 5563
/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */                                              // 5564
                                                                                                                       // 5565
(function (view) {                                                                                                     // 5566
	"use strict";                                                                                                         // 5567
                                                                                                                       // 5568
	view.URL = view.URL || view.webkitURL;                                                                                // 5569
                                                                                                                       // 5570
	if (view.Blob && view.URL) {                                                                                          // 5571
		try {                                                                                                                // 5572
			new Blob;                                                                                                           // 5573
			return;                                                                                                             // 5574
		} catch (e) {}                                                                                                       // 5575
	}                                                                                                                     // 5576
                                                                                                                       // 5577
	// Internally we use a BlobBuilder implementation to base Blob off of                                                 // 5578
	// in order to support older browsers that only have BlobBuilder                                                      // 5579
	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {              // 5580
		var                                                                                                                  // 5581
			  get_class = function(object) {                                                                                    // 5582
				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];                                      // 5583
			}                                                                                                                   // 5584
			, FakeBlobBuilder = function BlobBuilder() {                                                                        // 5585
				this.data = [];                                                                                                    // 5586
			}                                                                                                                   // 5587
			, FakeBlob = function Blob(data, type, encoding) {                                                                  // 5588
				this.data = data;                                                                                                  // 5589
				this.size = data.length;                                                                                           // 5590
				this.type = type;                                                                                                  // 5591
				this.encoding = encoding;                                                                                          // 5592
			}                                                                                                                   // 5593
			, FBB_proto = FakeBlobBuilder.prototype                                                                             // 5594
			, FB_proto = FakeBlob.prototype                                                                                     // 5595
			, FileReaderSync = view.FileReaderSync                                                                              // 5596
			, FileException = function(type) {                                                                                  // 5597
				this.code = this[this.name = type];                                                                                // 5598
			}                                                                                                                   // 5599
			, file_ex_codes = (                                                                                                 // 5600
				  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "                                            // 5601
				+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"                                                       // 5602
			).split(" ")                                                                                                        // 5603
			, file_ex_code = file_ex_codes.length                                                                               // 5604
			, real_URL = view.URL || view.webkitURL || view                                                                     // 5605
			, real_create_object_URL = real_URL.createObjectURL                                                                 // 5606
			, real_revoke_object_URL = real_URL.revokeObjectURL                                                                 // 5607
			, URL = real_URL                                                                                                    // 5608
			, btoa = view.btoa                                                                                                  // 5609
			, atob = view.atob                                                                                                  // 5610
                                                                                                                       // 5611
			, ArrayBuffer = view.ArrayBuffer                                                                                    // 5612
			, Uint8Array = view.Uint8Array                                                                                      // 5613
                                                                                                                       // 5614
			, origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/                                                                 // 5615
		;                                                                                                                    // 5616
		FakeBlob.fake = FB_proto.fake = true;                                                                                // 5617
		while (file_ex_code--) {                                                                                             // 5618
			FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;                                            // 5619
		}                                                                                                                    // 5620
		// Polyfill URL                                                                                                      // 5621
		if (!real_URL.createObjectURL) {                                                                                     // 5622
			URL = view.URL = function(uri) {                                                                                    // 5623
				var                                                                                                                // 5624
					  uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a")                                        // 5625
					, uri_origin                                                                                                      // 5626
				;                                                                                                                  // 5627
				uri_info.href = uri;                                                                                               // 5628
				if (!("origin" in uri_info)) {                                                                                     // 5629
					if (uri_info.protocol.toLowerCase() === "data:") {                                                                // 5630
						uri_info.origin = null;                                                                                          // 5631
					} else {                                                                                                          // 5632
						uri_origin = uri.match(origin);                                                                                  // 5633
						uri_info.origin = uri_origin && uri_origin[1];                                                                   // 5634
					}                                                                                                                 // 5635
				}                                                                                                                  // 5636
				return uri_info;                                                                                                   // 5637
			};                                                                                                                  // 5638
		}                                                                                                                    // 5639
		URL.createObjectURL = function(blob) {                                                                               // 5640
			var                                                                                                                 // 5641
				  type = blob.type                                                                                                 // 5642
				, data_URI_header                                                                                                  // 5643
			;                                                                                                                   // 5644
			if (type === null) {                                                                                                // 5645
				type = "application/octet-stream";                                                                                 // 5646
			}                                                                                                                   // 5647
			if (blob instanceof FakeBlob) {                                                                                     // 5648
				data_URI_header = "data:" + type;                                                                                  // 5649
				if (blob.encoding === "base64") {                                                                                  // 5650
					return data_URI_header + ";base64," + blob.data;                                                                  // 5651
				} else if (blob.encoding === "URI") {                                                                              // 5652
					return data_URI_header + "," + decodeURIComponent(blob.data);                                                     // 5653
				} if (btoa) {                                                                                                      // 5654
					return data_URI_header + ";base64," + btoa(blob.data);                                                            // 5655
				} else {                                                                                                           // 5656
					return data_URI_header + "," + encodeURIComponent(blob.data);                                                     // 5657
				}                                                                                                                  // 5658
			} else if (real_create_object_URL) {                                                                                // 5659
				return real_create_object_URL.call(real_URL, blob);                                                                // 5660
			}                                                                                                                   // 5661
		};                                                                                                                   // 5662
		URL.revokeObjectURL = function(object_URL) {                                                                         // 5663
			if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {                                             // 5664
				real_revoke_object_URL.call(real_URL, object_URL);                                                                 // 5665
			}                                                                                                                   // 5666
		};                                                                                                                   // 5667
		FBB_proto.append = function(data/*, endings*/) {                                                                     // 5668
			var bb = this.data;                                                                                                 // 5669
			// decode data to a binary string                                                                                   // 5670
			if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {                                    // 5671
				var                                                                                                                // 5672
					  str = ""                                                                                                        // 5673
					, buf = new Uint8Array(data)                                                                                      // 5674
					, i = 0                                                                                                           // 5675
					, buf_len = buf.length                                                                                            // 5676
				;                                                                                                                  // 5677
				for (; i < buf_len; i++) {                                                                                         // 5678
					str += String.fromCharCode(buf[i]);                                                                               // 5679
				}                                                                                                                  // 5680
				bb.push(str);                                                                                                      // 5681
			} else if (get_class(data) === "Blob" || get_class(data) === "File") {                                              // 5682
				if (FileReaderSync) {                                                                                              // 5683
					var fr = new FileReaderSync;                                                                                      // 5684
					bb.push(fr.readAsBinaryString(data));                                                                             // 5685
				} else {                                                                                                           // 5686
					// async FileReader won't work as BlobBuilder is sync                                                             // 5687
					throw new FileException("NOT_READABLE_ERR");                                                                      // 5688
				}                                                                                                                  // 5689
			} else if (data instanceof FakeBlob) {                                                                              // 5690
				if (data.encoding === "base64" && atob) {                                                                          // 5691
					bb.push(atob(data.data));                                                                                         // 5692
				} else if (data.encoding === "URI") {                                                                              // 5693
					bb.push(decodeURIComponent(data.data));                                                                           // 5694
				} else if (data.encoding === "raw") {                                                                              // 5695
					bb.push(data.data);                                                                                               // 5696
				}                                                                                                                  // 5697
			} else {                                                                                                            // 5698
				if (typeof data !== "string") {                                                                                    // 5699
					data += ""; // convert unsupported types to strings                                                               // 5700
				}                                                                                                                  // 5701
				// decode UTF-16 to binary string                                                                                  // 5702
				bb.push(unescape(encodeURIComponent(data)));                                                                       // 5703
			}                                                                                                                   // 5704
		};                                                                                                                   // 5705
		FBB_proto.getBlob = function(type) {                                                                                 // 5706
			if (!arguments.length) {                                                                                            // 5707
				type = null;                                                                                                       // 5708
			}                                                                                                                   // 5709
			return new FakeBlob(this.data.join(""), type, "raw");                                                               // 5710
		};                                                                                                                   // 5711
		FBB_proto.toString = function() {                                                                                    // 5712
			return "[object BlobBuilder]";                                                                                      // 5713
		};                                                                                                                   // 5714
		FB_proto.slice = function(start, end, type) {                                                                        // 5715
			var args = arguments.length;                                                                                        // 5716
			if (args < 3) {                                                                                                     // 5717
				type = null;                                                                                                       // 5718
			}                                                                                                                   // 5719
			return new FakeBlob(                                                                                                // 5720
				  this.data.slice(start, args > 1 ? end : this.data.length)                                                        // 5721
				, type                                                                                                             // 5722
				, this.encoding                                                                                                    // 5723
			);                                                                                                                  // 5724
		};                                                                                                                   // 5725
		FB_proto.toString = function() {                                                                                     // 5726
			return "[object Blob]";                                                                                             // 5727
		};                                                                                                                   // 5728
		FB_proto.close = function() {                                                                                        // 5729
			this.size = 0;                                                                                                      // 5730
			delete this.data;                                                                                                   // 5731
		};                                                                                                                   // 5732
		return FakeBlobBuilder;                                                                                              // 5733
	}(view));                                                                                                             // 5734
                                                                                                                       // 5735
	view.Blob = function(blobParts, options) {                                                                            // 5736
		var type = options ? (options.type || "") : "";                                                                      // 5737
		var builder = new BlobBuilder();                                                                                     // 5738
		if (blobParts) {                                                                                                     // 5739
			for (var i = 0, len = blobParts.length; i < len; i++) {                                                             // 5740
				builder.append(blobParts[i]);                                                                                      // 5741
			}                                                                                                                   // 5742
		}                                                                                                                    // 5743
		return builder.getBlob(type);                                                                                        // 5744
	};                                                                                                                    // 5745
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));            // 5746
/* FileSaver.js                                                                                                        // 5747
 * A saveAs() FileSaver implementation.                                                                                // 5748
 * 2014-08-29                                                                                                          // 5749
 *                                                                                                                     // 5750
 * By Eli Grey, http://eligrey.com                                                                                     // 5751
 * License: X11/MIT                                                                                                    // 5752
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md                                                // 5753
 */                                                                                                                    // 5754
                                                                                                                       // 5755
/*global self */                                                                                                       // 5756
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */                  // 5757
                                                                                                                       // 5758
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */                                    // 5759
                                                                                                                       // 5760
var saveAs = saveAs                                                                                                    // 5761
  // IE 10+ (native saveAs)                                                                                            // 5762
  || (typeof navigator !== "undefined" &&                                                                              // 5763
      navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))                                        // 5764
  // Everyone else                                                                                                     // 5765
  || (function(view) {                                                                                                 // 5766
	"use strict";                                                                                                         // 5767
	// IE <10 is explicitly unsupported                                                                                   // 5768
	if (typeof navigator !== "undefined" &&                                                                               // 5769
	    /MSIE [1-9]\./.test(navigator.userAgent)) {                                                                       // 5770
		return;                                                                                                              // 5771
	}                                                                                                                     // 5772
	var                                                                                                                   // 5773
		  doc = view.document                                                                                                // 5774
		  // only get URL when necessary in case Blob.js hasn't overridden it yet                                            // 5775
		, get_URL = function() {                                                                                             // 5776
			return view.URL || view.webkitURL || view;                                                                          // 5777
		}                                                                                                                    // 5778
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")                                               // 5779
		, can_use_save_link = "download" in save_link                                                                        // 5780
		, click = function(node) {                                                                                           // 5781
			var event = doc.createEvent("MouseEvents");                                                                         // 5782
			event.initMouseEvent(                                                                                               // 5783
				"click", true, false, view, 0, 0, 0, 0, 0                                                                          // 5784
				, false, false, false, false, 0, null                                                                              // 5785
			);                                                                                                                  // 5786
			node.dispatchEvent(event);                                                                                          // 5787
		}                                                                                                                    // 5788
		, webkit_req_fs = view.webkitRequestFileSystem                                                                       // 5789
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem                                      // 5790
		, throw_outside = function(ex) {                                                                                     // 5791
			(view.setImmediate || view.setTimeout)(function() {                                                                 // 5792
				throw ex;                                                                                                          // 5793
			}, 0);                                                                                                              // 5794
		}                                                                                                                    // 5795
		, force_saveable_type = "application/octet-stream"                                                                   // 5796
		, fs_min_size = 0                                                                                                    // 5797
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 for                                             // 5798
		// the reasoning behind the timeout and revocation flow                                                              // 5799
		, arbitrary_revoke_timeout = 10                                                                                      // 5800
		, revoke = function(file) {                                                                                          // 5801
			var revoker = function() {                                                                                          // 5802
				if (typeof file === "string") { // file is an object URL                                                           // 5803
					get_URL().revokeObjectURL(file);                                                                                  // 5804
				} else { // file is a File                                                                                         // 5805
					file.remove();                                                                                                    // 5806
				}                                                                                                                  // 5807
			};                                                                                                                  // 5808
			if (view.chrome) {                                                                                                  // 5809
				revoker();                                                                                                         // 5810
			} else {                                                                                                            // 5811
				setTimeout(revoker, arbitrary_revoke_timeout);                                                                     // 5812
			}                                                                                                                   // 5813
		}                                                                                                                    // 5814
		, dispatch = function(filesaver, event_types, event) {                                                               // 5815
			event_types = [].concat(event_types);                                                                               // 5816
			var i = event_types.length;                                                                                         // 5817
			while (i--) {                                                                                                       // 5818
				var listener = filesaver["on" + event_types[i]];                                                                   // 5819
				if (typeof listener === "function") {                                                                              // 5820
					try {                                                                                                             // 5821
						listener.call(filesaver, event || filesaver);                                                                    // 5822
					} catch (ex) {                                                                                                    // 5823
						throw_outside(ex);                                                                                               // 5824
					}                                                                                                                 // 5825
				}                                                                                                                  // 5826
			}                                                                                                                   // 5827
		}                                                                                                                    // 5828
		, FileSaver = function(blob, name) {                                                                                 // 5829
			// First try a.download, then web filesystem, then object URLs                                                      // 5830
			var                                                                                                                 // 5831
				  filesaver = this                                                                                                 // 5832
				, type = blob.type                                                                                                 // 5833
				, blob_changed = false                                                                                             // 5834
				, object_url                                                                                                       // 5835
				, target_view                                                                                                      // 5836
				, dispatch_all = function() {                                                                                      // 5837
					dispatch(filesaver, "writestart progress write writeend".split(" "));                                             // 5838
				}                                                                                                                  // 5839
				// on any filesys errors revert to saving with object URLs                                                         // 5840
				, fs_error = function() {                                                                                          // 5841
					// don't create more object URLs than needed                                                                      // 5842
					if (blob_changed || !object_url) {                                                                                // 5843
						object_url = get_URL().createObjectURL(blob);                                                                    // 5844
					}                                                                                                                 // 5845
					if (target_view) {                                                                                                // 5846
						target_view.location.href = object_url;                                                                          // 5847
					} else {                                                                                                          // 5848
						var new_tab = view.open(object_url, "_blank");                                                                   // 5849
						if (new_tab == undefined && typeof safari !== "undefined") {                                                     // 5850
							//Apple do not allow window.open, see http://bit.ly/1kZffRI                                                     // 5851
							view.location.href = object_url                                                                                 // 5852
						}                                                                                                                // 5853
					}                                                                                                                 // 5854
					filesaver.readyState = filesaver.DONE;                                                                            // 5855
					dispatch_all();                                                                                                   // 5856
					revoke(object_url);                                                                                               // 5857
				}                                                                                                                  // 5858
				, abortable = function(func) {                                                                                     // 5859
					return function() {                                                                                               // 5860
						if (filesaver.readyState !== filesaver.DONE) {                                                                   // 5861
							return func.apply(this, arguments);                                                                             // 5862
						}                                                                                                                // 5863
					};                                                                                                                // 5864
				}                                                                                                                  // 5865
				, create_if_not_found = {create: true, exclusive: false}                                                           // 5866
				, slice                                                                                                            // 5867
			;                                                                                                                   // 5868
			filesaver.readyState = filesaver.INIT;                                                                              // 5869
			if (!name) {                                                                                                        // 5870
				name = "download";                                                                                                 // 5871
			}                                                                                                                   // 5872
			if (can_use_save_link) {                                                                                            // 5873
				object_url = get_URL().createObjectURL(blob);                                                                      // 5874
				save_link.href = object_url;                                                                                       // 5875
				save_link.download = name;                                                                                         // 5876
				click(save_link);                                                                                                  // 5877
				filesaver.readyState = filesaver.DONE;                                                                             // 5878
				dispatch_all();                                                                                                    // 5879
				revoke(object_url);                                                                                                // 5880
				return;                                                                                                            // 5881
			}                                                                                                                   // 5882
			// Object and web filesystem URLs have a problem saving in Google Chrome when                                       // 5883
			// viewed in a tab, so I force save with application/octet-stream                                                   // 5884
			// http://code.google.com/p/chromium/issues/detail?id=91158                                                         // 5885
			// Update: Google errantly closed 91158, I submitted it again:                                                      // 5886
			// https://code.google.com/p/chromium/issues/detail?id=389642                                                       // 5887
			if (view.chrome && type && type !== force_saveable_type) {                                                          // 5888
				slice = blob.slice || blob.webkitSlice;                                                                            // 5889
				blob = slice.call(blob, 0, blob.size, force_saveable_type);                                                        // 5890
				blob_changed = true;                                                                                               // 5891
			}                                                                                                                   // 5892
			// Since I can't be sure that the guessed media type will trigger a download                                        // 5893
			// in WebKit, I append .download to the filename.                                                                   // 5894
			// https://bugs.webkit.org/show_bug.cgi?id=65440                                                                    // 5895
			if (webkit_req_fs && name !== "download") {                                                                         // 5896
				name += ".download";                                                                                               // 5897
			}                                                                                                                   // 5898
			if (type === force_saveable_type || webkit_req_fs) {                                                                // 5899
				target_view = view;                                                                                                // 5900
			}                                                                                                                   // 5901
			if (!req_fs) {                                                                                                      // 5902
				fs_error();                                                                                                        // 5903
				return;                                                                                                            // 5904
			}                                                                                                                   // 5905
			fs_min_size += blob.size;                                                                                           // 5906
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {                                                        // 5907
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {                                       // 5908
					var save = function() {                                                                                           // 5909
						dir.getFile(name, create_if_not_found, abortable(function(file) {                                                // 5910
							file.createWriter(abortable(function(writer) {                                                                  // 5911
								writer.onwriteend = function(event) {                                                                          // 5912
									target_view.location.href = file.toURL();                                                                     // 5913
									filesaver.readyState = filesaver.DONE;                                                                        // 5914
									dispatch(filesaver, "writeend", event);                                                                       // 5915
									revoke(file);                                                                                                 // 5916
								};                                                                                                             // 5917
								writer.onerror = function() {                                                                                  // 5918
									var error = writer.error;                                                                                     // 5919
									if (error.code !== error.ABORT_ERR) {                                                                         // 5920
										fs_error();                                                                                                  // 5921
									}                                                                                                             // 5922
								};                                                                                                             // 5923
								"writestart progress write abort".split(" ").forEach(function(event) {                                         // 5924
									writer["on" + event] = filesaver["on" + event];                                                               // 5925
								});                                                                                                            // 5926
								writer.write(blob);                                                                                            // 5927
								filesaver.abort = function() {                                                                                 // 5928
									writer.abort();                                                                                               // 5929
									filesaver.readyState = filesaver.DONE;                                                                        // 5930
								};                                                                                                             // 5931
								filesaver.readyState = filesaver.WRITING;                                                                      // 5932
							}), fs_error);                                                                                                  // 5933
						}), fs_error);                                                                                                   // 5934
					};                                                                                                                // 5935
					dir.getFile(name, {create: false}, abortable(function(file) {                                                     // 5936
						// delete file if it already exists                                                                              // 5937
						file.remove();                                                                                                   // 5938
						save();                                                                                                          // 5939
					}), abortable(function(ex) {                                                                                      // 5940
						if (ex.code === ex.NOT_FOUND_ERR) {                                                                              // 5941
							save();                                                                                                         // 5942
						} else {                                                                                                         // 5943
							fs_error();                                                                                                     // 5944
						}                                                                                                                // 5945
					}));                                                                                                              // 5946
				}), fs_error);                                                                                                     // 5947
			}), fs_error);                                                                                                      // 5948
		}                                                                                                                    // 5949
		, FS_proto = FileSaver.prototype                                                                                     // 5950
		, saveAs = function(blob, name) {                                                                                    // 5951
			return new FileSaver(blob, name);                                                                                   // 5952
		}                                                                                                                    // 5953
	;                                                                                                                     // 5954
	FS_proto.abort = function() {                                                                                         // 5955
		var filesaver = this;                                                                                                // 5956
		filesaver.readyState = filesaver.DONE;                                                                               // 5957
		dispatch(filesaver, "abort");                                                                                        // 5958
	};                                                                                                                    // 5959
	FS_proto.readyState = FS_proto.INIT = 0;                                                                              // 5960
	FS_proto.WRITING = 1;                                                                                                 // 5961
	FS_proto.DONE = 2;                                                                                                    // 5962
                                                                                                                       // 5963
	FS_proto.error =                                                                                                      // 5964
	FS_proto.onwritestart =                                                                                               // 5965
	FS_proto.onprogress =                                                                                                 // 5966
	FS_proto.onwrite =                                                                                                    // 5967
	FS_proto.onabort =                                                                                                    // 5968
	FS_proto.onerror =                                                                                                    // 5969
	FS_proto.onwriteend =                                                                                                 // 5970
		null;                                                                                                                // 5971
                                                                                                                       // 5972
	return saveAs;                                                                                                        // 5973
}(                                                                                                                     // 5974
	   typeof self !== "undefined" && self                                                                                // 5975
	|| typeof window !== "undefined" && window                                                                            // 5976
	|| this.content                                                                                                       // 5977
));                                                                                                                    // 5978
// `self` is undefined in Firefox for Android content script context                                                   // 5979
// while `this` is nsIContentFrameMessageManager                                                                       // 5980
// with an attribute `content` that corresponds to the window                                                          // 5981
                                                                                                                       // 5982
if (typeof module !== "undefined" && module !== null) {                                                                // 5983
  module.exports = saveAs;                                                                                             // 5984
} else if ((typeof define !== "undefined" && 0)) {                                                                     // 5985
  define([], function() {                                                                                              // 5986
    return saveAs;                                                                                                     // 5987
  });                                                                                                                  // 5988
}                                                                                                                      // 5989
/*                                                                                                                     // 5990
 * Copyright (c) 2012 chick307 <chick307@gmail.com>                                                                    // 5991
 *                                                                                                                     // 5992
 * Licensed under the MIT License.                                                                                     // 5993
 * http://opensource.org/licenses/mit-license                                                                          // 5994
 */                                                                                                                    // 5995
                                                                                                                       // 5996
void function(global, callback) {                                                                                      // 5997
	if (typeof module === 'object') {                                                                                     // 5998
		module.exports = callback();                                                                                         // 5999
	} else if (0 === 'function') {                                                                                        // 6000
		define(callback);                                                                                                    // 6001
	} else {                                                                                                              // 6002
		global.adler32cs = callback();                                                                                       // 6003
	}                                                                                                                     // 6004
}(jsPDF, function() {                                                                                                  // 6005
	var _hasArrayBuffer = typeof ArrayBuffer === 'function' &&                                                            // 6006
		typeof Uint8Array === 'function';                                                                                    // 6007
                                                                                                                       // 6008
	var _Buffer = null, _isBuffer = (function() {                                                                         // 6009
		if (!_hasArrayBuffer)                                                                                                // 6010
			return function _isBuffer() { return false };                                                                       // 6011
                                                                                                                       // 6012
		try {                                                                                                                // 6013
			var buffer = require('buffer');                                                                                     // 6014
			if (typeof buffer.Buffer === 'function')                                                                            // 6015
				_Buffer = buffer.Buffer;                                                                                           // 6016
		} catch (error) {}                                                                                                   // 6017
                                                                                                                       // 6018
		return function _isBuffer(value) {                                                                                   // 6019
			return value instanceof ArrayBuffer ||                                                                              // 6020
				_Buffer !== null && value instanceof _Buffer;                                                                      // 6021
		};                                                                                                                   // 6022
	}());                                                                                                                 // 6023
                                                                                                                       // 6024
	var _utf8ToBinary = (function() {                                                                                     // 6025
		if (_Buffer !== null) {                                                                                              // 6026
			return function _utf8ToBinary(utf8String) {                                                                         // 6027
				return new _Buffer(utf8String, 'utf8').toString('binary');                                                         // 6028
			};                                                                                                                  // 6029
		} else {                                                                                                             // 6030
			return function _utf8ToBinary(utf8String) {                                                                         // 6031
				return unescape(encodeURIComponent(utf8String));                                                                   // 6032
			};                                                                                                                  // 6033
		}                                                                                                                    // 6034
	}());                                                                                                                 // 6035
                                                                                                                       // 6036
	var MOD = 65521;                                                                                                      // 6037
                                                                                                                       // 6038
	var _update = function _update(checksum, binaryString) {                                                              // 6039
		var a = checksum & 0xFFFF, b = checksum >>> 16;                                                                      // 6040
		for (var i = 0, length = binaryString.length; i < length; i++) {                                                     // 6041
			a = (a + (binaryString.charCodeAt(i) & 0xFF)) % MOD;                                                                // 6042
			b = (b + a) % MOD;                                                                                                  // 6043
		}                                                                                                                    // 6044
		return (b << 16 | a) >>> 0;                                                                                          // 6045
	};                                                                                                                    // 6046
                                                                                                                       // 6047
	var _updateUint8Array = function _updateUint8Array(checksum, uint8Array) {                                            // 6048
		var a = checksum & 0xFFFF, b = checksum >>> 16;                                                                      // 6049
		for (var i = 0, length = uint8Array.length, x; i < length; i++) {                                                    // 6050
			a = (a + uint8Array[i]) % MOD;                                                                                      // 6051
			b = (b + a) % MOD;                                                                                                  // 6052
		}                                                                                                                    // 6053
		return (b << 16 | a) >>> 0                                                                                           // 6054
	};                                                                                                                    // 6055
                                                                                                                       // 6056
	var exports = {};                                                                                                     // 6057
                                                                                                                       // 6058
	var Adler32 = exports.Adler32 = (function() {                                                                         // 6059
		var ctor = function Adler32(checksum) {                                                                              // 6060
			if (!(this instanceof ctor)) {                                                                                      // 6061
				throw new TypeError(                                                                                               // 6062
					'Constructor cannot called be as a function.');                                                                   // 6063
			}                                                                                                                   // 6064
			if (!isFinite(checksum = checksum == null ? 1 : +checksum)) {                                                       // 6065
				throw new Error(                                                                                                   // 6066
					'First arguments needs to be a finite number.');                                                                  // 6067
			}                                                                                                                   // 6068
			this.checksum = checksum >>> 0;                                                                                     // 6069
		};                                                                                                                   // 6070
                                                                                                                       // 6071
		var proto = ctor.prototype = {};                                                                                     // 6072
		proto.constructor = ctor;                                                                                            // 6073
                                                                                                                       // 6074
		ctor.from = function(from) {                                                                                         // 6075
			from.prototype = proto;                                                                                             // 6076
			return from;                                                                                                        // 6077
		}(function from(binaryString) {                                                                                      // 6078
			if (!(this instanceof ctor)) {                                                                                      // 6079
				throw new TypeError(                                                                                               // 6080
					'Constructor cannot called be as a function.');                                                                   // 6081
			}                                                                                                                   // 6082
			if (binaryString == null)                                                                                           // 6083
				throw new Error('First argument needs to be a string.');                                                           // 6084
			this.checksum = _update(1, binaryString.toString());                                                                // 6085
		});                                                                                                                  // 6086
                                                                                                                       // 6087
		ctor.fromUtf8 = function(fromUtf8) {                                                                                 // 6088
			fromUtf8.prototype = proto;                                                                                         // 6089
			return fromUtf8;                                                                                                    // 6090
		}(function fromUtf8(utf8String) {                                                                                    // 6091
			if (!(this instanceof ctor)) {                                                                                      // 6092
				throw new TypeError(                                                                                               // 6093
					'Constructor cannot called be as a function.');                                                                   // 6094
			}                                                                                                                   // 6095
			if (utf8String == null)                                                                                             // 6096
				throw new Error('First argument needs to be a string.');                                                           // 6097
			var binaryString = _utf8ToBinary(utf8String.toString());                                                            // 6098
			this.checksum = _update(1, binaryString);                                                                           // 6099
		});                                                                                                                  // 6100
                                                                                                                       // 6101
		if (_hasArrayBuffer) {                                                                                               // 6102
			ctor.fromBuffer = function(fromBuffer) {                                                                            // 6103
				fromBuffer.prototype = proto;                                                                                      // 6104
				return fromBuffer;                                                                                                 // 6105
			}(function fromBuffer(buffer) {                                                                                     // 6106
				if (!(this instanceof ctor)) {                                                                                     // 6107
					throw new TypeError(                                                                                              // 6108
						'Constructor cannot called be as a function.');                                                                  // 6109
				}                                                                                                                  // 6110
				if (!_isBuffer(buffer))                                                                                            // 6111
					throw new Error('First argument needs to be ArrayBuffer.');                                                       // 6112
				var array = new Uint8Array(buffer);                                                                                // 6113
				return this.checksum = _updateUint8Array(1, array);                                                                // 6114
			});                                                                                                                 // 6115
		}                                                                                                                    // 6116
                                                                                                                       // 6117
		proto.update = function update(binaryString) {                                                                       // 6118
			if (binaryString == null)                                                                                           // 6119
				throw new Error('First argument needs to be a string.');                                                           // 6120
			binaryString = binaryString.toString();                                                                             // 6121
			return this.checksum = _update(this.checksum, binaryString);                                                        // 6122
		};                                                                                                                   // 6123
                                                                                                                       // 6124
		proto.updateUtf8 = function updateUtf8(utf8String) {                                                                 // 6125
			if (utf8String == null)                                                                                             // 6126
				throw new Error('First argument needs to be a string.');                                                           // 6127
			var binaryString = _utf8ToBinary(utf8String.toString());                                                            // 6128
			return this.checksum = _update(this.checksum, binaryString);                                                        // 6129
		};                                                                                                                   // 6130
                                                                                                                       // 6131
		if (_hasArrayBuffer) {                                                                                               // 6132
			proto.updateBuffer = function updateBuffer(buffer) {                                                                // 6133
				if (!_isBuffer(buffer))                                                                                            // 6134
					throw new Error('First argument needs to be ArrayBuffer.');                                                       // 6135
				var array = new Uint8Array(buffer);                                                                                // 6136
				return this.checksum = _updateUint8Array(this.checksum, array);                                                    // 6137
			};                                                                                                                  // 6138
		}                                                                                                                    // 6139
                                                                                                                       // 6140
		proto.clone = function clone() {                                                                                     // 6141
			return new Adler32(this.checksum);                                                                                  // 6142
		};                                                                                                                   // 6143
                                                                                                                       // 6144
		return ctor;                                                                                                         // 6145
	}());                                                                                                                 // 6146
                                                                                                                       // 6147
	exports.from = function from(binaryString) {                                                                          // 6148
		if (binaryString == null)                                                                                            // 6149
			throw new Error('First argument needs to be a string.');                                                            // 6150
		return _update(1, binaryString.toString());                                                                          // 6151
	};                                                                                                                    // 6152
                                                                                                                       // 6153
	exports.fromUtf8 = function fromUtf8(utf8String) {                                                                    // 6154
		if (utf8String == null)                                                                                              // 6155
			throw new Error('First argument needs to be a string.');                                                            // 6156
		var binaryString = _utf8ToBinary(utf8String.toString());                                                             // 6157
		return _update(1, binaryString);                                                                                     // 6158
	};                                                                                                                    // 6159
                                                                                                                       // 6160
	if (_hasArrayBuffer) {                                                                                                // 6161
		exports.fromBuffer = function fromBuffer(buffer) {                                                                   // 6162
			if (!_isBuffer(buffer))                                                                                             // 6163
				throw new Error('First argument need to be ArrayBuffer.');                                                         // 6164
			var array = new Uint8Array(buffer);                                                                                 // 6165
			return _updateUint8Array(1, array);                                                                                 // 6166
		};                                                                                                                   // 6167
	}                                                                                                                     // 6168
                                                                                                                       // 6169
	return exports;                                                                                                       // 6170
});                                                                                                                    // 6171
/*                                                                                                                     // 6172
 Deflate.js - https://github.com/gildas-lormeau/zip.js                                                                 // 6173
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.                                                               // 6174
                                                                                                                       // 6175
 Redistribution and use in source and binary forms, with or without                                                    // 6176
 modification, are permitted provided that the following conditions are met:                                           // 6177
                                                                                                                       // 6178
 1. Redistributions of source code must retain the above copyright notice,                                             // 6179
 this list of conditions and the following disclaimer.                                                                 // 6180
                                                                                                                       // 6181
 2. Redistributions in binary form must reproduce the above copyright                                                  // 6182
 notice, this list of conditions and the following disclaimer in                                                       // 6183
 the documentation and/or other materials provided with the distribution.                                              // 6184
                                                                                                                       // 6185
 3. The names of the authors may not be used to endorse or promote products                                            // 6186
 derived from this software without specific prior written permission.                                                 // 6187
                                                                                                                       // 6188
 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,                                          // 6189
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND                                          // 6190
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,                                            // 6191
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,                                         // 6192
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT                                          // 6193
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,                                           // 6194
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF                                             // 6195
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING                                                  // 6196
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,                                          // 6197
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                                                                    // 6198
 */                                                                                                                    // 6199
                                                                                                                       // 6200
/*                                                                                                                     // 6201
 * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.                                                              // 6202
 * JZlib is based on zlib-1.1.3, so all credit should go authors                                                       // 6203
 * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)                                          // 6204
 * and contributors of zlib.                                                                                           // 6205
 */                                                                                                                    // 6206
                                                                                                                       // 6207
var Deflater = (function(obj) {                                                                                        // 6208
                                                                                                                       // 6209
	// Global                                                                                                             // 6210
                                                                                                                       // 6211
	var MAX_BITS = 15;                                                                                                    // 6212
	var D_CODES = 30;                                                                                                     // 6213
	var BL_CODES = 19;                                                                                                    // 6214
                                                                                                                       // 6215
	var LENGTH_CODES = 29;                                                                                                // 6216
	var LITERALS = 256;                                                                                                   // 6217
	var L_CODES = (LITERALS + 1 + LENGTH_CODES);                                                                          // 6218
	var HEAP_SIZE = (2 * L_CODES + 1);                                                                                    // 6219
                                                                                                                       // 6220
	var END_BLOCK = 256;                                                                                                  // 6221
                                                                                                                       // 6222
	// Bit length codes must not exceed MAX_BL_BITS bits                                                                  // 6223
	var MAX_BL_BITS = 7;                                                                                                  // 6224
                                                                                                                       // 6225
	// repeat previous bit length 3-6 times (2 bits of repeat count)                                                      // 6226
	var REP_3_6 = 16;                                                                                                     // 6227
                                                                                                                       // 6228
	// repeat a zero length 3-10 times (3 bits of repeat count)                                                           // 6229
	var REPZ_3_10 = 17;                                                                                                   // 6230
                                                                                                                       // 6231
	// repeat a zero length 11-138 times (7 bits of repeat count)                                                         // 6232
	var REPZ_11_138 = 18;                                                                                                 // 6233
                                                                                                                       // 6234
	// The lengths of the bit length codes are sent in order of decreasing                                                // 6235
	// probability, to avoid transmitting the lengths for unused bit                                                      // 6236
	// length codes.                                                                                                      // 6237
                                                                                                                       // 6238
	var Buf_size = 8 * 2;                                                                                                 // 6239
                                                                                                                       // 6240
	// JZlib version : "1.0.2"                                                                                            // 6241
	var Z_DEFAULT_COMPRESSION = -1;                                                                                       // 6242
                                                                                                                       // 6243
	// compression strategy                                                                                               // 6244
	var Z_FILTERED = 1;                                                                                                   // 6245
	var Z_HUFFMAN_ONLY = 2;                                                                                               // 6246
	var Z_DEFAULT_STRATEGY = 0;                                                                                           // 6247
                                                                                                                       // 6248
	var Z_NO_FLUSH = 0;                                                                                                   // 6249
	var Z_PARTIAL_FLUSH = 1;                                                                                              // 6250
	var Z_FULL_FLUSH = 3;                                                                                                 // 6251
	var Z_FINISH = 4;                                                                                                     // 6252
                                                                                                                       // 6253
	var Z_OK = 0;                                                                                                         // 6254
	var Z_STREAM_END = 1;                                                                                                 // 6255
	var Z_NEED_DICT = 2;                                                                                                  // 6256
	var Z_STREAM_ERROR = -2;                                                                                              // 6257
	var Z_DATA_ERROR = -3;                                                                                                // 6258
	var Z_BUF_ERROR = -5;                                                                                                 // 6259
                                                                                                                       // 6260
	// Tree                                                                                                               // 6261
                                                                                                                       // 6262
	// see definition of array dist_code below                                                                            // 6263
	var _dist_code = [ 0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
			10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
			12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
			13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19,
			20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29 ];           // 6277
                                                                                                                       // 6278
	function Tree() {                                                                                                     // 6279
		var that = this;                                                                                                     // 6280
                                                                                                                       // 6281
		// dyn_tree; // the dynamic tree                                                                                     // 6282
		// max_code; // largest code with non zero frequency                                                                 // 6283
		// stat_desc; // the corresponding static tree                                                                       // 6284
                                                                                                                       // 6285
		// Compute the optimal bit lengths for a tree and update the total bit                                               // 6286
		// length                                                                                                            // 6287
		// for the current block.                                                                                            // 6288
		// IN assertion: the fields freq and dad are set, heap[heap_max] and                                                 // 6289
		// above are the tree nodes sorted by increasing frequency.                                                          // 6290
		// OUT assertions: the field len is set to the optimal bit length, the                                               // 6291
		// array bl_count contains the frequencies for each bit length.                                                      // 6292
		// The length opt_len is updated; static_len is also updated if stree is                                             // 6293
		// not null.                                                                                                         // 6294
		function gen_bitlen(s) {                                                                                             // 6295
			var tree = that.dyn_tree;                                                                                           // 6296
			var stree = that.stat_desc.static_tree;                                                                             // 6297
			var extra = that.stat_desc.extra_bits;                                                                              // 6298
			var base = that.stat_desc.extra_base;                                                                               // 6299
			var max_length = that.stat_desc.max_length;                                                                         // 6300
			var h; // heap index                                                                                                // 6301
			var n, m; // iterate over the tree elements                                                                         // 6302
			var bits; // bit length                                                                                             // 6303
			var xbits; // extra bits                                                                                            // 6304
			var f; // frequency                                                                                                 // 6305
			var overflow = 0; // number of elements with bit length too large                                                   // 6306
                                                                                                                       // 6307
			for (bits = 0; bits <= MAX_BITS; bits++)                                                                            // 6308
				s.bl_count[bits] = 0;                                                                                              // 6309
                                                                                                                       // 6310
			// In a first pass, compute the optimal bit lengths (which may                                                      // 6311
			// overflow in the case of the bit length tree).                                                                    // 6312
			tree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap                                                           // 6313
                                                                                                                       // 6314
			for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {                                                                      // 6315
				n = s.heap[h];                                                                                                     // 6316
				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                                                                          // 6317
				if (bits > max_length) {                                                                                           // 6318
					bits = max_length;                                                                                                // 6319
					overflow++;                                                                                                       // 6320
				}                                                                                                                  // 6321
				tree[n * 2 + 1] = bits;                                                                                            // 6322
				// We overwrite tree[n*2+1] which is no longer needed                                                              // 6323
                                                                                                                       // 6324
				if (n > that.max_code)                                                                                             // 6325
					continue; // not a leaf node                                                                                      // 6326
                                                                                                                       // 6327
				s.bl_count[bits]++;                                                                                                // 6328
				xbits = 0;                                                                                                         // 6329
				if (n >= base)                                                                                                     // 6330
					xbits = extra[n - base];                                                                                          // 6331
				f = tree[n * 2];                                                                                                   // 6332
				s.opt_len += f * (bits + xbits);                                                                                   // 6333
				if (stree)                                                                                                         // 6334
					s.static_len += f * (stree[n * 2 + 1] + xbits);                                                                   // 6335
			}                                                                                                                   // 6336
			if (overflow === 0)                                                                                                 // 6337
				return;                                                                                                            // 6338
                                                                                                                       // 6339
			// This happens for example on obj2 and pic of the Calgary corpus                                                   // 6340
			// Find the first bit length which could increase:                                                                  // 6341
			do {                                                                                                                // 6342
				bits = max_length - 1;                                                                                             // 6343
				while (s.bl_count[bits] === 0)                                                                                     // 6344
					bits--;                                                                                                           // 6345
				s.bl_count[bits]--; // move one leaf down the tree                                                                 // 6346
				s.bl_count[bits + 1] += 2; // move one overflow item as its brother                                                // 6347
				s.bl_count[max_length]--;                                                                                          // 6348
				// The brother of the overflow item also moves one step up,                                                        // 6349
				// but this does not affect bl_count[max_length]                                                                   // 6350
				overflow -= 2;                                                                                                     // 6351
			} while (overflow > 0);                                                                                             // 6352
                                                                                                                       // 6353
			for (bits = max_length; bits !== 0; bits--) {                                                                       // 6354
				n = s.bl_count[bits];                                                                                              // 6355
				while (n !== 0) {                                                                                                  // 6356
					m = s.heap[--h];                                                                                                  // 6357
					if (m > that.max_code)                                                                                            // 6358
						continue;                                                                                                        // 6359
					if (tree[m * 2 + 1] != bits) {                                                                                    // 6360
						s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];                                                             // 6361
						tree[m * 2 + 1] = bits;                                                                                          // 6362
					}                                                                                                                 // 6363
					n--;                                                                                                              // 6364
				}                                                                                                                  // 6365
			}                                                                                                                   // 6366
		}                                                                                                                    // 6367
                                                                                                                       // 6368
		// Reverse the first len bits of a code, using straightforward code (a                                               // 6369
		// faster                                                                                                            // 6370
		// method would use a table)                                                                                         // 6371
		// IN assertion: 1 <= len <= 15                                                                                      // 6372
		function bi_reverse(code, // the value to invert                                                                     // 6373
		len // its bit length                                                                                                // 6374
		) {                                                                                                                  // 6375
			var res = 0;                                                                                                        // 6376
			do {                                                                                                                // 6377
				res |= code & 1;                                                                                                   // 6378
				code >>>= 1;                                                                                                       // 6379
				res <<= 1;                                                                                                         // 6380
			} while (--len > 0);                                                                                                // 6381
			return res >>> 1;                                                                                                   // 6382
		}                                                                                                                    // 6383
                                                                                                                       // 6384
		// Generate the codes for a given tree and bit counts (which need not be                                             // 6385
		// optimal).                                                                                                         // 6386
		// IN assertion: the array bl_count contains the bit length statistics for                                           // 6387
		// the given tree and the field len is set for all tree elements.                                                    // 6388
		// OUT assertion: the field code is set for all tree elements of non                                                 // 6389
		// zero code length.                                                                                                 // 6390
		function gen_codes(tree, // the tree to decorate                                                                     // 6391
		max_code, // largest code with non zero frequency                                                                    // 6392
		bl_count // number of codes at each bit length                                                                       // 6393
		) {                                                                                                                  // 6394
			var next_code = []; // next code value for each                                                                     // 6395
			// bit length                                                                                                       // 6396
			var code = 0; // running code value                                                                                 // 6397
			var bits; // bit index                                                                                              // 6398
			var n; // code index                                                                                                // 6399
			var len;                                                                                                            // 6400
                                                                                                                       // 6401
			// The distribution counts are first used to generate the code values                                               // 6402
			// without bit reversal.                                                                                            // 6403
			for (bits = 1; bits <= MAX_BITS; bits++) {                                                                          // 6404
				next_code[bits] = code = ((code + bl_count[bits - 1]) << 1);                                                       // 6405
			}                                                                                                                   // 6406
                                                                                                                       // 6407
			// Check that the bit counts in bl_count are consistent. The last code                                              // 6408
			// must be all ones.                                                                                                // 6409
			// Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,                                                          // 6410
			// "inconsistent bit counts");                                                                                      // 6411
			// Tracev((stderr,"\ngen_codes: max_code %d ", max_code));                                                          // 6412
                                                                                                                       // 6413
			for (n = 0; n <= max_code; n++) {                                                                                   // 6414
				len = tree[n * 2 + 1];                                                                                             // 6415
				if (len === 0)                                                                                                     // 6416
					continue;                                                                                                         // 6417
				// Now reverse the bits                                                                                            // 6418
				tree[n * 2] = bi_reverse(next_code[len]++, len);                                                                   // 6419
			}                                                                                                                   // 6420
		}                                                                                                                    // 6421
                                                                                                                       // 6422
		// Construct one Huffman tree and assigns the code bit strings and lengths.                                          // 6423
		// Update the total bit length for the current block.                                                                // 6424
		// IN assertion: the field freq is set for all tree elements.                                                        // 6425
		// OUT assertions: the fields len and code are set to the optimal bit length                                         // 6426
		// and corresponding code. The length opt_len is updated; static_len is                                              // 6427
		// also updated if stree is not null. The field max_code is set.                                                     // 6428
		that.build_tree = function(s) {                                                                                      // 6429
			var tree = that.dyn_tree;                                                                                           // 6430
			var stree = that.stat_desc.static_tree;                                                                             // 6431
			var elems = that.stat_desc.elems;                                                                                   // 6432
			var n, m; // iterate over heap elements                                                                             // 6433
			var max_code = -1; // largest code with non zero frequency                                                          // 6434
			var node; // new node being created                                                                                 // 6435
                                                                                                                       // 6436
			// Construct the initial heap, with least frequent element in                                                       // 6437
			// heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].                                                      // 6438
			// heap[0] is not used.                                                                                             // 6439
			s.heap_len = 0;                                                                                                     // 6440
			s.heap_max = HEAP_SIZE;                                                                                             // 6441
                                                                                                                       // 6442
			for (n = 0; n < elems; n++) {                                                                                       // 6443
				if (tree[n * 2] !== 0) {                                                                                           // 6444
					s.heap[++s.heap_len] = max_code = n;                                                                              // 6445
					s.depth[n] = 0;                                                                                                   // 6446
				} else {                                                                                                           // 6447
					tree[n * 2 + 1] = 0;                                                                                              // 6448
				}                                                                                                                  // 6449
			}                                                                                                                   // 6450
                                                                                                                       // 6451
			// The pkzip format requires that at least one distance code exists,                                                // 6452
			// and that at least one bit should be sent even if there is only one                                               // 6453
			// possible code. So to avoid special checks later on we force at least                                             // 6454
			// two codes of non zero frequency.                                                                                 // 6455
			while (s.heap_len < 2) {                                                                                            // 6456
				node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;                                                       // 6457
				tree[node * 2] = 1;                                                                                                // 6458
				s.depth[node] = 0;                                                                                                 // 6459
				s.opt_len--;                                                                                                       // 6460
				if (stree)                                                                                                         // 6461
					s.static_len -= stree[node * 2 + 1];                                                                              // 6462
				// node is 0 or 1 so it does not have extra bits                                                                   // 6463
			}                                                                                                                   // 6464
			that.max_code = max_code;                                                                                           // 6465
                                                                                                                       // 6466
			// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,                                              // 6467
			// establish sub-heaps of increasing lengths:                                                                       // 6468
                                                                                                                       // 6469
			for (n = Math.floor(s.heap_len / 2); n >= 1; n--)                                                                   // 6470
				s.pqdownheap(tree, n);                                                                                             // 6471
                                                                                                                       // 6472
			// Construct the Huffman tree by repeatedly combining the least two                                                 // 6473
			// frequent nodes.                                                                                                  // 6474
                                                                                                                       // 6475
			node = elems; // next internal node of the tree                                                                     // 6476
			do {                                                                                                                // 6477
				// n = node of least frequency                                                                                     // 6478
				n = s.heap[1];                                                                                                     // 6479
				s.heap[1] = s.heap[s.heap_len--];                                                                                  // 6480
				s.pqdownheap(tree, 1);                                                                                             // 6481
				m = s.heap[1]; // m = node of next least frequency                                                                 // 6482
                                                                                                                       // 6483
				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                                                    // 6484
				s.heap[--s.heap_max] = m;                                                                                          // 6485
                                                                                                                       // 6486
				// Create a new node father of n and m                                                                             // 6487
				tree[node * 2] = (tree[n * 2] + tree[m * 2]);                                                                      // 6488
				s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;                                                              // 6489
				tree[n * 2 + 1] = tree[m * 2 + 1] = node;                                                                          // 6490
                                                                                                                       // 6491
				// and insert the new node in the heap                                                                             // 6492
				s.heap[1] = node++;                                                                                                // 6493
				s.pqdownheap(tree, 1);                                                                                             // 6494
			} while (s.heap_len >= 2);                                                                                          // 6495
                                                                                                                       // 6496
			s.heap[--s.heap_max] = s.heap[1];                                                                                   // 6497
                                                                                                                       // 6498
			// At this point, the fields freq and dad are set. We can now                                                       // 6499
			// generate the bit lengths.                                                                                        // 6500
                                                                                                                       // 6501
			gen_bitlen(s);                                                                                                      // 6502
                                                                                                                       // 6503
			// The field len is now set, we can generate the bit codes                                                          // 6504
			gen_codes(tree, that.max_code, s.bl_count);                                                                         // 6505
		};                                                                                                                   // 6506
                                                                                                                       // 6507
	}                                                                                                                     // 6508
                                                                                                                       // 6509
	Tree._length_code = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,
			16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20,
			20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
			22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
			25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28 ];
                                                                                                                       // 6517
	Tree.base_length = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0 ];
                                                                                                                       // 6519
	Tree.base_dist = [ 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384,
			24576 ];                                                                                                            // 6521
                                                                                                                       // 6522
	// Mapping from a distance to a distance code. dist is the distance - 1 and                                           // 6523
	// must not have side effects. _dist_code[256] and _dist_code[257] are never                                          // 6524
	// used.                                                                                                              // 6525
	Tree.d_code = function(dist) {                                                                                        // 6526
		return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >>> 7)]);                                         // 6527
	};                                                                                                                    // 6528
                                                                                                                       // 6529
	// extra bits for each length code                                                                                    // 6530
	Tree.extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ];         // 6531
                                                                                                                       // 6532
	// extra bits for each distance code                                                                                  // 6533
	Tree.extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
                                                                                                                       // 6535
	// extra bits for each bit length code                                                                                // 6536
	Tree.extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ];                                      // 6537
                                                                                                                       // 6538
	Tree.bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];                                 // 6539
                                                                                                                       // 6540
	// StaticTree                                                                                                         // 6541
                                                                                                                       // 6542
	function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {                                         // 6543
		var that = this;                                                                                                     // 6544
		that.static_tree = static_tree;                                                                                      // 6545
		that.extra_bits = extra_bits;                                                                                        // 6546
		that.extra_base = extra_base;                                                                                        // 6547
		that.elems = elems;                                                                                                  // 6548
		that.max_length = max_length;                                                                                        // 6549
	}                                                                                                                     // 6550
                                                                                                                       // 6551
	StaticTree.static_ltree = [ 12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8,
			130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42,
			8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8,
			22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8,
			222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113,
			8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8,
			69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8,
			173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9,
			51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9,
			427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379,
			9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23,
			9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9,
			399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9,
			223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7,
			40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8,
			99, 8, 227, 8 ];                                                                                                    // 6567
                                                                                                                       // 6568
	StaticTree.static_dtree = [ 0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5,
			25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5 ];                                         // 6570
                                                                                                                       // 6571
	StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
                                                                                                                       // 6573
	StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);           // 6574
                                                                                                                       // 6575
	StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);                        // 6576
                                                                                                                       // 6577
	// Deflate                                                                                                            // 6578
                                                                                                                       // 6579
	var MAX_MEM_LEVEL = 9;                                                                                                // 6580
	var DEF_MEM_LEVEL = 8;                                                                                                // 6581
                                                                                                                       // 6582
	function Config(good_length, max_lazy, nice_length, max_chain, func) {                                                // 6583
		var that = this;                                                                                                     // 6584
		that.good_length = good_length;                                                                                      // 6585
		that.max_lazy = max_lazy;                                                                                            // 6586
		that.nice_length = nice_length;                                                                                      // 6587
		that.max_chain = max_chain;                                                                                          // 6588
		that.func = func;                                                                                                    // 6589
	}                                                                                                                     // 6590
                                                                                                                       // 6591
	var STORED = 0;                                                                                                       // 6592
	var FAST = 1;                                                                                                         // 6593
	var SLOW = 2;                                                                                                         // 6594
	var config_table = [ new Config(0, 0, 0, 0, STORED), new Config(4, 4, 8, 4, FAST), new Config(4, 5, 16, 8, FAST), new Config(4, 6, 32, 32, FAST),
			new Config(4, 4, 16, 16, SLOW), new Config(8, 16, 32, 32, SLOW), new Config(8, 16, 128, 128, SLOW), new Config(8, 32, 128, 256, SLOW),
			new Config(32, 128, 258, 1024, SLOW), new Config(32, 258, 258, 4096, SLOW) ];                                       // 6597
                                                                                                                       // 6598
	var z_errmsg = [ "need dictionary", // Z_NEED_DICT                                                                    // 6599
	// 2                                                                                                                  // 6600
	"stream end", // Z_STREAM_END 1                                                                                       // 6601
	"", // Z_OK 0                                                                                                         // 6602
	"", // Z_ERRNO (-1)                                                                                                   // 6603
	"stream error", // Z_STREAM_ERROR (-2)                                                                                // 6604
	"data error", // Z_DATA_ERROR (-3)                                                                                    // 6605
	"", // Z_MEM_ERROR (-4)                                                                                               // 6606
	"buffer error", // Z_BUF_ERROR (-5)                                                                                   // 6607
	"",// Z_VERSION_ERROR (-6)                                                                                            // 6608
	"" ];                                                                                                                 // 6609
                                                                                                                       // 6610
	// block not completed, need more input or more output                                                                // 6611
	var NeedMore = 0;                                                                                                     // 6612
                                                                                                                       // 6613
	// block flush performed                                                                                              // 6614
	var BlockDone = 1;                                                                                                    // 6615
                                                                                                                       // 6616
	// finish started, need only more output at next deflate                                                              // 6617
	var FinishStarted = 2;                                                                                                // 6618
                                                                                                                       // 6619
	// finish done, accept no more input or output                                                                        // 6620
	var FinishDone = 3;                                                                                                   // 6621
                                                                                                                       // 6622
	// preset dictionary flag in zlib header                                                                              // 6623
	var PRESET_DICT = 0x20;                                                                                               // 6624
                                                                                                                       // 6625
	var INIT_STATE = 42;                                                                                                  // 6626
	var BUSY_STATE = 113;                                                                                                 // 6627
	var FINISH_STATE = 666;                                                                                               // 6628
                                                                                                                       // 6629
	// The deflate compression method                                                                                     // 6630
	var Z_DEFLATED = 8;                                                                                                   // 6631
                                                                                                                       // 6632
	var STORED_BLOCK = 0;                                                                                                 // 6633
	var STATIC_TREES = 1;                                                                                                 // 6634
	var DYN_TREES = 2;                                                                                                    // 6635
                                                                                                                       // 6636
	var MIN_MATCH = 3;                                                                                                    // 6637
	var MAX_MATCH = 258;                                                                                                  // 6638
	var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);                                                                      // 6639
                                                                                                                       // 6640
	function smaller(tree, n, m, depth) {                                                                                 // 6641
		var tn2 = tree[n * 2];                                                                                               // 6642
		var tm2 = tree[m * 2];                                                                                               // 6643
		return (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));                                                          // 6644
	}                                                                                                                     // 6645
                                                                                                                       // 6646
	function Deflate() {                                                                                                  // 6647
                                                                                                                       // 6648
		var that = this;                                                                                                     // 6649
		var strm; // pointer back to this zlib stream                                                                        // 6650
		var status; // as the name implies                                                                                   // 6651
		// pending_buf; // output still pending                                                                              // 6652
		var pending_buf_size; // size of pending_buf                                                                         // 6653
		// pending_out; // next pending byte to output to the stream                                                         // 6654
		// pending; // nb of bytes in the pending buffer                                                                     // 6655
		var method; // STORED (for zip only) or DEFLATED                                                                     // 6656
		var last_flush; // value of flush param for previous deflate call                                                    // 6657
                                                                                                                       // 6658
		var w_size; // LZ77 window size (32K by default)                                                                     // 6659
		var w_bits; // log2(w_size) (8..16)                                                                                  // 6660
		var w_mask; // w_size - 1                                                                                            // 6661
                                                                                                                       // 6662
		var window;                                                                                                          // 6663
		// Sliding window. Input bytes are read into the second half of the window,                                          // 6664
		// and move to the first half later to keep a dictionary of at least wSize                                           // 6665
		// bytes. With this organization, matches are limited to a distance of                                               // 6666
		// wSize-MAX_MATCH bytes, but this ensures that IO is always                                                         // 6667
		// performed with a length multiple of the block size. Also, it limits                                               // 6668
		// the window size to 64K, which is quite useful on MSDOS.                                                           // 6669
		// To do: use the user input buffer as sliding window.                                                               // 6670
                                                                                                                       // 6671
		var window_size;                                                                                                     // 6672
		// Actual size of window: 2*wSize, except when the user input buffer                                                 // 6673
		// is directly used as sliding window.                                                                               // 6674
                                                                                                                       // 6675
		var prev;                                                                                                            // 6676
		// Link to older string with same hash index. To limit the size of this                                              // 6677
		// array to 64K, this link is maintained only for the last 32K strings.                                              // 6678
		// An index in this array is thus a window index modulo 32K.                                                         // 6679
                                                                                                                       // 6680
		var head; // Heads of the hash chains or NIL.                                                                        // 6681
                                                                                                                       // 6682
		var ins_h; // hash index of string to be inserted                                                                    // 6683
		var hash_size; // number of elements in hash table                                                                   // 6684
		var hash_bits; // log2(hash_size)                                                                                    // 6685
		var hash_mask; // hash_size-1                                                                                        // 6686
                                                                                                                       // 6687
		// Number of bits by which ins_h must be shifted at each input                                                       // 6688
		// step. It must be such that after MIN_MATCH steps, the oldest                                                      // 6689
		// byte no longer takes part in the hash key, that is:                                                               // 6690
		// hash_shift * MIN_MATCH >= hash_bits                                                                               // 6691
		var hash_shift;                                                                                                      // 6692
                                                                                                                       // 6693
		// Window position at the beginning of the current output block. Gets                                                // 6694
		// negative when the window is moved backwards.                                                                      // 6695
                                                                                                                       // 6696
		var block_start;                                                                                                     // 6697
                                                                                                                       // 6698
		var match_length; // length of best match                                                                            // 6699
		var prev_match; // previous match                                                                                    // 6700
		var match_available; // set if previous match exists                                                                 // 6701
		var strstart; // start of string to insert                                                                           // 6702
		var match_start; // start of matching string                                                                         // 6703
		var lookahead; // number of valid bytes ahead in window                                                              // 6704
                                                                                                                       // 6705
		// Length of the best match at previous step. Matches not greater than this                                          // 6706
		// are discarded. This is used in the lazy match evaluation.                                                         // 6707
		var prev_length;                                                                                                     // 6708
                                                                                                                       // 6709
		// To speed up deflation, hash chains are never searched beyond this                                                 // 6710
		// length. A higher limit improves compression ratio but degrades the speed.                                         // 6711
		var max_chain_length;                                                                                                // 6712
                                                                                                                       // 6713
		// Attempt to find a better match only when the current match is strictly                                            // 6714
		// smaller than this value. This mechanism is used only for compression                                              // 6715
		// levels >= 4.                                                                                                      // 6716
		var max_lazy_match;                                                                                                  // 6717
                                                                                                                       // 6718
		// Insert new strings in the hash table only if the match length is not                                              // 6719
		// greater than this length. This saves time but degrades compression.                                               // 6720
		// max_insert_length is used only for compression levels <= 3.                                                       // 6721
                                                                                                                       // 6722
		var level; // compression level (1..9)                                                                               // 6723
		var strategy; // favor or force Huffman coding                                                                       // 6724
                                                                                                                       // 6725
		// Use a faster search when the previous match is longer than this                                                   // 6726
		var good_match;                                                                                                      // 6727
                                                                                                                       // 6728
		// Stop searching when current match exceeds this                                                                    // 6729
		var nice_match;                                                                                                      // 6730
                                                                                                                       // 6731
		var dyn_ltree; // literal and length tree                                                                            // 6732
		var dyn_dtree; // distance tree                                                                                      // 6733
		var bl_tree; // Huffman tree for bit lengths                                                                         // 6734
                                                                                                                       // 6735
		var l_desc = new Tree(); // desc for literal tree                                                                    // 6736
		var d_desc = new Tree(); // desc for distance tree                                                                   // 6737
		var bl_desc = new Tree(); // desc for bit length tree                                                                // 6738
                                                                                                                       // 6739
		// that.heap_len; // number of elements in the heap                                                                  // 6740
		// that.heap_max; // element of largest frequency                                                                    // 6741
		// The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.                                           // 6742
		// The same heap array is used to build all trees.                                                                   // 6743
                                                                                                                       // 6744
		// Depth of each subtree used as tie breaker for trees of equal frequency                                            // 6745
		that.depth = [];                                                                                                     // 6746
                                                                                                                       // 6747
		var l_buf; // index for literals or lengths */                                                                       // 6748
                                                                                                                       // 6749
		// Size of match buffer for literals/lengths. There are 4 reasons for                                                // 6750
		// limiting lit_bufsize to 64K:                                                                                      // 6751
		// - frequencies can be kept in 16 bit counters                                                                      // 6752
		// - if compression is not successful for the first block, all input                                                 // 6753
		// data is still in the window so we can still emit a stored block even                                              // 6754
		// when input comes from standard input. (This can also be done for                                                  // 6755
		// all blocks if lit_bufsize is not greater than 32K.)                                                               // 6756
		// - if compression is not successful for a file smaller than 64K, we can                                            // 6757
		// even emit a stored file instead of a stored block (saving 5 bytes).                                               // 6758
		// This is applicable only for zip (not gzip or zlib).                                                               // 6759
		// - creating new Huffman trees less frequently may not provide fast                                                 // 6760
		// adaptation to changes in the input data statistics. (Take for                                                     // 6761
		// example a binary file with poorly compressible code followed by                                                   // 6762
		// a highly compressible string table.) Smaller buffer sizes give                                                    // 6763
		// fast adaptation but have of course the overhead of transmitting                                                   // 6764
		// trees more frequently.                                                                                            // 6765
		// - I can't count above 4                                                                                           // 6766
		var lit_bufsize;                                                                                                     // 6767
                                                                                                                       // 6768
		var last_lit; // running index in l_buf                                                                              // 6769
                                                                                                                       // 6770
		// Buffer for distances. To simplify the code, d_buf and l_buf have                                                  // 6771
		// the same number of elements. To use different lengths, an extra flag                                              // 6772
		// array would be necessary.                                                                                         // 6773
                                                                                                                       // 6774
		var d_buf; // index of pendig_buf                                                                                    // 6775
                                                                                                                       // 6776
		// that.opt_len; // bit length of current block with optimal trees                                                   // 6777
		// that.static_len; // bit length of current block with static trees                                                 // 6778
		var matches; // number of string matches in current block                                                            // 6779
		var last_eob_len; // bit length of EOB code for last block                                                           // 6780
                                                                                                                       // 6781
		// Output buffer. bits are inserted starting at the bottom (least                                                    // 6782
		// significant bits).                                                                                                // 6783
		var bi_buf;                                                                                                          // 6784
                                                                                                                       // 6785
		// Number of valid bits in bi_buf. All bits above the last valid bit                                                 // 6786
		// are always zero.                                                                                                  // 6787
		var bi_valid;                                                                                                        // 6788
                                                                                                                       // 6789
		// number of codes at each bit length for an optimal tree                                                            // 6790
		that.bl_count = [];                                                                                                  // 6791
                                                                                                                       // 6792
		// heap used to build the Huffman trees                                                                              // 6793
		that.heap = [];                                                                                                      // 6794
                                                                                                                       // 6795
		dyn_ltree = [];                                                                                                      // 6796
		dyn_dtree = [];                                                                                                      // 6797
		bl_tree = [];                                                                                                        // 6798
                                                                                                                       // 6799
		function lm_init() {                                                                                                 // 6800
			var i;                                                                                                              // 6801
			window_size = 2 * w_size;                                                                                           // 6802
                                                                                                                       // 6803
			head[hash_size - 1] = 0;                                                                                            // 6804
			for (i = 0; i < hash_size - 1; i++) {                                                                               // 6805
				head[i] = 0;                                                                                                       // 6806
			}                                                                                                                   // 6807
                                                                                                                       // 6808
			// Set the default configuration parameters:                                                                        // 6809
			max_lazy_match = config_table[level].max_lazy;                                                                      // 6810
			good_match = config_table[level].good_length;                                                                       // 6811
			nice_match = config_table[level].nice_length;                                                                       // 6812
			max_chain_length = config_table[level].max_chain;                                                                   // 6813
                                                                                                                       // 6814
			strstart = 0;                                                                                                       // 6815
			block_start = 0;                                                                                                    // 6816
			lookahead = 0;                                                                                                      // 6817
			match_length = prev_length = MIN_MATCH - 1;                                                                         // 6818
			match_available = 0;                                                                                                // 6819
			ins_h = 0;                                                                                                          // 6820
		}                                                                                                                    // 6821
                                                                                                                       // 6822
		function init_block() {                                                                                              // 6823
			var i;                                                                                                              // 6824
			// Initialize the trees.                                                                                            // 6825
			for (i = 0; i < L_CODES; i++)                                                                                       // 6826
				dyn_ltree[i * 2] = 0;                                                                                              // 6827
			for (i = 0; i < D_CODES; i++)                                                                                       // 6828
				dyn_dtree[i * 2] = 0;                                                                                              // 6829
			for (i = 0; i < BL_CODES; i++)                                                                                      // 6830
				bl_tree[i * 2] = 0;                                                                                                // 6831
                                                                                                                       // 6832
			dyn_ltree[END_BLOCK * 2] = 1;                                                                                       // 6833
			that.opt_len = that.static_len = 0;                                                                                 // 6834
			last_lit = matches = 0;                                                                                             // 6835
		}                                                                                                                    // 6836
                                                                                                                       // 6837
		// Initialize the tree data structures for a new zlib stream.                                                        // 6838
		function tr_init() {                                                                                                 // 6839
                                                                                                                       // 6840
			l_desc.dyn_tree = dyn_ltree;                                                                                        // 6841
			l_desc.stat_desc = StaticTree.static_l_desc;                                                                        // 6842
                                                                                                                       // 6843
			d_desc.dyn_tree = dyn_dtree;                                                                                        // 6844
			d_desc.stat_desc = StaticTree.static_d_desc;                                                                        // 6845
                                                                                                                       // 6846
			bl_desc.dyn_tree = bl_tree;                                                                                         // 6847
			bl_desc.stat_desc = StaticTree.static_bl_desc;                                                                      // 6848
                                                                                                                       // 6849
			bi_buf = 0;                                                                                                         // 6850
			bi_valid = 0;                                                                                                       // 6851
			last_eob_len = 8; // enough lookahead for inflate                                                                   // 6852
                                                                                                                       // 6853
			// Initialize the first block of the first file:                                                                    // 6854
			init_block();                                                                                                       // 6855
		}                                                                                                                    // 6856
                                                                                                                       // 6857
		// Restore the heap property by moving down the tree starting at node k,                                             // 6858
		// exchanging a node with the smallest of its two sons if necessary,                                                 // 6859
		// stopping                                                                                                          // 6860
		// when the heap property is re-established (each father smaller than its                                            // 6861
		// two sons).                                                                                                        // 6862
		that.pqdownheap = function(tree, // the tree to restore                                                              // 6863
		k // node to move down                                                                                               // 6864
		) {                                                                                                                  // 6865
			var heap = that.heap;                                                                                               // 6866
			var v = heap[k];                                                                                                    // 6867
			var j = k << 1; // left son of k                                                                                    // 6868
			while (j <= that.heap_len) {                                                                                        // 6869
				// Set j to the smallest of the two sons:                                                                          // 6870
				if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {                                        // 6871
					j++;                                                                                                              // 6872
				}                                                                                                                  // 6873
				// Exit if v is smaller than both sons                                                                             // 6874
				if (smaller(tree, v, heap[j], that.depth))                                                                         // 6875
					break;                                                                                                            // 6876
                                                                                                                       // 6877
				// Exchange v with the smallest son                                                                                // 6878
				heap[k] = heap[j];                                                                                                 // 6879
				k = j;                                                                                                             // 6880
				// And continue down the tree, setting j to the left son of k                                                      // 6881
				j <<= 1;                                                                                                           // 6882
			}                                                                                                                   // 6883
			heap[k] = v;                                                                                                        // 6884
		};                                                                                                                   // 6885
                                                                                                                       // 6886
		// Scan a literal or distance tree to determine the frequencies of the codes                                         // 6887
		// in the bit length tree.                                                                                           // 6888
		function scan_tree(tree,// the tree to be scanned                                                                    // 6889
		max_code // and its largest code of non zero frequency                                                               // 6890
		) {                                                                                                                  // 6891
			var n; // iterates over all tree elements                                                                           // 6892
			var prevlen = -1; // last emitted length                                                                            // 6893
			var curlen; // length of current code                                                                               // 6894
			var nextlen = tree[0 * 2 + 1]; // length of next code                                                               // 6895
			var count = 0; // repeat count of the current code                                                                  // 6896
			var max_count = 7; // max repeat count                                                                              // 6897
			var min_count = 4; // min repeat count                                                                              // 6898
                                                                                                                       // 6899
			if (nextlen === 0) {                                                                                                // 6900
				max_count = 138;                                                                                                   // 6901
				min_count = 3;                                                                                                     // 6902
			}                                                                                                                   // 6903
			tree[(max_code + 1) * 2 + 1] = 0xffff; // guard                                                                     // 6904
                                                                                                                       // 6905
			for (n = 0; n <= max_code; n++) {                                                                                   // 6906
				curlen = nextlen;                                                                                                  // 6907
				nextlen = tree[(n + 1) * 2 + 1];                                                                                   // 6908
				if (++count < max_count && curlen == nextlen) {                                                                    // 6909
					continue;                                                                                                         // 6910
				} else if (count < min_count) {                                                                                    // 6911
					bl_tree[curlen * 2] += count;                                                                                     // 6912
				} else if (curlen !== 0) {                                                                                         // 6913
					if (curlen != prevlen)                                                                                            // 6914
						bl_tree[curlen * 2]++;                                                                                           // 6915
					bl_tree[REP_3_6 * 2]++;                                                                                           // 6916
				} else if (count <= 10) {                                                                                          // 6917
					bl_tree[REPZ_3_10 * 2]++;                                                                                         // 6918
				} else {                                                                                                           // 6919
					bl_tree[REPZ_11_138 * 2]++;                                                                                       // 6920
				}                                                                                                                  // 6921
				count = 0;                                                                                                         // 6922
				prevlen = curlen;                                                                                                  // 6923
				if (nextlen === 0) {                                                                                               // 6924
					max_count = 138;                                                                                                  // 6925
					min_count = 3;                                                                                                    // 6926
				} else if (curlen == nextlen) {                                                                                    // 6927
					max_count = 6;                                                                                                    // 6928
					min_count = 3;                                                                                                    // 6929
				} else {                                                                                                           // 6930
					max_count = 7;                                                                                                    // 6931
					min_count = 4;                                                                                                    // 6932
				}                                                                                                                  // 6933
			}                                                                                                                   // 6934
		}                                                                                                                    // 6935
                                                                                                                       // 6936
		// Construct the Huffman tree for the bit lengths and return the index in                                            // 6937
		// bl_order of the last bit length code to send.                                                                     // 6938
		function build_bl_tree() {                                                                                           // 6939
			var max_blindex; // index of last bit length code of non zero freq                                                  // 6940
                                                                                                                       // 6941
			// Determine the bit length frequencies for literal and distance trees                                              // 6942
			scan_tree(dyn_ltree, l_desc.max_code);                                                                              // 6943
			scan_tree(dyn_dtree, d_desc.max_code);                                                                              // 6944
                                                                                                                       // 6945
			// Build the bit length tree:                                                                                       // 6946
			bl_desc.build_tree(that);                                                                                           // 6947
			// opt_len now includes the length of the tree representations, except                                              // 6948
			// the lengths of the bit lengths codes and the 5+5+4 bits for the                                                  // 6949
			// counts.                                                                                                          // 6950
                                                                                                                       // 6951
			// Determine the number of bit length codes to send. The pkzip format                                               // 6952
			// requires that at least 4 bit length codes be sent. (appnote.txt says                                             // 6953
			// 3 but the actual value used is 4.)                                                                               // 6954
			for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {                                                 // 6955
				if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)                                                             // 6956
					break;                                                                                                            // 6957
			}                                                                                                                   // 6958
			// Update opt_len to include the bit length tree and counts                                                         // 6959
			that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;                                                                  // 6960
                                                                                                                       // 6961
			return max_blindex;                                                                                                 // 6962
		}                                                                                                                    // 6963
                                                                                                                       // 6964
		// Output a byte on the stream.                                                                                      // 6965
		// IN assertion: there is enough room in pending_buf.                                                                // 6966
		function put_byte(p) {                                                                                               // 6967
			that.pending_buf[that.pending++] = p;                                                                               // 6968
		}                                                                                                                    // 6969
                                                                                                                       // 6970
		function put_short(w) {                                                                                              // 6971
			put_byte(w & 0xff);                                                                                                 // 6972
			put_byte((w >>> 8) & 0xff);                                                                                         // 6973
		}                                                                                                                    // 6974
                                                                                                                       // 6975
		function putShortMSB(b) {                                                                                            // 6976
			put_byte((b >> 8) & 0xff);                                                                                          // 6977
			put_byte((b & 0xff) & 0xff);                                                                                        // 6978
		}                                                                                                                    // 6979
                                                                                                                       // 6980
		function send_bits(value, length) {                                                                                  // 6981
			var val, len = length;                                                                                              // 6982
			if (bi_valid > Buf_size - len) {                                                                                    // 6983
				val = value;                                                                                                       // 6984
				// bi_buf |= (val << bi_valid);                                                                                    // 6985
				bi_buf |= ((val << bi_valid) & 0xffff);                                                                            // 6986
				put_short(bi_buf);                                                                                                 // 6987
				bi_buf = val >>> (Buf_size - bi_valid);                                                                            // 6988
				bi_valid += len - Buf_size;                                                                                        // 6989
			} else {                                                                                                            // 6990
				// bi_buf |= (value) << bi_valid;                                                                                  // 6991
				bi_buf |= (((value) << bi_valid) & 0xffff);                                                                        // 6992
				bi_valid += len;                                                                                                   // 6993
			}                                                                                                                   // 6994
		}                                                                                                                    // 6995
                                                                                                                       // 6996
		function send_code(c, tree) {                                                                                        // 6997
			var c2 = c * 2;                                                                                                     // 6998
			send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);                                                                // 6999
		}                                                                                                                    // 7000
                                                                                                                       // 7001
		// Send a literal or distance tree in compressed form, using the codes in                                            // 7002
		// bl_tree.                                                                                                          // 7003
		function send_tree(tree,// the tree to be sent                                                                       // 7004
		max_code // and its largest code of non zero frequency                                                               // 7005
		) {                                                                                                                  // 7006
			var n; // iterates over all tree elements                                                                           // 7007
			var prevlen = -1; // last emitted length                                                                            // 7008
			var curlen; // length of current code                                                                               // 7009
			var nextlen = tree[0 * 2 + 1]; // length of next code                                                               // 7010
			var count = 0; // repeat count of the current code                                                                  // 7011
			var max_count = 7; // max repeat count                                                                              // 7012
			var min_count = 4; // min repeat count                                                                              // 7013
                                                                                                                       // 7014
			if (nextlen === 0) {                                                                                                // 7015
				max_count = 138;                                                                                                   // 7016
				min_count = 3;                                                                                                     // 7017
			}                                                                                                                   // 7018
                                                                                                                       // 7019
			for (n = 0; n <= max_code; n++) {                                                                                   // 7020
				curlen = nextlen;                                                                                                  // 7021
				nextlen = tree[(n + 1) * 2 + 1];                                                                                   // 7022
				if (++count < max_count && curlen == nextlen) {                                                                    // 7023
					continue;                                                                                                         // 7024
				} else if (count < min_count) {                                                                                    // 7025
					do {                                                                                                              // 7026
						send_code(curlen, bl_tree);                                                                                      // 7027
					} while (--count !== 0);                                                                                          // 7028
				} else if (curlen !== 0) {                                                                                         // 7029
					if (curlen != prevlen) {                                                                                          // 7030
						send_code(curlen, bl_tree);                                                                                      // 7031
						count--;                                                                                                         // 7032
					}                                                                                                                 // 7033
					send_code(REP_3_6, bl_tree);                                                                                      // 7034
					send_bits(count - 3, 2);                                                                                          // 7035
				} else if (count <= 10) {                                                                                          // 7036
					send_code(REPZ_3_10, bl_tree);                                                                                    // 7037
					send_bits(count - 3, 3);                                                                                          // 7038
				} else {                                                                                                           // 7039
					send_code(REPZ_11_138, bl_tree);                                                                                  // 7040
					send_bits(count - 11, 7);                                                                                         // 7041
				}                                                                                                                  // 7042
				count = 0;                                                                                                         // 7043
				prevlen = curlen;                                                                                                  // 7044
				if (nextlen === 0) {                                                                                               // 7045
					max_count = 138;                                                                                                  // 7046
					min_count = 3;                                                                                                    // 7047
				} else if (curlen == nextlen) {                                                                                    // 7048
					max_count = 6;                                                                                                    // 7049
					min_count = 3;                                                                                                    // 7050
				} else {                                                                                                           // 7051
					max_count = 7;                                                                                                    // 7052
					min_count = 4;                                                                                                    // 7053
				}                                                                                                                  // 7054
			}                                                                                                                   // 7055
		}                                                                                                                    // 7056
                                                                                                                       // 7057
		// Send the header for a block using dynamic Huffman trees: the counts, the                                          // 7058
		// lengths of the bit length codes, the literal tree and the distance tree.                                          // 7059
		// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.                                                           // 7060
		function send_all_trees(lcodes, dcodes, blcodes) {                                                                   // 7061
			var rank; // index in bl_order                                                                                      // 7062
                                                                                                                       // 7063
			send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt                                                    // 7064
			send_bits(dcodes - 1, 5);                                                                                           // 7065
			send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt                                                       // 7066
			for (rank = 0; rank < blcodes; rank++) {                                                                            // 7067
				send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);                                                                // 7068
			}                                                                                                                   // 7069
			send_tree(dyn_ltree, lcodes - 1); // literal tree                                                                   // 7070
			send_tree(dyn_dtree, dcodes - 1); // distance tree                                                                  // 7071
		}                                                                                                                    // 7072
                                                                                                                       // 7073
		// Flush the bit buffer, keeping at most 7 bits in it.                                                               // 7074
		function bi_flush() {                                                                                                // 7075
			if (bi_valid == 16) {                                                                                               // 7076
				put_short(bi_buf);                                                                                                 // 7077
				bi_buf = 0;                                                                                                        // 7078
				bi_valid = 0;                                                                                                      // 7079
			} else if (bi_valid >= 8) {                                                                                         // 7080
				put_byte(bi_buf & 0xff);                                                                                           // 7081
				bi_buf >>>= 8;                                                                                                     // 7082
				bi_valid -= 8;                                                                                                     // 7083
			}                                                                                                                   // 7084
		}                                                                                                                    // 7085
                                                                                                                       // 7086
		// Send one empty static block to give enough lookahead for inflate.                                                 // 7087
		// This takes 10 bits, of which 7 may remain in the bit buffer.                                                      // 7088
		// The current inflate code requires 9 bits of lookahead. If the                                                     // 7089
		// last two codes for the previous block (real code plus EOB) were coded                                             // 7090
		// on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode                                          // 7091
		// the last real code. In this case we send two empty static blocks instead                                          // 7092
		// of one. (There are no problems if the previous block is stored or fixed.)                                         // 7093
		// To simplify the code, we assume the worst case of last real code encoded                                          // 7094
		// on one bit only.                                                                                                  // 7095
		function _tr_align() {                                                                                               // 7096
			send_bits(STATIC_TREES << 1, 3);                                                                                    // 7097
			send_code(END_BLOCK, StaticTree.static_ltree);                                                                      // 7098
                                                                                                                       // 7099
			bi_flush();                                                                                                         // 7100
                                                                                                                       // 7101
			// Of the 10 bits for the empty block, we have already sent                                                         // 7102
			// (10 - bi_valid) bits. The lookahead for the last real code (before                                               // 7103
			// the EOB of the previous block) was thus at least one plus the length                                             // 7104
			// of the EOB plus what we have just sent of the empty static block.                                                // 7105
			if (1 + last_eob_len + 10 - bi_valid < 9) {                                                                         // 7106
				send_bits(STATIC_TREES << 1, 3);                                                                                   // 7107
				send_code(END_BLOCK, StaticTree.static_ltree);                                                                     // 7108
				bi_flush();                                                                                                        // 7109
			}                                                                                                                   // 7110
			last_eob_len = 7;                                                                                                   // 7111
		}                                                                                                                    // 7112
                                                                                                                       // 7113
		// Save the match info and tally the frequency counts. Return true if                                                // 7114
		// the current block must be flushed.                                                                                // 7115
		function _tr_tally(dist, // distance of matched string                                                               // 7116
		lc // match length-MIN_MATCH or unmatched char (if dist==0)                                                          // 7117
		) {                                                                                                                  // 7118
			var out_length, in_length, dcode;                                                                                   // 7119
			that.pending_buf[d_buf + last_lit * 2] = (dist >>> 8) & 0xff;                                                       // 7120
			that.pending_buf[d_buf + last_lit * 2 + 1] = dist & 0xff;                                                           // 7121
                                                                                                                       // 7122
			that.pending_buf[l_buf + last_lit] = lc & 0xff;                                                                     // 7123
			last_lit++;                                                                                                         // 7124
                                                                                                                       // 7125
			if (dist === 0) {                                                                                                   // 7126
				// lc is the unmatched char                                                                                        // 7127
				dyn_ltree[lc * 2]++;                                                                                               // 7128
			} else {                                                                                                            // 7129
				matches++;                                                                                                         // 7130
				// Here, lc is the match length - MIN_MATCH                                                                        // 7131
				dist--; // dist = match distance - 1                                                                               // 7132
				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;                                                           // 7133
				dyn_dtree[Tree.d_code(dist) * 2]++;                                                                                // 7134
			}                                                                                                                   // 7135
                                                                                                                       // 7136
			if ((last_lit & 0x1fff) === 0 && level > 2) {                                                                       // 7137
				// Compute an upper bound for the compressed length                                                                // 7138
				out_length = last_lit * 8;                                                                                         // 7139
				in_length = strstart - block_start;                                                                                // 7140
				for (dcode = 0; dcode < D_CODES; dcode++) {                                                                        // 7141
					out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);                                               // 7142
				}                                                                                                                  // 7143
				out_length >>>= 3;                                                                                                 // 7144
				if ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))                                // 7145
					return true;                                                                                                      // 7146
			}                                                                                                                   // 7147
                                                                                                                       // 7148
			return (last_lit == lit_bufsize - 1);                                                                               // 7149
			// We avoid equality with lit_bufsize because of wraparound at 64K                                                  // 7150
			// on 16 bit machines and because stored blocks are restricted to                                                   // 7151
			// 64K-1 bytes.                                                                                                     // 7152
		}                                                                                                                    // 7153
                                                                                                                       // 7154
		// Send the block data compressed using the given Huffman trees                                                      // 7155
		function compress_block(ltree, dtree) {                                                                              // 7156
			var dist; // distance of matched string                                                                             // 7157
			var lc; // match length or unmatched char (if dist === 0)                                                           // 7158
			var lx = 0; // running index in l_buf                                                                               // 7159
			var code; // the code to send                                                                                       // 7160
			var extra; // number of extra bits to send                                                                          // 7161
                                                                                                                       // 7162
			if (last_lit !== 0) {                                                                                               // 7163
				do {                                                                                                               // 7164
					dist = ((that.pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (that.pending_buf[d_buf + lx * 2 + 1] & 0xff);        // 7165
					lc = (that.pending_buf[l_buf + lx]) & 0xff;                                                                       // 7166
					lx++;                                                                                                             // 7167
                                                                                                                       // 7168
					if (dist === 0) {                                                                                                 // 7169
						send_code(lc, ltree); // send a literal byte                                                                     // 7170
					} else {                                                                                                          // 7171
						// Here, lc is the match length - MIN_MATCH                                                                      // 7172
						code = Tree._length_code[lc];                                                                                    // 7173
                                                                                                                       // 7174
						send_code(code + LITERALS + 1, ltree); // send the length                                                        // 7175
						// code                                                                                                          // 7176
						extra = Tree.extra_lbits[code];                                                                                  // 7177
						if (extra !== 0) {                                                                                               // 7178
							lc -= Tree.base_length[code];                                                                                   // 7179
							send_bits(lc, extra); // send the extra length bits                                                             // 7180
						}                                                                                                                // 7181
						dist--; // dist is now the match distance - 1                                                                    // 7182
						code = Tree.d_code(dist);                                                                                        // 7183
                                                                                                                       // 7184
						send_code(code, dtree); // send the distance code                                                                // 7185
						extra = Tree.extra_dbits[code];                                                                                  // 7186
						if (extra !== 0) {                                                                                               // 7187
							dist -= Tree.base_dist[code];                                                                                   // 7188
							send_bits(dist, extra); // send the extra distance bits                                                         // 7189
						}                                                                                                                // 7190
					} // literal or match pair ?                                                                                      // 7191
                                                                                                                       // 7192
					// Check that the overlay between pending_buf and d_buf+l_buf is                                                  // 7193
					// ok:                                                                                                            // 7194
				} while (lx < last_lit);                                                                                           // 7195
			}                                                                                                                   // 7196
                                                                                                                       // 7197
			send_code(END_BLOCK, ltree);                                                                                        // 7198
			last_eob_len = ltree[END_BLOCK * 2 + 1];                                                                            // 7199
		}                                                                                                                    // 7200
                                                                                                                       // 7201
		// Flush the bit buffer and align the output on a byte boundary                                                      // 7202
		function bi_windup() {                                                                                               // 7203
			if (bi_valid > 8) {                                                                                                 // 7204
				put_short(bi_buf);                                                                                                 // 7205
			} else if (bi_valid > 0) {                                                                                          // 7206
				put_byte(bi_buf & 0xff);                                                                                           // 7207
			}                                                                                                                   // 7208
			bi_buf = 0;                                                                                                         // 7209
			bi_valid = 0;                                                                                                       // 7210
		}                                                                                                                    // 7211
                                                                                                                       // 7212
		// Copy a stored block, storing first the length and its                                                             // 7213
		// one's complement if requested.                                                                                    // 7214
		function copy_block(buf, // the input data                                                                           // 7215
		len, // its length                                                                                                   // 7216
		header // true if block header must be written                                                                       // 7217
		) {                                                                                                                  // 7218
			bi_windup(); // align on byte boundary                                                                              // 7219
			last_eob_len = 8; // enough lookahead for inflate                                                                   // 7220
                                                                                                                       // 7221
			if (header) {                                                                                                       // 7222
				put_short(len);                                                                                                    // 7223
				put_short(~len);                                                                                                   // 7224
			}                                                                                                                   // 7225
                                                                                                                       // 7226
			that.pending_buf.set(window.subarray(buf, buf + len), that.pending);                                                // 7227
			that.pending += len;                                                                                                // 7228
		}                                                                                                                    // 7229
                                                                                                                       // 7230
		// Send a stored block                                                                                               // 7231
		function _tr_stored_block(buf, // input block                                                                        // 7232
		stored_len, // length of input block                                                                                 // 7233
		eof // true if this is the last block for a file                                                                     // 7234
		) {                                                                                                                  // 7235
			send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type                                               // 7236
			copy_block(buf, stored_len, true); // with header                                                                   // 7237
		}                                                                                                                    // 7238
                                                                                                                       // 7239
		// Determine the best encoding for the current block: dynamic trees, static                                          // 7240
		// trees or store, and output the encoded block to the zip file.                                                     // 7241
		function _tr_flush_block(buf, // input block, or NULL if too old                                                     // 7242
		stored_len, // length of input block                                                                                 // 7243
		eof // true if this is the last block for a file                                                                     // 7244
		) {                                                                                                                  // 7245
			var opt_lenb, static_lenb;// opt_len and static_len in bytes                                                        // 7246
			var max_blindex = 0; // index of last bit length code of non zero freq                                              // 7247
                                                                                                                       // 7248
			// Build the Huffman trees unless a stored block is forced                                                          // 7249
			if (level > 0) {                                                                                                    // 7250
				// Construct the literal and distance trees                                                                        // 7251
				l_desc.build_tree(that);                                                                                           // 7252
                                                                                                                       // 7253
				d_desc.build_tree(that);                                                                                           // 7254
                                                                                                                       // 7255
				// At this point, opt_len and static_len are the total bit lengths                                                 // 7256
				// of                                                                                                              // 7257
				// the compressed block data, excluding the tree representations.                                                  // 7258
                                                                                                                       // 7259
				// Build the bit length tree for the above two trees, and get the                                                  // 7260
				// index                                                                                                           // 7261
				// in bl_order of the last bit length code to send.                                                                // 7262
				max_blindex = build_bl_tree();                                                                                     // 7263
                                                                                                                       // 7264
				// Determine the best encoding. Compute first the block length in                                                  // 7265
				// bytes                                                                                                           // 7266
				opt_lenb = (that.opt_len + 3 + 7) >>> 3;                                                                           // 7267
				static_lenb = (that.static_len + 3 + 7) >>> 3;                                                                     // 7268
                                                                                                                       // 7269
				if (static_lenb <= opt_lenb)                                                                                       // 7270
					opt_lenb = static_lenb;                                                                                           // 7271
			} else {                                                                                                            // 7272
				opt_lenb = static_lenb = stored_len + 5; // force a stored block                                                   // 7273
			}                                                                                                                   // 7274
                                                                                                                       // 7275
			if ((stored_len + 4 <= opt_lenb) && buf != -1) {                                                                    // 7276
				// 4: two words for the lengths                                                                                    // 7277
				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                                                  // 7278
				// Otherwise we can't have processed more than WSIZE input bytes                                                   // 7279
				// since                                                                                                           // 7280
				// the last block flush, because compression would have been                                                       // 7281
				// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to                                                    // 7282
				// transform a block into a stored block.                                                                          // 7283
				_tr_stored_block(buf, stored_len, eof);                                                                            // 7284
			} else if (static_lenb == opt_lenb) {                                                                               // 7285
				send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);                                                                 // 7286
				compress_block(StaticTree.static_ltree, StaticTree.static_dtree);                                                  // 7287
			} else {                                                                                                            // 7288
				send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);                                                                    // 7289
				send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);                                         // 7290
				compress_block(dyn_ltree, dyn_dtree);                                                                              // 7291
			}                                                                                                                   // 7292
                                                                                                                       // 7293
			// The above check is made mod 2^32, for files larger than 512 MB                                                   // 7294
			// and uLong implemented on 32 bits.                                                                                // 7295
                                                                                                                       // 7296
			init_block();                                                                                                       // 7297
                                                                                                                       // 7298
			if (eof) {                                                                                                          // 7299
				bi_windup();                                                                                                       // 7300
			}                                                                                                                   // 7301
		}                                                                                                                    // 7302
                                                                                                                       // 7303
		function flush_block_only(eof) {                                                                                     // 7304
			_tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);                                  // 7305
			block_start = strstart;                                                                                             // 7306
			strm.flush_pending();                                                                                               // 7307
		}                                                                                                                    // 7308
                                                                                                                       // 7309
		// Fill the window when the lookahead becomes insufficient.                                                          // 7310
		// Updates strstart and lookahead.                                                                                   // 7311
		//                                                                                                                   // 7312
		// IN assertion: lookahead < MIN_LOOKAHEAD                                                                           // 7313
		// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD                                                             // 7314
		// At least one byte has been read, or avail_in === 0; reads are                                                     // 7315
		// performed for at least two bytes (required for the zip translate_eol                                              // 7316
		// option -- not supported here).                                                                                    // 7317
		function fill_window() {                                                                                             // 7318
			var n, m;                                                                                                           // 7319
			var p;                                                                                                              // 7320
			var more; // Amount of free space at the end of the window.                                                         // 7321
                                                                                                                       // 7322
			do {                                                                                                                // 7323
				more = (window_size - lookahead - strstart);                                                                       // 7324
                                                                                                                       // 7325
				// Deal with !@#$% 64K limit:                                                                                      // 7326
				if (more === 0 && strstart === 0 && lookahead === 0) {                                                             // 7327
					more = w_size;                                                                                                    // 7328
				} else if (more == -1) {                                                                                           // 7329
					// Very unlikely, but possible on 16 bit machine if strstart ==                                                   // 7330
					// 0                                                                                                              // 7331
					// and lookahead == 1 (input done one byte at time)                                                               // 7332
					more--;                                                                                                           // 7333
                                                                                                                       // 7334
					// If the window is almost full and there is insufficient                                                         // 7335
					// lookahead,                                                                                                     // 7336
					// move the upper half to the lower one to make room in the                                                       // 7337
					// upper half.                                                                                                    // 7338
				} else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {                                                          // 7339
					window.set(window.subarray(w_size, w_size + w_size), 0);                                                          // 7340
                                                                                                                       // 7341
					match_start -= w_size;                                                                                            // 7342
					strstart -= w_size; // we now have strstart >= MAX_DIST                                                           // 7343
					block_start -= w_size;                                                                                            // 7344
                                                                                                                       // 7345
					// Slide the hash table (could be avoided with 32 bit values                                                      // 7346
					// at the expense of memory usage). We slide even when level ==                                                   // 7347
					// 0                                                                                                              // 7348
					// to keep the hash table consistent if we switch back to level                                                   // 7349
					// > 0                                                                                                            // 7350
					// later. (Using level 0 permanently is not an optimal usage of                                                   // 7351
					// zlib, so we don't care about this pathological case.)                                                          // 7352
                                                                                                                       // 7353
					n = hash_size;                                                                                                    // 7354
					p = n;                                                                                                            // 7355
					do {                                                                                                              // 7356
						m = (head[--p] & 0xffff);                                                                                        // 7357
						head[p] = (m >= w_size ? m - w_size : 0);                                                                        // 7358
					} while (--n !== 0);                                                                                              // 7359
                                                                                                                       // 7360
					n = w_size;                                                                                                       // 7361
					p = n;                                                                                                            // 7362
					do {                                                                                                              // 7363
						m = (prev[--p] & 0xffff);                                                                                        // 7364
						prev[p] = (m >= w_size ? m - w_size : 0);                                                                        // 7365
						// If n is not on any hash chain, prev[n] is garbage but                                                         // 7366
						// its value will never be used.                                                                                 // 7367
					} while (--n !== 0);                                                                                              // 7368
					more += w_size;                                                                                                   // 7369
				}                                                                                                                  // 7370
                                                                                                                       // 7371
				if (strm.avail_in === 0)                                                                                           // 7372
					return;                                                                                                           // 7373
                                                                                                                       // 7374
				// If there was no sliding:                                                                                        // 7375
				// strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&                                               // 7376
				// more == window_size - lookahead - strstart                                                                      // 7377
				// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)                                                 // 7378
				// => more >= window_size - 2*WSIZE + 2                                                                            // 7379
				// In the BIG_MEM or MMAP case (not yet supported),                                                                // 7380
				// window_size == input_size + MIN_LOOKAHEAD &&                                                                    // 7381
				// strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.                                                 // 7382
				// Otherwise, window_size == 2*WSIZE so more >= 2.                                                                 // 7383
				// If there was sliding, more >= WSIZE. So in all cases, more >= 2.                                                // 7384
                                                                                                                       // 7385
				n = strm.read_buf(window, strstart + lookahead, more);                                                             // 7386
				lookahead += n;                                                                                                    // 7387
                                                                                                                       // 7388
				// Initialize the hash value now that we have some input:                                                          // 7389
				if (lookahead >= MIN_MATCH) {                                                                                      // 7390
					ins_h = window[strstart] & 0xff;                                                                                  // 7391
					ins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;                                    // 7392
				}                                                                                                                  // 7393
				// If the whole input has less than MIN_MATCH bytes, ins_h is                                                      // 7394
				// garbage,                                                                                                        // 7395
				// but this is not important since only literal bytes will be                                                      // 7396
				// emitted.                                                                                                        // 7397
			} while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);                                                         // 7398
		}                                                                                                                    // 7399
                                                                                                                       // 7400
		// Copy without compression as much as possible from the input stream,                                               // 7401
		// return                                                                                                            // 7402
		// the current block state.                                                                                          // 7403
		// This function does not insert new strings in the dictionary since                                                 // 7404
		// uncompressible data is probably not useful. This function is used                                                 // 7405
		// only for the level=0 compression option.                                                                          // 7406
		// NOTE: this function should be optimized to avoid extra copying from                                               // 7407
		// window to pending_buf.                                                                                            // 7408
		function deflate_stored(flush) {                                                                                     // 7409
			// Stored blocks are limited to 0xffff bytes, pending_buf is limited                                                // 7410
			// to pending_buf_size, and each stored block has a 5 byte header:                                                  // 7411
                                                                                                                       // 7412
			var max_block_size = 0xffff;                                                                                        // 7413
			var max_start;                                                                                                      // 7414
                                                                                                                       // 7415
			if (max_block_size > pending_buf_size - 5) {                                                                        // 7416
				max_block_size = pending_buf_size - 5;                                                                             // 7417
			}                                                                                                                   // 7418
                                                                                                                       // 7419
			// Copy as much as possible from input to output:                                                                   // 7420
			while (true) {                                                                                                      // 7421
				// Fill the window as much as possible:                                                                            // 7422
				if (lookahead <= 1) {                                                                                              // 7423
					fill_window();                                                                                                    // 7424
					if (lookahead === 0 && flush == Z_NO_FLUSH)                                                                       // 7425
						return NeedMore;                                                                                                 // 7426
					if (lookahead === 0)                                                                                              // 7427
						break; // flush the current block                                                                                // 7428
				}                                                                                                                  // 7429
                                                                                                                       // 7430
				strstart += lookahead;                                                                                             // 7431
				lookahead = 0;                                                                                                     // 7432
                                                                                                                       // 7433
				// Emit a stored block if pending_buf will be full:                                                                // 7434
				max_start = block_start + max_block_size;                                                                          // 7435
				if (strstart === 0 || strstart >= max_start) {                                                                     // 7436
					// strstart === 0 is possible when wraparound on 16-bit machine                                                   // 7437
					lookahead = (strstart - max_start);                                                                               // 7438
					strstart = max_start;                                                                                             // 7439
                                                                                                                       // 7440
					flush_block_only(false);                                                                                          // 7441
					if (strm.avail_out === 0)                                                                                         // 7442
						return NeedMore;                                                                                                 // 7443
                                                                                                                       // 7444
				}                                                                                                                  // 7445
                                                                                                                       // 7446
				// Flush if we may have to slide, otherwise block_start may become                                                 // 7447
				// negative and the data will be gone:                                                                             // 7448
				if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {                                                            // 7449
					flush_block_only(false);                                                                                          // 7450
					if (strm.avail_out === 0)                                                                                         // 7451
						return NeedMore;                                                                                                 // 7452
				}                                                                                                                  // 7453
			}                                                                                                                   // 7454
                                                                                                                       // 7455
			flush_block_only(flush == Z_FINISH);                                                                                // 7456
			if (strm.avail_out === 0)                                                                                           // 7457
				return (flush == Z_FINISH) ? FinishStarted : NeedMore;                                                             // 7458
                                                                                                                       // 7459
			return flush == Z_FINISH ? FinishDone : BlockDone;                                                                  // 7460
		}                                                                                                                    // 7461
                                                                                                                       // 7462
		function longest_match(cur_match) {                                                                                  // 7463
			var chain_length = max_chain_length; // max hash chain length                                                       // 7464
			var scan = strstart; // current string                                                                              // 7465
			var match; // matched string                                                                                        // 7466
			var len; // length of current match                                                                                 // 7467
			var best_len = prev_length; // best match length so far                                                             // 7468
			var limit = strstart > (w_size - MIN_LOOKAHEAD) ? strstart - (w_size - MIN_LOOKAHEAD) : 0;                          // 7469
			var _nice_match = nice_match;                                                                                       // 7470
                                                                                                                       // 7471
			// Stop when cur_match becomes <= limit. To simplify the code,                                                      // 7472
			// we prevent matches with the string of window index 0.                                                            // 7473
                                                                                                                       // 7474
			var wmask = w_mask;                                                                                                 // 7475
                                                                                                                       // 7476
			var strend = strstart + MAX_MATCH;                                                                                  // 7477
			var scan_end1 = window[scan + best_len - 1];                                                                        // 7478
			var scan_end = window[scan + best_len];                                                                             // 7479
                                                                                                                       // 7480
			// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of                                             // 7481
			// 16.                                                                                                              // 7482
			// It is easy to get rid of this optimization if necessary.                                                         // 7483
                                                                                                                       // 7484
			// Do not waste too much time if we already have a good match:                                                      // 7485
			if (prev_length >= good_match) {                                                                                    // 7486
				chain_length >>= 2;                                                                                                // 7487
			}                                                                                                                   // 7488
                                                                                                                       // 7489
			// Do not look for matches beyond the end of the input. This is                                                     // 7490
			// necessary                                                                                                        // 7491
			// to make deflate deterministic.                                                                                   // 7492
			if (_nice_match > lookahead)                                                                                        // 7493
				_nice_match = lookahead;                                                                                           // 7494
                                                                                                                       // 7495
			do {                                                                                                                // 7496
				match = cur_match;                                                                                                 // 7497
                                                                                                                       // 7498
				// Skip to next match if the match length cannot increase                                                          // 7499
				// or if the match length is less than 2:                                                                          // 7500
				if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan]
						|| window[++match] != window[scan + 1])                                                                          // 7502
					continue;                                                                                                         // 7503
                                                                                                                       // 7504
				// The check at best_len-1 can be removed because it will be made                                                  // 7505
				// again later. (This heuristic is not always a win.)                                                              // 7506
				// It is not necessary to compare scan[2] and match[2] since they                                                  // 7507
				// are always equal when the other bytes match, given that                                                         // 7508
				// the hash keys are equal and that HASH_BITS >= 8.                                                                // 7509
				scan += 2;                                                                                                         // 7510
				match++;                                                                                                           // 7511
                                                                                                                       // 7512
				// We check for insufficient lookahead only every 8th comparison;                                                  // 7513
				// the 256th check will be made at strstart+258.                                                                   // 7514
				do {                                                                                                               // 7515
				} while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]
						&& window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]   // 7517
						&& window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);                     // 7518
                                                                                                                       // 7519
				len = MAX_MATCH - (strend - scan);                                                                                 // 7520
				scan = strend - MAX_MATCH;                                                                                         // 7521
                                                                                                                       // 7522
				if (len > best_len) {                                                                                              // 7523
					match_start = cur_match;                                                                                          // 7524
					best_len = len;                                                                                                   // 7525
					if (len >= _nice_match)                                                                                           // 7526
						break;                                                                                                           // 7527
					scan_end1 = window[scan + best_len - 1];                                                                          // 7528
					scan_end = window[scan + best_len];                                                                               // 7529
				}                                                                                                                  // 7530
                                                                                                                       // 7531
			} while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);                         // 7532
                                                                                                                       // 7533
			if (best_len <= lookahead)                                                                                          // 7534
				return best_len;                                                                                                   // 7535
			return lookahead;                                                                                                   // 7536
		}                                                                                                                    // 7537
                                                                                                                       // 7538
		// Compress as much as possible from the input stream, return the current                                            // 7539
		// block state.                                                                                                      // 7540
		// This function does not perform lazy evaluation of matches and inserts                                             // 7541
		// new strings in the dictionary only for unmatched strings or for short                                             // 7542
		// matches. It is used only for the fast compression options.                                                        // 7543
		function deflate_fast(flush) {                                                                                       // 7544
			// short hash_head = 0; // head of the hash chain                                                                   // 7545
			var hash_head = 0; // head of the hash chain                                                                        // 7546
			var bflush; // set if current block must be flushed                                                                 // 7547
                                                                                                                       // 7548
			while (true) {                                                                                                      // 7549
				// Make sure that we always have enough lookahead, except                                                          // 7550
				// at the end of the input file. We need MAX_MATCH bytes                                                           // 7551
				// for the next match, plus MIN_MATCH bytes to insert the                                                          // 7552
				// string following the next match.                                                                                // 7553
				if (lookahead < MIN_LOOKAHEAD) {                                                                                   // 7554
					fill_window();                                                                                                    // 7555
					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {                                                           // 7556
						return NeedMore;                                                                                                 // 7557
					}                                                                                                                 // 7558
					if (lookahead === 0)                                                                                              // 7559
						break; // flush the current block                                                                                // 7560
				}                                                                                                                  // 7561
                                                                                                                       // 7562
				// Insert the string window[strstart .. strstart+2] in the                                                         // 7563
				// dictionary, and set hash_head to the head of the hash chain:                                                    // 7564
				if (lookahead >= MIN_MATCH) {                                                                                      // 7565
					ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                    // 7566
                                                                                                                       // 7567
					// prev[strstart&w_mask]=hash_head=head[ins_h];                                                                   // 7568
					hash_head = (head[ins_h] & 0xffff);                                                                               // 7569
					prev[strstart & w_mask] = head[ins_h];                                                                            // 7570
					head[ins_h] = strstart;                                                                                           // 7571
				}                                                                                                                  // 7572
                                                                                                                       // 7573
				// Find the longest match, discarding those <= prev_length.                                                        // 7574
				// At this point we have always match_length < MIN_MATCH                                                           // 7575
                                                                                                                       // 7576
				if (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {                              // 7577
					// To simplify the code, we prevent matches with the string                                                       // 7578
					// of window index 0 (in particular we have to avoid a match                                                      // 7579
					// of the string with itself at the start of the input file).                                                     // 7580
					if (strategy != Z_HUFFMAN_ONLY) {                                                                                 // 7581
						match_length = longest_match(hash_head);                                                                         // 7582
					}                                                                                                                 // 7583
					// longest_match() sets match_start                                                                               // 7584
				}                                                                                                                  // 7585
				if (match_length >= MIN_MATCH) {                                                                                   // 7586
					// check_match(strstart, match_start, match_length);                                                              // 7587
                                                                                                                       // 7588
					bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);                                             // 7589
                                                                                                                       // 7590
					lookahead -= match_length;                                                                                        // 7591
                                                                                                                       // 7592
					// Insert new strings in the hash table only if the match length                                                  // 7593
					// is not too large. This saves time but degrades compression.                                                    // 7594
					if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {                                                   // 7595
						match_length--; // string at strstart already in hash table                                                      // 7596
						do {                                                                                                             // 7597
							strstart++;                                                                                                     // 7598
                                                                                                                       // 7599
							ins_h = ((ins_h << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                    // 7600
							// prev[strstart&w_mask]=hash_head=head[ins_h];                                                                 // 7601
							hash_head = (head[ins_h] & 0xffff);                                                                             // 7602
							prev[strstart & w_mask] = head[ins_h];                                                                          // 7603
							head[ins_h] = strstart;                                                                                         // 7604
                                                                                                                       // 7605
							// strstart never exceeds WSIZE-MAX_MATCH, so there are                                                         // 7606
							// always MIN_MATCH bytes ahead.                                                                                // 7607
						} while (--match_length !== 0);                                                                                  // 7608
						strstart++;                                                                                                      // 7609
					} else {                                                                                                          // 7610
						strstart += match_length;                                                                                        // 7611
						match_length = 0;                                                                                                // 7612
						ins_h = window[strstart] & 0xff;                                                                                 // 7613
                                                                                                                       // 7614
						ins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;                                   // 7615
						// If lookahead < MIN_MATCH, ins_h is garbage, but it does                                                       // 7616
						// not                                                                                                           // 7617
						// matter since it will be recomputed at next deflate call.                                                      // 7618
					}                                                                                                                 // 7619
				} else {                                                                                                           // 7620
					// No match, output a literal byte                                                                                // 7621
                                                                                                                       // 7622
					bflush = _tr_tally(0, window[strstart] & 0xff);                                                                   // 7623
					lookahead--;                                                                                                      // 7624
					strstart++;                                                                                                       // 7625
				}                                                                                                                  // 7626
				if (bflush) {                                                                                                      // 7627
                                                                                                                       // 7628
					flush_block_only(false);                                                                                          // 7629
					if (strm.avail_out === 0)                                                                                         // 7630
						return NeedMore;                                                                                                 // 7631
				}                                                                                                                  // 7632
			}                                                                                                                   // 7633
                                                                                                                       // 7634
			flush_block_only(flush == Z_FINISH);                                                                                // 7635
			if (strm.avail_out === 0) {                                                                                         // 7636
				if (flush == Z_FINISH)                                                                                             // 7637
					return FinishStarted;                                                                                             // 7638
				else                                                                                                               // 7639
					return NeedMore;                                                                                                  // 7640
			}                                                                                                                   // 7641
			return flush == Z_FINISH ? FinishDone : BlockDone;                                                                  // 7642
		}                                                                                                                    // 7643
                                                                                                                       // 7644
		// Same as above, but achieves better compression. We use a lazy                                                     // 7645
		// evaluation for matches: a match is finally adopted only if there is                                               // 7646
		// no better match at the next window position.                                                                      // 7647
		function deflate_slow(flush) {                                                                                       // 7648
			// short hash_head = 0; // head of hash chain                                                                       // 7649
			var hash_head = 0; // head of hash chain                                                                            // 7650
			var bflush; // set if current block must be flushed                                                                 // 7651
			var max_insert;                                                                                                     // 7652
                                                                                                                       // 7653
			// Process the input block.                                                                                         // 7654
			while (true) {                                                                                                      // 7655
				// Make sure that we always have enough lookahead, except                                                          // 7656
				// at the end of the input file. We need MAX_MATCH bytes                                                           // 7657
				// for the next match, plus MIN_MATCH bytes to insert the                                                          // 7658
				// string following the next match.                                                                                // 7659
                                                                                                                       // 7660
				if (lookahead < MIN_LOOKAHEAD) {                                                                                   // 7661
					fill_window();                                                                                                    // 7662
					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {                                                           // 7663
						return NeedMore;                                                                                                 // 7664
					}                                                                                                                 // 7665
					if (lookahead === 0)                                                                                              // 7666
						break; // flush the current block                                                                                // 7667
				}                                                                                                                  // 7668
                                                                                                                       // 7669
				// Insert the string window[strstart .. strstart+2] in the                                                         // 7670
				// dictionary, and set hash_head to the head of the hash chain:                                                    // 7671
                                                                                                                       // 7672
				if (lookahead >= MIN_MATCH) {                                                                                      // 7673
					ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                    // 7674
					// prev[strstart&w_mask]=hash_head=head[ins_h];                                                                   // 7675
					hash_head = (head[ins_h] & 0xffff);                                                                               // 7676
					prev[strstart & w_mask] = head[ins_h];                                                                            // 7677
					head[ins_h] = strstart;                                                                                           // 7678
				}                                                                                                                  // 7679
                                                                                                                       // 7680
				// Find the longest match, discarding those <= prev_length.                                                        // 7681
				prev_length = match_length;                                                                                        // 7682
				prev_match = match_start;                                                                                          // 7683
				match_length = MIN_MATCH - 1;                                                                                      // 7684
                                                                                                                       // 7685
				if (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {
					// To simplify the code, we prevent matches with the string                                                       // 7687
					// of window index 0 (in particular we have to avoid a match                                                      // 7688
					// of the string with itself at the start of the input file).                                                     // 7689
                                                                                                                       // 7690
					if (strategy != Z_HUFFMAN_ONLY) {                                                                                 // 7691
						match_length = longest_match(hash_head);                                                                         // 7692
					}                                                                                                                 // 7693
					// longest_match() sets match_start                                                                               // 7694
                                                                                                                       // 7695
					if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {
                                                                                                                       // 7697
						// If prev_match is also MIN_MATCH, match_start is garbage                                                       // 7698
						// but we will ignore the current match anyway.                                                                  // 7699
						match_length = MIN_MATCH - 1;                                                                                    // 7700
					}                                                                                                                 // 7701
				}                                                                                                                  // 7702
                                                                                                                       // 7703
				// If there was a match at the previous step and the current                                                       // 7704
				// match is not better, output the previous match:                                                                 // 7705
				if (prev_length >= MIN_MATCH && match_length <= prev_length) {                                                     // 7706
					max_insert = strstart + lookahead - MIN_MATCH;                                                                    // 7707
					// Do not insert strings in hash table beyond this.                                                               // 7708
                                                                                                                       // 7709
					// check_match(strstart-1, prev_match, prev_length);                                                              // 7710
                                                                                                                       // 7711
					bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);                                           // 7712
                                                                                                                       // 7713
					// Insert in hash table all strings up to the end of the match.                                                   // 7714
					// strstart-1 and strstart are already inserted. If there is not                                                  // 7715
					// enough lookahead, the last two strings are not inserted in                                                     // 7716
					// the hash table.                                                                                                // 7717
					lookahead -= prev_length - 1;                                                                                     // 7718
					prev_length -= 2;                                                                                                 // 7719
					do {                                                                                                              // 7720
						if (++strstart <= max_insert) {                                                                                  // 7721
							ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                  // 7722
							// prev[strstart&w_mask]=hash_head=head[ins_h];                                                                 // 7723
							hash_head = (head[ins_h] & 0xffff);                                                                             // 7724
							prev[strstart & w_mask] = head[ins_h];                                                                          // 7725
							head[ins_h] = strstart;                                                                                         // 7726
						}                                                                                                                // 7727
					} while (--prev_length !== 0);                                                                                    // 7728
					match_available = 0;                                                                                              // 7729
					match_length = MIN_MATCH - 1;                                                                                     // 7730
					strstart++;                                                                                                       // 7731
                                                                                                                       // 7732
					if (bflush) {                                                                                                     // 7733
						flush_block_only(false);                                                                                         // 7734
						if (strm.avail_out === 0)                                                                                        // 7735
							return NeedMore;                                                                                                // 7736
					}                                                                                                                 // 7737
				} else if (match_available !== 0) {                                                                                // 7738
                                                                                                                       // 7739
					// If there was no match at the previous position, output a                                                       // 7740
					// single literal. If there was a match but the current match                                                     // 7741
					// is longer, truncate the previous match to a single literal.                                                    // 7742
                                                                                                                       // 7743
					bflush = _tr_tally(0, window[strstart - 1] & 0xff);                                                               // 7744
                                                                                                                       // 7745
					if (bflush) {                                                                                                     // 7746
						flush_block_only(false);                                                                                         // 7747
					}                                                                                                                 // 7748
					strstart++;                                                                                                       // 7749
					lookahead--;                                                                                                      // 7750
					if (strm.avail_out === 0)                                                                                         // 7751
						return NeedMore;                                                                                                 // 7752
				} else {                                                                                                           // 7753
					// There is no previous match to compare with, wait for                                                           // 7754
					// the next step to decide.                                                                                       // 7755
                                                                                                                       // 7756
					match_available = 1;                                                                                              // 7757
					strstart++;                                                                                                       // 7758
					lookahead--;                                                                                                      // 7759
				}                                                                                                                  // 7760
			}                                                                                                                   // 7761
                                                                                                                       // 7762
			if (match_available !== 0) {                                                                                        // 7763
				bflush = _tr_tally(0, window[strstart - 1] & 0xff);                                                                // 7764
				match_available = 0;                                                                                               // 7765
			}                                                                                                                   // 7766
			flush_block_only(flush == Z_FINISH);                                                                                // 7767
                                                                                                                       // 7768
			if (strm.avail_out === 0) {                                                                                         // 7769
				if (flush == Z_FINISH)                                                                                             // 7770
					return FinishStarted;                                                                                             // 7771
				else                                                                                                               // 7772
					return NeedMore;                                                                                                  // 7773
			}                                                                                                                   // 7774
                                                                                                                       // 7775
			return flush == Z_FINISH ? FinishDone : BlockDone;                                                                  // 7776
		}                                                                                                                    // 7777
                                                                                                                       // 7778
		function deflateReset(strm) {                                                                                        // 7779
			strm.total_in = strm.total_out = 0;                                                                                 // 7780
			strm.msg = null; //                                                                                                 // 7781
			                                                                                                                    // 7782
			that.pending = 0;                                                                                                   // 7783
			that.pending_out = 0;                                                                                               // 7784
                                                                                                                       // 7785
			status = BUSY_STATE;                                                                                                // 7786
                                                                                                                       // 7787
			last_flush = Z_NO_FLUSH;                                                                                            // 7788
                                                                                                                       // 7789
			tr_init();                                                                                                          // 7790
			lm_init();                                                                                                          // 7791
			return Z_OK;                                                                                                        // 7792
		}                                                                                                                    // 7793
                                                                                                                       // 7794
		that.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {                                      // 7795
			if (!_method)                                                                                                       // 7796
				_method = Z_DEFLATED;                                                                                              // 7797
			if (!memLevel)                                                                                                      // 7798
				memLevel = DEF_MEM_LEVEL;                                                                                          // 7799
			if (!_strategy)                                                                                                     // 7800
				_strategy = Z_DEFAULT_STRATEGY;                                                                                    // 7801
                                                                                                                       // 7802
			// byte[] my_version=ZLIB_VERSION;                                                                                  // 7803
                                                                                                                       // 7804
			//                                                                                                                  // 7805
			// if (!version || version[0] != my_version[0]                                                                      // 7806
			// || stream_size != sizeof(z_stream)) {                                                                            // 7807
			// return Z_VERSION_ERROR;                                                                                          // 7808
			// }                                                                                                                // 7809
                                                                                                                       // 7810
			strm.msg = null;                                                                                                    // 7811
                                                                                                                       // 7812
			if (_level == Z_DEFAULT_COMPRESSION)                                                                                // 7813
				_level = 6;                                                                                                        // 7814
                                                                                                                       // 7815
			if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0
					|| _strategy > Z_HUFFMAN_ONLY) {                                                                                  // 7817
				return Z_STREAM_ERROR;                                                                                             // 7818
			}                                                                                                                   // 7819
                                                                                                                       // 7820
			strm.dstate = that;                                                                                                 // 7821
                                                                                                                       // 7822
			w_bits = bits;                                                                                                      // 7823
			w_size = 1 << w_bits;                                                                                               // 7824
			w_mask = w_size - 1;                                                                                                // 7825
                                                                                                                       // 7826
			hash_bits = memLevel + 7;                                                                                           // 7827
			hash_size = 1 << hash_bits;                                                                                         // 7828
			hash_mask = hash_size - 1;                                                                                          // 7829
			hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);                                                   // 7830
                                                                                                                       // 7831
			window = new Uint8Array(w_size * 2);                                                                                // 7832
			prev = [];                                                                                                          // 7833
			head = [];                                                                                                          // 7834
                                                                                                                       // 7835
			lit_bufsize = 1 << (memLevel + 6); // 16K elements by default                                                       // 7836
                                                                                                                       // 7837
			// We overlay pending_buf and d_buf+l_buf. This works since the average                                             // 7838
			// output size for (length,distance) codes is <= 24 bits.                                                           // 7839
			that.pending_buf = new Uint8Array(lit_bufsize * 4);                                                                 // 7840
			pending_buf_size = lit_bufsize * 4;                                                                                 // 7841
                                                                                                                       // 7842
			d_buf = Math.floor(lit_bufsize / 2);                                                                                // 7843
			l_buf = (1 + 2) * lit_bufsize;                                                                                      // 7844
                                                                                                                       // 7845
			level = _level;                                                                                                     // 7846
                                                                                                                       // 7847
			strategy = _strategy;                                                                                               // 7848
			method = _method & 0xff;                                                                                            // 7849
                                                                                                                       // 7850
			return deflateReset(strm);                                                                                          // 7851
		};                                                                                                                   // 7852
                                                                                                                       // 7853
		that.deflateEnd = function() {                                                                                       // 7854
			if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {                                       // 7855
				return Z_STREAM_ERROR;                                                                                             // 7856
			}                                                                                                                   // 7857
			// Deallocate in reverse order of allocations:                                                                      // 7858
			that.pending_buf = null;                                                                                            // 7859
			head = null;                                                                                                        // 7860
			prev = null;                                                                                                        // 7861
			window = null;                                                                                                      // 7862
			// free                                                                                                             // 7863
			that.dstate = null;                                                                                                 // 7864
			return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;                                                                  // 7865
		};                                                                                                                   // 7866
                                                                                                                       // 7867
		that.deflateParams = function(strm, _level, _strategy) {                                                             // 7868
			var err = Z_OK;                                                                                                     // 7869
                                                                                                                       // 7870
			if (_level == Z_DEFAULT_COMPRESSION) {                                                                              // 7871
				_level = 6;                                                                                                        // 7872
			}                                                                                                                   // 7873
			if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {                                      // 7874
				return Z_STREAM_ERROR;                                                                                             // 7875
			}                                                                                                                   // 7876
                                                                                                                       // 7877
			if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {                                 // 7878
				// Flush the last buffer:                                                                                          // 7879
				err = strm.deflate(Z_PARTIAL_FLUSH);                                                                               // 7880
			}                                                                                                                   // 7881
                                                                                                                       // 7882
			if (level != _level) {                                                                                              // 7883
				level = _level;                                                                                                    // 7884
				max_lazy_match = config_table[level].max_lazy;                                                                     // 7885
				good_match = config_table[level].good_length;                                                                      // 7886
				nice_match = config_table[level].nice_length;                                                                      // 7887
				max_chain_length = config_table[level].max_chain;                                                                  // 7888
			}                                                                                                                   // 7889
			strategy = _strategy;                                                                                               // 7890
			return err;                                                                                                         // 7891
		};                                                                                                                   // 7892
                                                                                                                       // 7893
		that.deflateSetDictionary = function(strm, dictionary, dictLength) {                                                 // 7894
			var length = dictLength;                                                                                            // 7895
			var n, index = 0;                                                                                                   // 7896
                                                                                                                       // 7897
			if (!dictionary || status != INIT_STATE)                                                                            // 7898
				return Z_STREAM_ERROR;                                                                                             // 7899
                                                                                                                       // 7900
			if (length < MIN_MATCH)                                                                                             // 7901
				return Z_OK;                                                                                                       // 7902
			if (length > w_size - MIN_LOOKAHEAD) {                                                                              // 7903
				length = w_size - MIN_LOOKAHEAD;                                                                                   // 7904
				index = dictLength - length; // use the tail of the dictionary                                                     // 7905
			}                                                                                                                   // 7906
			window.set(dictionary.subarray(index, index + length), 0);                                                          // 7907
                                                                                                                       // 7908
			strstart = length;                                                                                                  // 7909
			block_start = length;                                                                                               // 7910
                                                                                                                       // 7911
			// Insert all strings in the hash table (except for the last two bytes).                                            // 7912
			// s->lookahead stays null, so s->ins_h will be recomputed at the next                                              // 7913
			// call of fill_window.                                                                                             // 7914
                                                                                                                       // 7915
			ins_h = window[0] & 0xff;                                                                                           // 7916
			ins_h = (((ins_h) << hash_shift) ^ (window[1] & 0xff)) & hash_mask;                                                 // 7917
                                                                                                                       // 7918
			for (n = 0; n <= length - MIN_MATCH; n++) {                                                                         // 7919
				ins_h = (((ins_h) << hash_shift) ^ (window[(n) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                            // 7920
				prev[n & w_mask] = head[ins_h];                                                                                    // 7921
				head[ins_h] = n;                                                                                                   // 7922
			}                                                                                                                   // 7923
			return Z_OK;                                                                                                        // 7924
		};                                                                                                                   // 7925
                                                                                                                       // 7926
		that.deflate = function(_strm, flush) {                                                                              // 7927
			var i, header, level_flags, old_flush, bstate;                                                                      // 7928
                                                                                                                       // 7929
			if (flush > Z_FINISH || flush < 0) {                                                                                // 7930
				return Z_STREAM_ERROR;                                                                                             // 7931
			}                                                                                                                   // 7932
                                                                                                                       // 7933
			if (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE && flush != Z_FINISH)) { // 7934
				_strm.msg = z_errmsg[Z_NEED_DICT - (Z_STREAM_ERROR)];                                                              // 7935
				return Z_STREAM_ERROR;                                                                                             // 7936
			}                                                                                                                   // 7937
			if (_strm.avail_out === 0) {                                                                                        // 7938
				_strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];                                                                 // 7939
				return Z_BUF_ERROR;                                                                                                // 7940
			}                                                                                                                   // 7941
                                                                                                                       // 7942
			strm = _strm; // just in case                                                                                       // 7943
			old_flush = last_flush;                                                                                             // 7944
			last_flush = flush;                                                                                                 // 7945
                                                                                                                       // 7946
			// Write the zlib header                                                                                            // 7947
			if (status == INIT_STATE) {                                                                                         // 7948
				header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                                                                  // 7949
				level_flags = ((level - 1) & 0xff) >> 1;                                                                           // 7950
                                                                                                                       // 7951
				if (level_flags > 3)                                                                                               // 7952
					level_flags = 3;                                                                                                  // 7953
				header |= (level_flags << 6);                                                                                      // 7954
				if (strstart !== 0)                                                                                                // 7955
					header |= PRESET_DICT;                                                                                            // 7956
				header += 31 - (header % 31);                                                                                      // 7957
                                                                                                                       // 7958
				status = BUSY_STATE;                                                                                               // 7959
				putShortMSB(header);                                                                                               // 7960
			}                                                                                                                   // 7961
                                                                                                                       // 7962
			// Flush as much pending output as possible                                                                         // 7963
			if (that.pending !== 0) {                                                                                           // 7964
				strm.flush_pending();                                                                                              // 7965
				if (strm.avail_out === 0) {                                                                                        // 7966
					// console.log(" avail_out==0");                                                                                  // 7967
					// Since avail_out is 0, deflate will be called again with                                                        // 7968
					// more output space, but possibly with both pending and                                                          // 7969
					// avail_in equal to zero. There won't be anything to do,                                                         // 7970
					// but this is not an error situation so make sure we                                                             // 7971
					// return OK instead of BUF_ERROR at next call of deflate:                                                        // 7972
					last_flush = -1;                                                                                                  // 7973
					return Z_OK;                                                                                                      // 7974
				}                                                                                                                  // 7975
                                                                                                                       // 7976
				// Make sure there is something to do and avoid duplicate                                                          // 7977
				// consecutive                                                                                                     // 7978
				// flushes. For repeated and useless calls with Z_FINISH, we keep                                                  // 7979
				// returning Z_STREAM_END instead of Z_BUFF_ERROR.                                                                 // 7980
			} else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {                                        // 7981
				strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];                                                                  // 7982
				return Z_BUF_ERROR;                                                                                                // 7983
			}                                                                                                                   // 7984
                                                                                                                       // 7985
			// User must not provide more input after the first FINISH:                                                         // 7986
			if (status == FINISH_STATE && strm.avail_in !== 0) {                                                                // 7987
				_strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];                                                                 // 7988
				return Z_BUF_ERROR;                                                                                                // 7989
			}                                                                                                                   // 7990
                                                                                                                       // 7991
			// Start a new block or continue the current one.                                                                   // 7992
			if (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)) {                    // 7993
				bstate = -1;                                                                                                       // 7994
				switch (config_table[level].func) {                                                                                // 7995
				case STORED:                                                                                                       // 7996
					bstate = deflate_stored(flush);                                                                                   // 7997
					break;                                                                                                            // 7998
				case FAST:                                                                                                         // 7999
					bstate = deflate_fast(flush);                                                                                     // 8000
					break;                                                                                                            // 8001
				case SLOW:                                                                                                         // 8002
					bstate = deflate_slow(flush);                                                                                     // 8003
					break;                                                                                                            // 8004
				default:                                                                                                           // 8005
				}                                                                                                                  // 8006
                                                                                                                       // 8007
				if (bstate == FinishStarted || bstate == FinishDone) {                                                             // 8008
					status = FINISH_STATE;                                                                                            // 8009
				}                                                                                                                  // 8010
				if (bstate == NeedMore || bstate == FinishStarted) {                                                               // 8011
					if (strm.avail_out === 0) {                                                                                       // 8012
						last_flush = -1; // avoid BUF_ERROR next call, see above                                                         // 8013
					}                                                                                                                 // 8014
					return Z_OK;                                                                                                      // 8015
					// If flush != Z_NO_FLUSH && avail_out === 0, the next call                                                       // 8016
					// of deflate should use the same flush parameter to make sure                                                    // 8017
					// that the flush is complete. So we don't have to output an                                                      // 8018
					// empty block here, this will be done at next call. This also                                                    // 8019
					// ensures that for a very small output buffer, we emit at most                                                   // 8020
					// one empty block.                                                                                               // 8021
				}                                                                                                                  // 8022
                                                                                                                       // 8023
				if (bstate == BlockDone) {                                                                                         // 8024
					if (flush == Z_PARTIAL_FLUSH) {                                                                                   // 8025
						_tr_align();                                                                                                     // 8026
					} else { // FULL_FLUSH or SYNC_FLUSH                                                                              // 8027
						_tr_stored_block(0, 0, false);                                                                                   // 8028
						// For a full flush, this empty block will be recognized                                                         // 8029
						// as a special marker by inflate_sync().                                                                        // 8030
						if (flush == Z_FULL_FLUSH) {                                                                                     // 8031
							// state.head[s.hash_size-1]=0;                                                                                 // 8032
							for (i = 0; i < hash_size/*-1*/; i++)                                                                           // 8033
								// forget history                                                                                              // 8034
								head[i] = 0;                                                                                                   // 8035
						}                                                                                                                // 8036
					}                                                                                                                 // 8037
					strm.flush_pending();                                                                                             // 8038
					if (strm.avail_out === 0) {                                                                                       // 8039
						last_flush = -1; // avoid BUF_ERROR at next call, see above                                                      // 8040
						return Z_OK;                                                                                                     // 8041
					}                                                                                                                 // 8042
				}                                                                                                                  // 8043
			}                                                                                                                   // 8044
                                                                                                                       // 8045
			if (flush != Z_FINISH)                                                                                              // 8046
				return Z_OK;                                                                                                       // 8047
			return Z_STREAM_END;                                                                                                // 8048
		};                                                                                                                   // 8049
	}                                                                                                                     // 8050
                                                                                                                       // 8051
	// ZStream                                                                                                            // 8052
                                                                                                                       // 8053
	function ZStream() {                                                                                                  // 8054
		var that = this;                                                                                                     // 8055
		that.next_in_index = 0;                                                                                              // 8056
		that.next_out_index = 0;                                                                                             // 8057
		// that.next_in; // next input byte                                                                                  // 8058
		that.avail_in = 0; // number of bytes available at next_in                                                           // 8059
		that.total_in = 0; // total nb of input bytes read so far                                                            // 8060
		// that.next_out; // next output byte should be put there                                                            // 8061
		that.avail_out = 0; // remaining free space at next_out                                                              // 8062
		that.total_out = 0; // total nb of bytes output so far                                                               // 8063
		// that.msg;                                                                                                         // 8064
		// that.dstate;                                                                                                      // 8065
	}                                                                                                                     // 8066
                                                                                                                       // 8067
	ZStream.prototype = {                                                                                                 // 8068
		deflateInit : function(level, bits) {                                                                                // 8069
			var that = this;                                                                                                    // 8070
			that.dstate = new Deflate();                                                                                        // 8071
			if (!bits)                                                                                                          // 8072
				bits = MAX_BITS;                                                                                                   // 8073
			return that.dstate.deflateInit(that, level, bits);                                                                  // 8074
		},                                                                                                                   // 8075
                                                                                                                       // 8076
		deflate : function(flush) {                                                                                          // 8077
			var that = this;                                                                                                    // 8078
			if (!that.dstate) {                                                                                                 // 8079
				return Z_STREAM_ERROR;                                                                                             // 8080
			}                                                                                                                   // 8081
			return that.dstate.deflate(that, flush);                                                                            // 8082
		},                                                                                                                   // 8083
                                                                                                                       // 8084
		deflateEnd : function() {                                                                                            // 8085
			var that = this;                                                                                                    // 8086
			if (!that.dstate)                                                                                                   // 8087
				return Z_STREAM_ERROR;                                                                                             // 8088
			var ret = that.dstate.deflateEnd();                                                                                 // 8089
			that.dstate = null;                                                                                                 // 8090
			return ret;                                                                                                         // 8091
		},                                                                                                                   // 8092
                                                                                                                       // 8093
		deflateParams : function(level, strategy) {                                                                          // 8094
			var that = this;                                                                                                    // 8095
			if (!that.dstate)                                                                                                   // 8096
				return Z_STREAM_ERROR;                                                                                             // 8097
			return that.dstate.deflateParams(that, level, strategy);                                                            // 8098
		},                                                                                                                   // 8099
                                                                                                                       // 8100
		deflateSetDictionary : function(dictionary, dictLength) {                                                            // 8101
			var that = this;                                                                                                    // 8102
			if (!that.dstate)                                                                                                   // 8103
				return Z_STREAM_ERROR;                                                                                             // 8104
			return that.dstate.deflateSetDictionary(that, dictionary, dictLength);                                              // 8105
		},                                                                                                                   // 8106
                                                                                                                       // 8107
		// Read a new buffer from the current input stream, update the                                                       // 8108
		// total number of bytes read. All deflate() input goes through                                                      // 8109
		// this function so some applications may wish to modify it to avoid                                                 // 8110
		// allocating a large strm->next_in buffer and copying from it.                                                      // 8111
		// (See also flush_pending()).                                                                                       // 8112
		read_buf : function(buf, start, size) {                                                                              // 8113
			var that = this;                                                                                                    // 8114
			var len = that.avail_in;                                                                                            // 8115
			if (len > size)                                                                                                     // 8116
				len = size;                                                                                                        // 8117
			if (len === 0)                                                                                                      // 8118
				return 0;                                                                                                          // 8119
			that.avail_in -= len;                                                                                               // 8120
			buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);                                // 8121
			that.next_in_index += len;                                                                                          // 8122
			that.total_in += len;                                                                                               // 8123
			return len;                                                                                                         // 8124
		},                                                                                                                   // 8125
                                                                                                                       // 8126
		// Flush as much pending output as possible. All deflate() output goes                                               // 8127
		// through this function so some applications may wish to modify it                                                  // 8128
		// to avoid allocating a large strm->next_out buffer and copying into it.                                            // 8129
		// (See also read_buf()).                                                                                            // 8130
		flush_pending : function() {                                                                                         // 8131
			var that = this;                                                                                                    // 8132
			var len = that.dstate.pending;                                                                                      // 8133
                                                                                                                       // 8134
			if (len > that.avail_out)                                                                                           // 8135
				len = that.avail_out;                                                                                              // 8136
			if (len === 0)                                                                                                      // 8137
				return;                                                                                                            // 8138
                                                                                                                       // 8139
			// if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index     // 8140
			// || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +
			// len)) {                                                                                                          // 8142
			// console.log(that.dstate.pending_buf.length + ", " + that.dstate.pending_out + ", " + that.next_out.length + ", " +
			// that.next_out_index + ", " + len);                                                                               // 8144
			// console.log("avail_out=" + that.avail_out);                                                                      // 8145
			// }                                                                                                                // 8146
                                                                                                                       // 8147
			that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);
                                                                                                                       // 8149
			that.next_out_index += len;                                                                                         // 8150
			that.dstate.pending_out += len;                                                                                     // 8151
			that.total_out += len;                                                                                              // 8152
			that.avail_out -= len;                                                                                              // 8153
			that.dstate.pending -= len;                                                                                         // 8154
			if (that.dstate.pending === 0) {                                                                                    // 8155
				that.dstate.pending_out = 0;                                                                                       // 8156
			}                                                                                                                   // 8157
		}                                                                                                                    // 8158
	};                                                                                                                    // 8159
                                                                                                                       // 8160
	// Deflater                                                                                                           // 8161
                                                                                                                       // 8162
	return function Deflater(level) {                                                                                     // 8163
		var that = this;                                                                                                     // 8164
		var z = new ZStream();                                                                                               // 8165
		var bufsize = 512;                                                                                                   // 8166
		var flush = Z_NO_FLUSH;                                                                                              // 8167
		var buf = new Uint8Array(bufsize);                                                                                   // 8168
                                                                                                                       // 8169
		if (typeof level == "undefined")                                                                                     // 8170
			level = Z_DEFAULT_COMPRESSION;                                                                                      // 8171
		z.deflateInit(level);                                                                                                // 8172
		z.next_out = buf;                                                                                                    // 8173
                                                                                                                       // 8174
		that.append = function(data, onprogress) {                                                                           // 8175
			var err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;                                       // 8176
			if (!data.length)                                                                                                   // 8177
				return;                                                                                                            // 8178
			z.next_in_index = 0;                                                                                                // 8179
			z.next_in = data;                                                                                                   // 8180
			z.avail_in = data.length;                                                                                           // 8181
			do {                                                                                                                // 8182
				z.next_out_index = 0;                                                                                              // 8183
				z.avail_out = bufsize;                                                                                             // 8184
				err = z.deflate(flush);                                                                                            // 8185
				if (err != Z_OK)                                                                                                   // 8186
					throw "deflating: " + z.msg;                                                                                      // 8187
				if (z.next_out_index)                                                                                              // 8188
					if (z.next_out_index == bufsize)                                                                                  // 8189
						buffers.push(new Uint8Array(buf));                                                                               // 8190
					else                                                                                                              // 8191
						buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));                                                 // 8192
				bufferSize += z.next_out_index;                                                                                    // 8193
				if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {                                           // 8194
					onprogress(z.next_in_index);                                                                                      // 8195
					lastIndex = z.next_in_index;                                                                                      // 8196
				}                                                                                                                  // 8197
			} while (z.avail_in > 0 || z.avail_out === 0);                                                                      // 8198
			array = new Uint8Array(bufferSize);                                                                                 // 8199
			buffers.forEach(function(chunk) {                                                                                   // 8200
				array.set(chunk, bufferIndex);                                                                                     // 8201
				bufferIndex += chunk.length;                                                                                       // 8202
			});                                                                                                                 // 8203
			return array;                                                                                                       // 8204
		};                                                                                                                   // 8205
		that.flush = function() {                                                                                            // 8206
			var err, buffers = [], bufferIndex = 0, bufferSize = 0, array;                                                      // 8207
			do {                                                                                                                // 8208
				z.next_out_index = 0;                                                                                              // 8209
				z.avail_out = bufsize;                                                                                             // 8210
				err = z.deflate(Z_FINISH);                                                                                         // 8211
				if (err != Z_STREAM_END && err != Z_OK)                                                                            // 8212
					throw "deflating: " + z.msg;                                                                                      // 8213
				if (bufsize - z.avail_out > 0)                                                                                     // 8214
					buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));                                                  // 8215
				bufferSize += z.next_out_index;                                                                                    // 8216
			} while (z.avail_in > 0 || z.avail_out === 0);                                                                      // 8217
			z.deflateEnd();                                                                                                     // 8218
			array = new Uint8Array(bufferSize);                                                                                 // 8219
			buffers.forEach(function(chunk) {                                                                                   // 8220
				array.set(chunk, bufferIndex);                                                                                     // 8221
				bufferIndex += chunk.length;                                                                                       // 8222
			});                                                                                                                 // 8223
			return array;                                                                                                       // 8224
		};                                                                                                                   // 8225
	};                                                                                                                    // 8226
})(this);                                                                                                              // 8227
// Generated by CoffeeScript 1.4.0                                                                                     // 8228
                                                                                                                       // 8229
/*                                                                                                                     // 8230
# PNG.js                                                                                                               // 8231
# Copyright (c) 2011 Devon Govett                                                                                      // 8232
# MIT LICENSE                                                                                                          // 8233
#                                                                                                                      // 8234
# Permission is hereby granted, free of charge, to any person obtaining a copy of this                                 // 8235
# software and associated documentation files (the "Software"), to deal in the Software                                // 8236
# without restriction, including without limitation the rights to use, copy, modify, merge,                            // 8237
# publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons                           // 8238
# to whom the Software is furnished to do so, subject to the following conditions:                                     // 8239
#                                                                                                                      // 8240
# The above copyright notice and this permission notice shall be included in all copies or                             // 8241
# substantial portions of the Software.                                                                                // 8242
#                                                                                                                      // 8243
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING                        // 8244
# BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                           // 8245
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                         // 8246
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                       // 8247
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                              // 8248
*/                                                                                                                     // 8249
                                                                                                                       // 8250
                                                                                                                       // 8251
(function(global) {                                                                                                    // 8252
  var PNG;                                                                                                             // 8253
                                                                                                                       // 8254
  PNG = (function() {                                                                                                  // 8255
    var APNG_BLEND_OP_OVER, APNG_BLEND_OP_SOURCE, APNG_DISPOSE_OP_BACKGROUND, APNG_DISPOSE_OP_NONE, APNG_DISPOSE_OP_PREVIOUS, makeImage, scratchCanvas, scratchCtx;
                                                                                                                       // 8257
    PNG.load = function(url, canvas, callback) {                                                                       // 8258
      var xhr,                                                                                                         // 8259
        _this = this;                                                                                                  // 8260
      if (typeof canvas === 'function') {                                                                              // 8261
        callback = canvas;                                                                                             // 8262
      }                                                                                                                // 8263
      xhr = new XMLHttpRequest;                                                                                        // 8264
      xhr.open("GET", url, true);                                                                                      // 8265
      xhr.responseType = "arraybuffer";                                                                                // 8266
      xhr.onload = function() {                                                                                        // 8267
        var data, png;                                                                                                 // 8268
        data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);                                             // 8269
        png = new PNG(data);                                                                                           // 8270
        if (typeof (canvas != null ? canvas.getContext : void 0) === 'function') {                                     // 8271
          png.render(canvas);                                                                                          // 8272
        }                                                                                                              // 8273
        return typeof callback === "function" ? callback(png) : void 0;                                                // 8274
      };                                                                                                               // 8275
      return xhr.send(null);                                                                                           // 8276
    };                                                                                                                 // 8277
                                                                                                                       // 8278
    APNG_DISPOSE_OP_NONE = 0;                                                                                          // 8279
                                                                                                                       // 8280
    APNG_DISPOSE_OP_BACKGROUND = 1;                                                                                    // 8281
                                                                                                                       // 8282
    APNG_DISPOSE_OP_PREVIOUS = 2;                                                                                      // 8283
                                                                                                                       // 8284
    APNG_BLEND_OP_SOURCE = 0;                                                                                          // 8285
                                                                                                                       // 8286
    APNG_BLEND_OP_OVER = 1;                                                                                            // 8287
                                                                                                                       // 8288
    function PNG(data) {                                                                                               // 8289
      var chunkSize, colors, palLen, delayDen, delayNum, frame, i, index, key, section, palShort, text, _i, _j, _ref;  // 8290
      this.data = data;                                                                                                // 8291
      this.pos = 8;                                                                                                    // 8292
      this.palette = [];                                                                                               // 8293
      this.imgData = [];                                                                                               // 8294
      this.transparency = {};                                                                                          // 8295
      this.animation = null;                                                                                           // 8296
      this.text = {};                                                                                                  // 8297
      frame = null;                                                                                                    // 8298
      while (true) {                                                                                                   // 8299
        chunkSize = this.readUInt32();                                                                                 // 8300
        section = ((function() {                                                                                       // 8301
          var _i, _results;                                                                                            // 8302
          _results = [];                                                                                               // 8303
          for (i = _i = 0; _i < 4; i = ++_i) {                                                                         // 8304
            _results.push(String.fromCharCode(this.data[this.pos++]));                                                 // 8305
          }                                                                                                            // 8306
          return _results;                                                                                             // 8307
        }).call(this)).join('');                                                                                       // 8308
        switch (section) {                                                                                             // 8309
          case 'IHDR':                                                                                                 // 8310
            this.width = this.readUInt32();                                                                            // 8311
            this.height = this.readUInt32();                                                                           // 8312
            this.bits = this.data[this.pos++];                                                                         // 8313
            this.colorType = this.data[this.pos++];                                                                    // 8314
            this.compressionMethod = this.data[this.pos++];                                                            // 8315
            this.filterMethod = this.data[this.pos++];                                                                 // 8316
            this.interlaceMethod = this.data[this.pos++];                                                              // 8317
            break;                                                                                                     // 8318
          case 'acTL':                                                                                                 // 8319
            this.animation = {                                                                                         // 8320
              numFrames: this.readUInt32(),                                                                            // 8321
              numPlays: this.readUInt32() || Infinity,                                                                 // 8322
              frames: []                                                                                               // 8323
            };                                                                                                         // 8324
            break;                                                                                                     // 8325
          case 'PLTE':                                                                                                 // 8326
            this.palette = this.read(chunkSize);                                                                       // 8327
            break;                                                                                                     // 8328
          case 'fcTL':                                                                                                 // 8329
            if (frame) {                                                                                               // 8330
              this.animation.frames.push(frame);                                                                       // 8331
            }                                                                                                          // 8332
            this.pos += 4;                                                                                             // 8333
            frame = {                                                                                                  // 8334
              width: this.readUInt32(),                                                                                // 8335
              height: this.readUInt32(),                                                                               // 8336
              xOffset: this.readUInt32(),                                                                              // 8337
              yOffset: this.readUInt32()                                                                               // 8338
            };                                                                                                         // 8339
            delayNum = this.readUInt16();                                                                              // 8340
            delayDen = this.readUInt16() || 100;                                                                       // 8341
            frame.delay = 1000 * delayNum / delayDen;                                                                  // 8342
            frame.disposeOp = this.data[this.pos++];                                                                   // 8343
            frame.blendOp = this.data[this.pos++];                                                                     // 8344
            frame.data = [];                                                                                           // 8345
            break;                                                                                                     // 8346
          case 'IDAT':                                                                                                 // 8347
          case 'fdAT':                                                                                                 // 8348
            if (section === 'fdAT') {                                                                                  // 8349
              this.pos += 4;                                                                                           // 8350
              chunkSize -= 4;                                                                                          // 8351
            }                                                                                                          // 8352
            data = (frame != null ? frame.data : void 0) || this.imgData;                                              // 8353
            for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) {     // 8354
              data.push(this.data[this.pos++]);                                                                        // 8355
            }                                                                                                          // 8356
            break;                                                                                                     // 8357
          case 'tRNS':                                                                                                 // 8358
            this.transparency = {};                                                                                    // 8359
            switch (this.colorType) {                                                                                  // 8360
              case 3:                                                                                                  // 8361
            	palLen = this.palette.length/3;                                                                           // 8362
                this.transparency.indexed = this.read(chunkSize);                                                      // 8363
                if(this.transparency.indexed.length > palLen)                                                          // 8364
                	throw new Error('More transparent colors than palette size');                                         // 8365
                /*                                                                                                     // 8366
                 * According to the PNG spec trns should be increased to the same size as palette if shorter           // 8367
                 */                                                                                                    // 8368
                //palShort = 255 - this.transparency.indexed.length;                                                   // 8369
                palShort = palLen - this.transparency.indexed.length;                                                  // 8370
                if (palShort > 0) {                                                                                    // 8371
                  for (i = _j = 0; 0 <= palShort ? _j < palShort : _j > palShort; i = 0 <= palShort ? ++_j : --_j) {   // 8372
                    this.transparency.indexed.push(255);                                                               // 8373
                  }                                                                                                    // 8374
                }                                                                                                      // 8375
                break;                                                                                                 // 8376
              case 0:                                                                                                  // 8377
                this.transparency.grayscale = this.read(chunkSize)[0];                                                 // 8378
                break;                                                                                                 // 8379
              case 2:                                                                                                  // 8380
                this.transparency.rgb = this.read(chunkSize);                                                          // 8381
            }                                                                                                          // 8382
            break;                                                                                                     // 8383
          case 'tEXt':                                                                                                 // 8384
            text = this.read(chunkSize);                                                                               // 8385
            index = text.indexOf(0);                                                                                   // 8386
            key = String.fromCharCode.apply(String, text.slice(0, index));                                             // 8387
            this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));                                 // 8388
            break;                                                                                                     // 8389
          case 'IEND':                                                                                                 // 8390
            if (frame) {                                                                                               // 8391
              this.animation.frames.push(frame);                                                                       // 8392
            }                                                                                                          // 8393
            this.colors = (function() {                                                                                // 8394
              switch (this.colorType) {                                                                                // 8395
                case 0:                                                                                                // 8396
                case 3:                                                                                                // 8397
                case 4:                                                                                                // 8398
                  return 1;                                                                                            // 8399
                case 2:                                                                                                // 8400
                case 6:                                                                                                // 8401
                  return 3;                                                                                            // 8402
              }                                                                                                        // 8403
            }).call(this);                                                                                             // 8404
            this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;                                        // 8405
            colors = this.colors + (this.hasAlphaChannel ? 1 : 0);                                                     // 8406
            this.pixelBitlength = this.bits * colors;                                                                  // 8407
            this.colorSpace = (function() {                                                                            // 8408
              switch (this.colors) {                                                                                   // 8409
                case 1:                                                                                                // 8410
                  return 'DeviceGray';                                                                                 // 8411
                case 3:                                                                                                // 8412
                  return 'DeviceRGB';                                                                                  // 8413
              }                                                                                                        // 8414
            }).call(this);                                                                                             // 8415
            this.imgData = new Uint8Array(this.imgData);                                                               // 8416
            return;                                                                                                    // 8417
          default:                                                                                                     // 8418
            this.pos += chunkSize;                                                                                     // 8419
        }                                                                                                              // 8420
        this.pos += 4;                                                                                                 // 8421
        if (this.pos > this.data.length) {                                                                             // 8422
          throw new Error("Incomplete or corrupt PNG file");                                                           // 8423
        }                                                                                                              // 8424
      }                                                                                                                // 8425
      return;                                                                                                          // 8426
    }                                                                                                                  // 8427
                                                                                                                       // 8428
    PNG.prototype.read = function(bytes) {                                                                             // 8429
      var i, _i, _results;                                                                                             // 8430
      _results = [];                                                                                                   // 8431
      for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {                           // 8432
        _results.push(this.data[this.pos++]);                                                                          // 8433
      }                                                                                                                // 8434
      return _results;                                                                                                 // 8435
    };                                                                                                                 // 8436
                                                                                                                       // 8437
    PNG.prototype.readUInt32 = function() {                                                                            // 8438
      var b1, b2, b3, b4;                                                                                              // 8439
      b1 = this.data[this.pos++] << 24;                                                                                // 8440
      b2 = this.data[this.pos++] << 16;                                                                                // 8441
      b3 = this.data[this.pos++] << 8;                                                                                 // 8442
      b4 = this.data[this.pos++];                                                                                      // 8443
      return b1 | b2 | b3 | b4;                                                                                        // 8444
    };                                                                                                                 // 8445
                                                                                                                       // 8446
    PNG.prototype.readUInt16 = function() {                                                                            // 8447
      var b1, b2;                                                                                                      // 8448
      b1 = this.data[this.pos++] << 8;                                                                                 // 8449
      b2 = this.data[this.pos++];                                                                                      // 8450
      return b1 | b2;                                                                                                  // 8451
    };                                                                                                                 // 8452
                                                                                                                       // 8453
    PNG.prototype.decodePixels = function(data) {                                                                      // 8454
      var abyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
      if (data == null) {                                                                                              // 8456
        data = this.imgData;                                                                                           // 8457
      }                                                                                                                // 8458
      if (data.length === 0) {                                                                                         // 8459
        return new Uint8Array(0);                                                                                      // 8460
      }                                                                                                                // 8461
      data = new FlateStream(data);                                                                                    // 8462
      data = data.getBytes();                                                                                          // 8463
      pixelBytes = this.pixelBitlength / 8;                                                                            // 8464
      scanlineLength = pixelBytes * this.width;                                                                        // 8465
      pixels = new Uint8Array(scanlineLength * this.height);                                                           // 8466
      length = data.length;                                                                                            // 8467
      row = 0;                                                                                                         // 8468
      pos = 0;                                                                                                         // 8469
      c = 0;                                                                                                           // 8470
      while (pos < length) {                                                                                           // 8471
        switch (data[pos++]) {                                                                                         // 8472
          case 0:                                                                                                      // 8473
            for (i = _i = 0; _i < scanlineLength; i = _i += 1) {                                                       // 8474
              pixels[c++] = data[pos++];                                                                               // 8475
            }                                                                                                          // 8476
            break;                                                                                                     // 8477
          case 1:                                                                                                      // 8478
            for (i = _j = 0; _j < scanlineLength; i = _j += 1) {                                                       // 8479
              abyte = data[pos++];                                                                                     // 8480
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];                                                      // 8481
              pixels[c++] = (abyte + left) % 256;                                                                      // 8482
            }                                                                                                          // 8483
            break;                                                                                                     // 8484
          case 2:                                                                                                      // 8485
            for (i = _k = 0; _k < scanlineLength; i = _k += 1) {                                                       // 8486
              abyte = data[pos++];                                                                                     // 8487
              col = (i - (i % pixelBytes)) / pixelBytes;                                                               // 8488
              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];                 // 8489
              pixels[c++] = (upper + abyte) % 256;                                                                     // 8490
            }                                                                                                          // 8491
            break;                                                                                                     // 8492
          case 3:                                                                                                      // 8493
            for (i = _l = 0; _l < scanlineLength; i = _l += 1) {                                                       // 8494
              abyte = data[pos++];                                                                                     // 8495
              col = (i - (i % pixelBytes)) / pixelBytes;                                                               // 8496
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];                                                      // 8497
              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];                 // 8498
              pixels[c++] = (abyte + Math.floor((left + upper) / 2)) % 256;                                            // 8499
            }                                                                                                          // 8500
            break;                                                                                                     // 8501
          case 4:                                                                                                      // 8502
            for (i = _m = 0; _m < scanlineLength; i = _m += 1) {                                                       // 8503
              abyte = data[pos++];                                                                                     // 8504
              col = (i - (i % pixelBytes)) / pixelBytes;                                                               // 8505
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];                                                      // 8506
              if (row === 0) {                                                                                         // 8507
                upper = upperLeft = 0;                                                                                 // 8508
              } else {                                                                                                 // 8509
                upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];                      // 8510
                upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + (i % pixelBytes)];     // 8511
              }                                                                                                        // 8512
              p = left + upper - upperLeft;                                                                            // 8513
              pa = Math.abs(p - left);                                                                                 // 8514
              pb = Math.abs(p - upper);                                                                                // 8515
              pc = Math.abs(p - upperLeft);                                                                            // 8516
              if (pa <= pb && pa <= pc) {                                                                              // 8517
                paeth = left;                                                                                          // 8518
              } else if (pb <= pc) {                                                                                   // 8519
                paeth = upper;                                                                                         // 8520
              } else {                                                                                                 // 8521
                paeth = upperLeft;                                                                                     // 8522
              }                                                                                                        // 8523
              pixels[c++] = (abyte + paeth) % 256;                                                                     // 8524
            }                                                                                                          // 8525
            break;                                                                                                     // 8526
          default:                                                                                                     // 8527
            throw new Error("Invalid filter algorithm: " + data[pos - 1]);                                             // 8528
        }                                                                                                              // 8529
        row++;                                                                                                         // 8530
      }                                                                                                                // 8531
      return pixels;                                                                                                   // 8532
    };                                                                                                                 // 8533
                                                                                                                       // 8534
    PNG.prototype.decodePalette = function() {                                                                         // 8535
      var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;                                              // 8536
      palette = this.palette;                                                                                          // 8537
      transparency = this.transparency.indexed || [];                                                                  // 8538
      ret = new Uint8Array((transparency.length || 0) + palette.length);                                               // 8539
      pos = 0;                                                                                                         // 8540
      length = palette.length;                                                                                         // 8541
      c = 0;                                                                                                           // 8542
      for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {                                                // 8543
        ret[pos++] = palette[i];                                                                                       // 8544
        ret[pos++] = palette[i + 1];                                                                                   // 8545
        ret[pos++] = palette[i + 2];                                                                                   // 8546
        ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255;                                                // 8547
      }                                                                                                                // 8548
      return ret;                                                                                                      // 8549
    };                                                                                                                 // 8550
                                                                                                                       // 8551
    PNG.prototype.copyToImageData = function(imageData, pixels) {                                                      // 8552
      var alpha, colors, data, i, input, j, k, length, palette, v, _ref;                                               // 8553
      colors = this.colors;                                                                                            // 8554
      palette = null;                                                                                                  // 8555
      alpha = this.hasAlphaChannel;                                                                                    // 8556
      if (this.palette.length) {                                                                                       // 8557
        palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();          // 8558
        colors = 4;                                                                                                    // 8559
        alpha = true;                                                                                                  // 8560
      }                                                                                                                // 8561
      data = imageData.data || imageData;                                                                              // 8562
      length = data.length;                                                                                            // 8563
      input = palette || pixels;                                                                                       // 8564
      i = j = 0;                                                                                                       // 8565
      if (colors === 1) {                                                                                              // 8566
        while (i < length) {                                                                                           // 8567
          k = palette ? pixels[i / 4] * 4 : j;                                                                         // 8568
          v = input[k++];                                                                                              // 8569
          data[i++] = v;                                                                                               // 8570
          data[i++] = v;                                                                                               // 8571
          data[i++] = v;                                                                                               // 8572
          data[i++] = alpha ? input[k++] : 255;                                                                        // 8573
          j = k;                                                                                                       // 8574
        }                                                                                                              // 8575
      } else {                                                                                                         // 8576
        while (i < length) {                                                                                           // 8577
          k = palette ? pixels[i / 4] * 4 : j;                                                                         // 8578
          data[i++] = input[k++];                                                                                      // 8579
          data[i++] = input[k++];                                                                                      // 8580
          data[i++] = input[k++];                                                                                      // 8581
          data[i++] = alpha ? input[k++] : 255;                                                                        // 8582
          j = k;                                                                                                       // 8583
        }                                                                                                              // 8584
      }                                                                                                                // 8585
    };                                                                                                                 // 8586
                                                                                                                       // 8587
    PNG.prototype.decode = function() {                                                                                // 8588
      var ret;                                                                                                         // 8589
      ret = new Uint8Array(this.width * this.height * 4);                                                              // 8590
      this.copyToImageData(ret, this.decodePixels());                                                                  // 8591
      return ret;                                                                                                      // 8592
    };                                                                                                                 // 8593
                                                                                                                       // 8594
    try {                                                                                                              // 8595
        scratchCanvas = global.document.createElement('canvas');                                                       // 8596
        scratchCtx = scratchCanvas.getContext('2d');                                                                   // 8597
    } catch(e) {                                                                                                       // 8598
        return -1;                                                                                                     // 8599
    }                                                                                                                  // 8600
                                                                                                                       // 8601
    makeImage = function(imageData) {                                                                                  // 8602
      var img;                                                                                                         // 8603
      scratchCtx.width = imageData.width;                                                                              // 8604
      scratchCtx.height = imageData.height;                                                                            // 8605
      scratchCtx.clearRect(0, 0, imageData.width, imageData.height);                                                   // 8606
      scratchCtx.putImageData(imageData, 0, 0);                                                                        // 8607
      img = new Image;                                                                                                 // 8608
      img.src = scratchCanvas.toDataURL();                                                                             // 8609
      return img;                                                                                                      // 8610
    };                                                                                                                 // 8611
                                                                                                                       // 8612
    PNG.prototype.decodeFrames = function(ctx) {                                                                       // 8613
      var frame, i, imageData, pixels, _i, _len, _ref, _results;                                                       // 8614
      if (!this.animation) {                                                                                           // 8615
        return;                                                                                                        // 8616
      }                                                                                                                // 8617
      _ref = this.animation.frames;                                                                                    // 8618
      _results = [];                                                                                                   // 8619
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {                                                      // 8620
        frame = _ref[i];                                                                                               // 8621
        imageData = ctx.createImageData(frame.width, frame.height);                                                    // 8622
        pixels = this.decodePixels(new Uint8Array(frame.data));                                                        // 8623
        this.copyToImageData(imageData, pixels);                                                                       // 8624
        frame.imageData = imageData;                                                                                   // 8625
        _results.push(frame.image = makeImage(imageData));                                                             // 8626
      }                                                                                                                // 8627
      return _results;                                                                                                 // 8628
    };                                                                                                                 // 8629
                                                                                                                       // 8630
    PNG.prototype.renderFrame = function(ctx, number) {                                                                // 8631
      var frame, frames, prev;                                                                                         // 8632
      frames = this.animation.frames;                                                                                  // 8633
      frame = frames[number];                                                                                          // 8634
      prev = frames[number - 1];                                                                                       // 8635
      if (number === 0) {                                                                                              // 8636
        ctx.clearRect(0, 0, this.width, this.height);                                                                  // 8637
      }                                                                                                                // 8638
      if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_BACKGROUND) {                                   // 8639
        ctx.clearRect(prev.xOffset, prev.yOffset, prev.width, prev.height);                                            // 8640
      } else if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_PREVIOUS) {                              // 8641
        ctx.putImageData(prev.imageData, prev.xOffset, prev.yOffset);                                                  // 8642
      }                                                                                                                // 8643
      if (frame.blendOp === APNG_BLEND_OP_SOURCE) {                                                                    // 8644
        ctx.clearRect(frame.xOffset, frame.yOffset, frame.width, frame.height);                                        // 8645
      }                                                                                                                // 8646
      return ctx.drawImage(frame.image, frame.xOffset, frame.yOffset);                                                 // 8647
    };                                                                                                                 // 8648
                                                                                                                       // 8649
    PNG.prototype.animate = function(ctx) {                                                                            // 8650
      var doFrame, frameNumber, frames, numFrames, numPlays, _ref,                                                     // 8651
        _this = this;                                                                                                  // 8652
      frameNumber = 0;                                                                                                 // 8653
      _ref = this.animation, numFrames = _ref.numFrames, frames = _ref.frames, numPlays = _ref.numPlays;               // 8654
      return (doFrame = function() {                                                                                   // 8655
        var f, frame;                                                                                                  // 8656
        f = frameNumber++ % numFrames;                                                                                 // 8657
        frame = frames[f];                                                                                             // 8658
        _this.renderFrame(ctx, f);                                                                                     // 8659
        if (numFrames > 1 && frameNumber / numFrames < numPlays) {                                                     // 8660
          return _this.animation._timeout = setTimeout(doFrame, frame.delay);                                          // 8661
        }                                                                                                              // 8662
      })();                                                                                                            // 8663
    };                                                                                                                 // 8664
                                                                                                                       // 8665
    PNG.prototype.stopAnimation = function() {                                                                         // 8666
      var _ref;                                                                                                        // 8667
      return clearTimeout((_ref = this.animation) != null ? _ref._timeout : void 0);                                   // 8668
    };                                                                                                                 // 8669
                                                                                                                       // 8670
    PNG.prototype.render = function(canvas) {                                                                          // 8671
      var ctx, data;                                                                                                   // 8672
      if (canvas._png) {                                                                                               // 8673
        canvas._png.stopAnimation();                                                                                   // 8674
      }                                                                                                                // 8675
      canvas._png = this;                                                                                              // 8676
      canvas.width = this.width;                                                                                       // 8677
      canvas.height = this.height;                                                                                     // 8678
      ctx = canvas.getContext("2d");                                                                                   // 8679
      if (this.animation) {                                                                                            // 8680
        this.decodeFrames(ctx);                                                                                        // 8681
        return this.animate(ctx);                                                                                      // 8682
      } else {                                                                                                         // 8683
        data = ctx.createImageData(this.width, this.height);                                                           // 8684
        this.copyToImageData(data, this.decodePixels());                                                               // 8685
        return ctx.putImageData(data, 0, 0);                                                                           // 8686
      }                                                                                                                // 8687
    };                                                                                                                 // 8688
                                                                                                                       // 8689
    return PNG;                                                                                                        // 8690
                                                                                                                       // 8691
  })();                                                                                                                // 8692
                                                                                                                       // 8693
  global.PNG = PNG;                                                                                                    // 8694
                                                                                                                       // 8695
})(typeof window !== "undefined" && window || this);                                                                   // 8696
/*                                                                                                                     // 8697
 * Extracted from pdf.js                                                                                               // 8698
 * https://github.com/andreasgal/pdf.js                                                                                // 8699
 *                                                                                                                     // 8700
 * Copyright (c) 2011 Mozilla Foundation                                                                               // 8701
 *                                                                                                                     // 8702
 * Contributors: Andreas Gal <gal@mozilla.com>                                                                         // 8703
 *               Chris G Jones <cjones@mozilla.com>                                                                    // 8704
 *               Shaon Barman <shaon.barman@gmail.com>                                                                 // 8705
 *               Vivien Nicolas <21@vingtetun.org>                                                                     // 8706
 *               Justin D'Arcangelo <justindarc@gmail.com>                                                             // 8707
 *               Yury Delendik                                                                                         // 8708
 *                                                                                                                     // 8709
 * Permission is hereby granted, free of charge, to any person obtaining a                                             // 8710
 * copy of this software and associated documentation files (the "Software"),                                          // 8711
 * to deal in the Software without restriction, including without limitation                                           // 8712
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,                                            // 8713
 * and/or sell copies of the Software, and to permit persons to whom the                                               // 8714
 * Software is furnished to do so, subject to the following conditions:                                                // 8715
 *                                                                                                                     // 8716
 * The above copyright notice and this permission notice shall be included in                                          // 8717
 * all copies or substantial portions of the Software.                                                                 // 8718
 *                                                                                                                     // 8719
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                          // 8720
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                            // 8721
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL                                             // 8722
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                          // 8723
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING                                             // 8724
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER                                                 // 8725
 * DEALINGS IN THE SOFTWARE.                                                                                           // 8726
 */                                                                                                                    // 8727
                                                                                                                       // 8728
var DecodeStream = (function() {                                                                                       // 8729
  function constructor() {                                                                                             // 8730
    this.pos = 0;                                                                                                      // 8731
    this.bufferLength = 0;                                                                                             // 8732
    this.eof = false;                                                                                                  // 8733
    this.buffer = null;                                                                                                // 8734
  }                                                                                                                    // 8735
                                                                                                                       // 8736
  constructor.prototype = {                                                                                            // 8737
    ensureBuffer: function decodestream_ensureBuffer(requested) {                                                      // 8738
      var buffer = this.buffer;                                                                                        // 8739
      var current = buffer ? buffer.byteLength : 0;                                                                    // 8740
      if (requested < current)                                                                                         // 8741
        return buffer;                                                                                                 // 8742
      var size = 512;                                                                                                  // 8743
      while (size < requested)                                                                                         // 8744
        size <<= 1;                                                                                                    // 8745
      var buffer2 = new Uint8Array(size);                                                                              // 8746
      for (var i = 0; i < current; ++i)                                                                                // 8747
        buffer2[i] = buffer[i];                                                                                        // 8748
      return this.buffer = buffer2;                                                                                    // 8749
    },                                                                                                                 // 8750
    getByte: function decodestream_getByte() {                                                                         // 8751
      var pos = this.pos;                                                                                              // 8752
      while (this.bufferLength <= pos) {                                                                               // 8753
        if (this.eof)                                                                                                  // 8754
          return null;                                                                                                 // 8755
        this.readBlock();                                                                                              // 8756
      }                                                                                                                // 8757
      return this.buffer[this.pos++];                                                                                  // 8758
    },                                                                                                                 // 8759
    getBytes: function decodestream_getBytes(length) {                                                                 // 8760
      var pos = this.pos;                                                                                              // 8761
                                                                                                                       // 8762
      if (length) {                                                                                                    // 8763
        this.ensureBuffer(pos + length);                                                                               // 8764
        var end = pos + length;                                                                                        // 8765
                                                                                                                       // 8766
        while (!this.eof && this.bufferLength < end)                                                                   // 8767
          this.readBlock();                                                                                            // 8768
                                                                                                                       // 8769
        var bufEnd = this.bufferLength;                                                                                // 8770
        if (end > bufEnd)                                                                                              // 8771
          end = bufEnd;                                                                                                // 8772
      } else {                                                                                                         // 8773
        while (!this.eof)                                                                                              // 8774
          this.readBlock();                                                                                            // 8775
                                                                                                                       // 8776
        var end = this.bufferLength;                                                                                   // 8777
      }                                                                                                                // 8778
                                                                                                                       // 8779
      this.pos = end;                                                                                                  // 8780
      return this.buffer.subarray(pos, end);                                                                           // 8781
    },                                                                                                                 // 8782
    lookChar: function decodestream_lookChar() {                                                                       // 8783
      var pos = this.pos;                                                                                              // 8784
      while (this.bufferLength <= pos) {                                                                               // 8785
        if (this.eof)                                                                                                  // 8786
          return null;                                                                                                 // 8787
        this.readBlock();                                                                                              // 8788
      }                                                                                                                // 8789
      return String.fromCharCode(this.buffer[this.pos]);                                                               // 8790
    },                                                                                                                 // 8791
    getChar: function decodestream_getChar() {                                                                         // 8792
      var pos = this.pos;                                                                                              // 8793
      while (this.bufferLength <= pos) {                                                                               // 8794
        if (this.eof)                                                                                                  // 8795
          return null;                                                                                                 // 8796
        this.readBlock();                                                                                              // 8797
      }                                                                                                                // 8798
      return String.fromCharCode(this.buffer[this.pos++]);                                                             // 8799
    },                                                                                                                 // 8800
    makeSubStream: function decodestream_makeSubstream(start, length, dict) {                                          // 8801
      var end = start + length;                                                                                        // 8802
      while (this.bufferLength <= end && !this.eof)                                                                    // 8803
        this.readBlock();                                                                                              // 8804
      return new Stream(this.buffer, start, length, dict);                                                             // 8805
    },                                                                                                                 // 8806
    skip: function decodestream_skip(n) {                                                                              // 8807
      if (!n)                                                                                                          // 8808
        n = 1;                                                                                                         // 8809
      this.pos += n;                                                                                                   // 8810
    },                                                                                                                 // 8811
    reset: function decodestream_reset() {                                                                             // 8812
      this.pos = 0;                                                                                                    // 8813
    }                                                                                                                  // 8814
  };                                                                                                                   // 8815
                                                                                                                       // 8816
  return constructor;                                                                                                  // 8817
})();                                                                                                                  // 8818
                                                                                                                       // 8819
var FlateStream = (function() {                                                                                        // 8820
  if (typeof Uint32Array === 'undefined') {                                                                            // 8821
    return undefined;                                                                                                  // 8822
  }                                                                                                                    // 8823
  var codeLenCodeMap = new Uint32Array([                                                                               // 8824
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15                                                   // 8825
  ]);                                                                                                                  // 8826
                                                                                                                       // 8827
  var lengthDecode = new Uint32Array([                                                                                 // 8828
    0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,                                            // 8829
    0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,                                            // 8830
    0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,                                            // 8831
    0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102                                                      // 8832
  ]);                                                                                                                  // 8833
                                                                                                                       // 8834
  var distDecode = new Uint32Array([                                                                                   // 8835
    0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,                                            // 8836
    0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,                                            // 8837
    0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,                                            // 8838
    0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001                                                               // 8839
  ]);                                                                                                                  // 8840
                                                                                                                       // 8841
  var fixedLitCodeTab = [new Uint32Array([                                                                             // 8842
    0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,                                            // 8843
    0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,                                            // 8844
    0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,                                            // 8845
    0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,                                            // 8846
    0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,                                            // 8847
    0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,                                            // 8848
    0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,                                            // 8849
    0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,                                            // 8850
    0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,                                            // 8851
    0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,                                            // 8852
    0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,                                            // 8853
    0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,                                            // 8854
    0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,                                            // 8855
    0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,                                            // 8856
    0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,                                            // 8857
    0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,                                            // 8858
    0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,                                            // 8859
    0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,                                            // 8860
    0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,                                            // 8861
    0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,                                            // 8862
    0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,                                            // 8863
    0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,                                            // 8864
    0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,                                            // 8865
    0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,                                            // 8866
    0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,                                            // 8867
    0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,                                            // 8868
    0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,                                            // 8869
    0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,                                            // 8870
    0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,                                            // 8871
    0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,                                            // 8872
    0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,                                            // 8873
    0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,                                            // 8874
    0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,                                            // 8875
    0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,                                            // 8876
    0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,                                            // 8877
    0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,                                            // 8878
    0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,                                            // 8879
    0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,                                            // 8880
    0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,                                            // 8881
    0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,                                            // 8882
    0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,                                            // 8883
    0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,                                            // 8884
    0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,                                            // 8885
    0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,                                            // 8886
    0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,                                            // 8887
    0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,                                            // 8888
    0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,                                            // 8889
    0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,                                            // 8890
    0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,                                            // 8891
    0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,                                            // 8892
    0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,                                            // 8893
    0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,                                            // 8894
    0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,                                            // 8895
    0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,                                            // 8896
    0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,                                            // 8897
    0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,                                            // 8898
    0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,                                            // 8899
    0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,                                            // 8900
    0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,                                            // 8901
    0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,                                            // 8902
    0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,                                            // 8903
    0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,                                            // 8904
    0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,                                            // 8905
    0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff                                             // 8906
  ]), 9];                                                                                                              // 8907
                                                                                                                       // 8908
  var fixedDistCodeTab = [new Uint32Array([                                                                            // 8909
    0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,                                            // 8910
    0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,                                            // 8911
    0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,                                            // 8912
    0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000                                             // 8913
  ]), 5];                                                                                                              // 8914
                                                                                                                       // 8915
  function error(e) {                                                                                                  // 8916
      throw new Error(e)                                                                                               // 8917
  }                                                                                                                    // 8918
                                                                                                                       // 8919
  function constructor(bytes) {                                                                                        // 8920
    //var bytes = stream.getBytes();                                                                                   // 8921
    var bytesPos = 0;                                                                                                  // 8922
                                                                                                                       // 8923
    var cmf = bytes[bytesPos++];                                                                                       // 8924
    var flg = bytes[bytesPos++];                                                                                       // 8925
    if (cmf == -1 || flg == -1)                                                                                        // 8926
      error('Invalid header in flate stream');                                                                         // 8927
    if ((cmf & 0x0f) != 0x08)                                                                                          // 8928
      error('Unknown compression method in flate stream');                                                             // 8929
    if ((((cmf << 8) + flg) % 31) != 0)                                                                                // 8930
      error('Bad FCHECK in flate stream');                                                                             // 8931
    if (flg & 0x20)                                                                                                    // 8932
      error('FDICT bit set in flate stream');                                                                          // 8933
                                                                                                                       // 8934
    this.bytes = bytes;                                                                                                // 8935
    this.bytesPos = bytesPos;                                                                                          // 8936
                                                                                                                       // 8937
    this.codeSize = 0;                                                                                                 // 8938
    this.codeBuf = 0;                                                                                                  // 8939
                                                                                                                       // 8940
    DecodeStream.call(this);                                                                                           // 8941
  }                                                                                                                    // 8942
                                                                                                                       // 8943
  constructor.prototype = Object.create(DecodeStream.prototype);                                                       // 8944
                                                                                                                       // 8945
  constructor.prototype.getBits = function(bits) {                                                                     // 8946
    var codeSize = this.codeSize;                                                                                      // 8947
    var codeBuf = this.codeBuf;                                                                                        // 8948
    var bytes = this.bytes;                                                                                            // 8949
    var bytesPos = this.bytesPos;                                                                                      // 8950
                                                                                                                       // 8951
    var b;                                                                                                             // 8952
    while (codeSize < bits) {                                                                                          // 8953
      if (typeof (b = bytes[bytesPos++]) == 'undefined')                                                               // 8954
        error('Bad encoding in flate stream');                                                                         // 8955
      codeBuf |= b << codeSize;                                                                                        // 8956
      codeSize += 8;                                                                                                   // 8957
    }                                                                                                                  // 8958
    b = codeBuf & ((1 << bits) - 1);                                                                                   // 8959
    this.codeBuf = codeBuf >> bits;                                                                                    // 8960
    this.codeSize = codeSize -= bits;                                                                                  // 8961
    this.bytesPos = bytesPos;                                                                                          // 8962
    return b;                                                                                                          // 8963
  };                                                                                                                   // 8964
                                                                                                                       // 8965
  constructor.prototype.getCode = function(table) {                                                                    // 8966
    var codes = table[0];                                                                                              // 8967
    var maxLen = table[1];                                                                                             // 8968
    var codeSize = this.codeSize;                                                                                      // 8969
    var codeBuf = this.codeBuf;                                                                                        // 8970
    var bytes = this.bytes;                                                                                            // 8971
    var bytesPos = this.bytesPos;                                                                                      // 8972
                                                                                                                       // 8973
    while (codeSize < maxLen) {                                                                                        // 8974
      var b;                                                                                                           // 8975
      if (typeof (b = bytes[bytesPos++]) == 'undefined')                                                               // 8976
        error('Bad encoding in flate stream');                                                                         // 8977
      codeBuf |= (b << codeSize);                                                                                      // 8978
      codeSize += 8;                                                                                                   // 8979
    }                                                                                                                  // 8980
    var code = codes[codeBuf & ((1 << maxLen) - 1)];                                                                   // 8981
    var codeLen = code >> 16;                                                                                          // 8982
    var codeVal = code & 0xffff;                                                                                       // 8983
    if (codeSize == 0 || codeSize < codeLen || codeLen == 0)                                                           // 8984
      error('Bad encoding in flate stream');                                                                           // 8985
    this.codeBuf = (codeBuf >> codeLen);                                                                               // 8986
    this.codeSize = (codeSize - codeLen);                                                                              // 8987
    this.bytesPos = bytesPos;                                                                                          // 8988
    return codeVal;                                                                                                    // 8989
  };                                                                                                                   // 8990
                                                                                                                       // 8991
  constructor.prototype.generateHuffmanTable = function(lengths) {                                                     // 8992
    var n = lengths.length;                                                                                            // 8993
                                                                                                                       // 8994
    // find max code length                                                                                            // 8995
    var maxLen = 0;                                                                                                    // 8996
    for (var i = 0; i < n; ++i) {                                                                                      // 8997
      if (lengths[i] > maxLen)                                                                                         // 8998
        maxLen = lengths[i];                                                                                           // 8999
    }                                                                                                                  // 9000
                                                                                                                       // 9001
    // build the table                                                                                                 // 9002
    var size = 1 << maxLen;                                                                                            // 9003
    var codes = new Uint32Array(size);                                                                                 // 9004
    for (var len = 1, code = 0, skip = 2;                                                                              // 9005
         len <= maxLen;                                                                                                // 9006
         ++len, code <<= 1, skip <<= 1) {                                                                              // 9007
      for (var val = 0; val < n; ++val) {                                                                              // 9008
        if (lengths[val] == len) {                                                                                     // 9009
          // bit-reverse the code                                                                                      // 9010
          var code2 = 0;                                                                                               // 9011
          var t = code;                                                                                                // 9012
          for (var i = 0; i < len; ++i) {                                                                              // 9013
            code2 = (code2 << 1) | (t & 1);                                                                            // 9014
            t >>= 1;                                                                                                   // 9015
          }                                                                                                            // 9016
                                                                                                                       // 9017
          // fill the table entries                                                                                    // 9018
          for (var i = code2; i < size; i += skip)                                                                     // 9019
            codes[i] = (len << 16) | val;                                                                              // 9020
                                                                                                                       // 9021
          ++code;                                                                                                      // 9022
        }                                                                                                              // 9023
      }                                                                                                                // 9024
    }                                                                                                                  // 9025
                                                                                                                       // 9026
    return [codes, maxLen];                                                                                            // 9027
  };                                                                                                                   // 9028
                                                                                                                       // 9029
  constructor.prototype.readBlock = function() {                                                                       // 9030
    function repeat(stream, array, len, offset, what) {                                                                // 9031
      var repeat = stream.getBits(len) + offset;                                                                       // 9032
      while (repeat-- > 0)                                                                                             // 9033
        array[i++] = what;                                                                                             // 9034
    }                                                                                                                  // 9035
                                                                                                                       // 9036
    // read block header                                                                                               // 9037
    var hdr = this.getBits(3);                                                                                         // 9038
    if (hdr & 1)                                                                                                       // 9039
      this.eof = true;                                                                                                 // 9040
    hdr >>= 1;                                                                                                         // 9041
                                                                                                                       // 9042
    if (hdr == 0) { // uncompressed block                                                                              // 9043
      var bytes = this.bytes;                                                                                          // 9044
      var bytesPos = this.bytesPos;                                                                                    // 9045
      var b;                                                                                                           // 9046
                                                                                                                       // 9047
      if (typeof (b = bytes[bytesPos++]) == 'undefined')                                                               // 9048
        error('Bad block header in flate stream');                                                                     // 9049
      var blockLen = b;                                                                                                // 9050
      if (typeof (b = bytes[bytesPos++]) == 'undefined')                                                               // 9051
        error('Bad block header in flate stream');                                                                     // 9052
      blockLen |= (b << 8);                                                                                            // 9053
      if (typeof (b = bytes[bytesPos++]) == 'undefined')                                                               // 9054
        error('Bad block header in flate stream');                                                                     // 9055
      var check = b;                                                                                                   // 9056
      if (typeof (b = bytes[bytesPos++]) == 'undefined')                                                               // 9057
        error('Bad block header in flate stream');                                                                     // 9058
      check |= (b << 8);                                                                                               // 9059
      if (check != (~blockLen & 0xffff))                                                                               // 9060
        error('Bad uncompressed block length in flate stream');                                                        // 9061
                                                                                                                       // 9062
      this.codeBuf = 0;                                                                                                // 9063
      this.codeSize = 0;                                                                                               // 9064
                                                                                                                       // 9065
      var bufferLength = this.bufferLength;                                                                            // 9066
      var buffer = this.ensureBuffer(bufferLength + blockLen);                                                         // 9067
      var end = bufferLength + blockLen;                                                                               // 9068
      this.bufferLength = end;                                                                                         // 9069
      for (var n = bufferLength; n < end; ++n) {                                                                       // 9070
        if (typeof (b = bytes[bytesPos++]) == 'undefined') {                                                           // 9071
          this.eof = true;                                                                                             // 9072
          break;                                                                                                       // 9073
        }                                                                                                              // 9074
        buffer[n] = b;                                                                                                 // 9075
      }                                                                                                                // 9076
      this.bytesPos = bytesPos;                                                                                        // 9077
      return;                                                                                                          // 9078
    }                                                                                                                  // 9079
                                                                                                                       // 9080
    var litCodeTable;                                                                                                  // 9081
    var distCodeTable;                                                                                                 // 9082
    if (hdr == 1) { // compressed block, fixed codes                                                                   // 9083
      litCodeTable = fixedLitCodeTab;                                                                                  // 9084
      distCodeTable = fixedDistCodeTab;                                                                                // 9085
    } else if (hdr == 2) { // compressed block, dynamic codes                                                          // 9086
      var numLitCodes = this.getBits(5) + 257;                                                                         // 9087
      var numDistCodes = this.getBits(5) + 1;                                                                          // 9088
      var numCodeLenCodes = this.getBits(4) + 4;                                                                       // 9089
                                                                                                                       // 9090
      // build the code lengths code table                                                                             // 9091
      var codeLenCodeLengths = Array(codeLenCodeMap.length);                                                           // 9092
      var i = 0;                                                                                                       // 9093
      while (i < numCodeLenCodes)                                                                                      // 9094
        codeLenCodeLengths[codeLenCodeMap[i++]] = this.getBits(3);                                                     // 9095
      var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);                                              // 9096
                                                                                                                       // 9097
      // build the literal and distance code tables                                                                    // 9098
      var len = 0;                                                                                                     // 9099
      var i = 0;                                                                                                       // 9100
      var codes = numLitCodes + numDistCodes;                                                                          // 9101
      var codeLengths = new Array(codes);                                                                              // 9102
      while (i < codes) {                                                                                              // 9103
        var code = this.getCode(codeLenCodeTab);                                                                       // 9104
        if (code == 16) {                                                                                              // 9105
          repeat(this, codeLengths, 2, 3, len);                                                                        // 9106
        } else if (code == 17) {                                                                                       // 9107
          repeat(this, codeLengths, 3, 3, len = 0);                                                                    // 9108
        } else if (code == 18) {                                                                                       // 9109
          repeat(this, codeLengths, 7, 11, len = 0);                                                                   // 9110
        } else {                                                                                                       // 9111
          codeLengths[i++] = len = code;                                                                               // 9112
        }                                                                                                              // 9113
      }                                                                                                                // 9114
                                                                                                                       // 9115
      litCodeTable =                                                                                                   // 9116
        this.generateHuffmanTable(codeLengths.slice(0, numLitCodes));                                                  // 9117
      distCodeTable =                                                                                                  // 9118
        this.generateHuffmanTable(codeLengths.slice(numLitCodes, codes));                                              // 9119
    } else {                                                                                                           // 9120
      error('Unknown block type in flate stream');                                                                     // 9121
    }                                                                                                                  // 9122
                                                                                                                       // 9123
    var buffer = this.buffer;                                                                                          // 9124
    var limit = buffer ? buffer.length : 0;                                                                            // 9125
    var pos = this.bufferLength;                                                                                       // 9126
    while (true) {                                                                                                     // 9127
      var code1 = this.getCode(litCodeTable);                                                                          // 9128
      if (code1 < 256) {                                                                                               // 9129
        if (pos + 1 >= limit) {                                                                                        // 9130
          buffer = this.ensureBuffer(pos + 1);                                                                         // 9131
          limit = buffer.length;                                                                                       // 9132
        }                                                                                                              // 9133
        buffer[pos++] = code1;                                                                                         // 9134
        continue;                                                                                                      // 9135
      }                                                                                                                // 9136
      if (code1 == 256) {                                                                                              // 9137
        this.bufferLength = pos;                                                                                       // 9138
        return;                                                                                                        // 9139
      }                                                                                                                // 9140
      code1 -= 257;                                                                                                    // 9141
      code1 = lengthDecode[code1];                                                                                     // 9142
      var code2 = code1 >> 16;                                                                                         // 9143
      if (code2 > 0)                                                                                                   // 9144
        code2 = this.getBits(code2);                                                                                   // 9145
      var len = (code1 & 0xffff) + code2;                                                                              // 9146
      code1 = this.getCode(distCodeTable);                                                                             // 9147
      code1 = distDecode[code1];                                                                                       // 9148
      code2 = code1 >> 16;                                                                                             // 9149
      if (code2 > 0)                                                                                                   // 9150
        code2 = this.getBits(code2);                                                                                   // 9151
      var dist = (code1 & 0xffff) + code2;                                                                             // 9152
      if (pos + len >= limit) {                                                                                        // 9153
        buffer = this.ensureBuffer(pos + len);                                                                         // 9154
        limit = buffer.length;                                                                                         // 9155
      }                                                                                                                // 9156
      for (var k = 0; k < len; ++k, ++pos)                                                                             // 9157
        buffer[pos] = buffer[pos - dist];                                                                              // 9158
    }                                                                                                                  // 9159
  };                                                                                                                   // 9160
                                                                                                                       // 9161
  return constructor;                                                                                                  // 9162
})();/**                                                                                                               // 9163
 * JavaScript Polyfill functions for jsPDF                                                                             // 9164
 * Collected from public resources by                                                                                  // 9165
 * https://github.com/diegocr                                                                                          // 9166
 */                                                                                                                    // 9167
                                                                                                                       // 9168
(function (global) {                                                                                                   // 9169
	var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';                                        // 9170
                                                                                                                       // 9171
	if (typeof global.btoa === 'undefined') {                                                                             // 9172
		global.btoa = function(data) {                                                                                       // 9173
			//  discuss at: http://phpjs.org/functions/base64_encode/                                                           // 9174
			// original by: Tyler Akins (http://rumkin.com)                                                                     // 9175
			// improved by: Bayron Guevara                                                                                      // 9176
			// improved by: Thunder.m                                                                                           // 9177
			// improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)                                                 // 9178
			// improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)                                                 // 9179
			// improved by: Rafal Kukawski (http://kukawski.pl)                                                                 // 9180
			// bugfixed by: Pellentesque Malesuada                                                                              // 9181
			//   example 1: base64_encode('Kevin van Zonneveld');                                                               // 9182
			//   returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='                                                                      // 9183
                                                                                                                       // 9184
			var o1,o2,o3,h1,h2,h3,h4,bits,i = 0,ac = 0,enc = '',tmp_arr = [];                                                   // 9185
                                                                                                                       // 9186
			if (!data) {                                                                                                        // 9187
				return data;                                                                                                       // 9188
			}                                                                                                                   // 9189
                                                                                                                       // 9190
			do { // pack three octets into four hexets                                                                          // 9191
				o1 = data.charCodeAt(i++);                                                                                         // 9192
				o2 = data.charCodeAt(i++);                                                                                         // 9193
				o3 = data.charCodeAt(i++);                                                                                         // 9194
                                                                                                                       // 9195
				bits = o1 << 16 | o2 << 8 | o3;                                                                                    // 9196
                                                                                                                       // 9197
				h1 = bits >> 18 & 0x3f;                                                                                            // 9198
				h2 = bits >> 12 & 0x3f;                                                                                            // 9199
				h3 = bits >> 6 & 0x3f;                                                                                             // 9200
				h4 = bits & 0x3f;                                                                                                  // 9201
                                                                                                                       // 9202
				// use hexets to index into b64, and append result to encoded string                                               // 9203
				tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);                                 // 9204
			} while (i < data.length);                                                                                          // 9205
                                                                                                                       // 9206
			enc = tmp_arr.join('');                                                                                             // 9207
                                                                                                                       // 9208
			var r = data.length % 3;                                                                                            // 9209
                                                                                                                       // 9210
			return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);                                                       // 9211
		};                                                                                                                   // 9212
	}                                                                                                                     // 9213
                                                                                                                       // 9214
	if (typeof global.atob === 'undefined') {                                                                             // 9215
		global.atob = function(data) {                                                                                       // 9216
			//  discuss at: http://phpjs.org/functions/base64_decode/                                                           // 9217
			// original by: Tyler Akins (http://rumkin.com)                                                                     // 9218
			// improved by: Thunder.m                                                                                           // 9219
			// improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)                                                 // 9220
			// improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)                                                 // 9221
			//    input by: Aman Gupta                                                                                          // 9222
			//    input by: Brett Zamir (http://brett-zamir.me)                                                                 // 9223
			// bugfixed by: Onno Marsman                                                                                        // 9224
			// bugfixed by: Pellentesque Malesuada                                                                              // 9225
			// bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)                                                 // 9226
			//   example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');                                                      // 9227
			//   returns 1: 'Kevin van Zonneveld'                                                                               // 9228
                                                                                                                       // 9229
			var o1,o2,o3,h1,h2,h3,h4,bits,i = 0,ac = 0,dec = '',tmp_arr = [];                                                   // 9230
                                                                                                                       // 9231
			if (!data) {                                                                                                        // 9232
				return data;                                                                                                       // 9233
			}                                                                                                                   // 9234
                                                                                                                       // 9235
			data += '';                                                                                                         // 9236
                                                                                                                       // 9237
			do { // unpack four hexets into three octets using index points in b64                                              // 9238
				h1 = b64.indexOf(data.charAt(i++));                                                                                // 9239
				h2 = b64.indexOf(data.charAt(i++));                                                                                // 9240
				h3 = b64.indexOf(data.charAt(i++));                                                                                // 9241
				h4 = b64.indexOf(data.charAt(i++));                                                                                // 9242
                                                                                                                       // 9243
				bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;                                                                         // 9244
                                                                                                                       // 9245
				o1 = bits >> 16 & 0xff;                                                                                            // 9246
				o2 = bits >> 8 & 0xff;                                                                                             // 9247
				o3 = bits & 0xff;                                                                                                  // 9248
                                                                                                                       // 9249
				if (h3 == 64) {                                                                                                    // 9250
					tmp_arr[ac++] = String.fromCharCode(o1);                                                                          // 9251
				} else if (h4 == 64) {                                                                                             // 9252
					tmp_arr[ac++] = String.fromCharCode(o1, o2);                                                                      // 9253
				} else {                                                                                                           // 9254
					tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);                                                                  // 9255
				}                                                                                                                  // 9256
			} while (i < data.length);                                                                                          // 9257
                                                                                                                       // 9258
			dec = tmp_arr.join('');                                                                                             // 9259
                                                                                                                       // 9260
			return dec;                                                                                                         // 9261
		};                                                                                                                   // 9262
	}                                                                                                                     // 9263
                                                                                                                       // 9264
	if (!Array.prototype.map) {                                                                                           // 9265
		Array.prototype.map = function(fun /*, thisArg */) {                                                                 // 9266
			if (this === void 0 || this === null || typeof fun !== "function")                                                  // 9267
				throw new TypeError();                                                                                             // 9268
                                                                                                                       // 9269
			var t = Object(this), len = t.length >>> 0, res = new Array(len);                                                   // 9270
			var thisArg = arguments.length > 1 ? arguments[1] : void 0;                                                         // 9271
			for (var i = 0; i < len; i++) {                                                                                     // 9272
				// NOTE: Absolute correctness would demand Object.defineProperty                                                   // 9273
				//       be used.  But this method is fairly new, and failure is                                                   // 9274
				//       possible only if Object.prototype or Array.prototype                                                      // 9275
				//       has a property |i| (very unlikely), so use a less-correct                                                 // 9276
				//       but more portable alternative.                                                                            // 9277
				if (i in t)                                                                                                        // 9278
					res[i] = fun.call(thisArg, t[i], i, t);                                                                           // 9279
			}                                                                                                                   // 9280
                                                                                                                       // 9281
			return res;                                                                                                         // 9282
		};                                                                                                                   // 9283
	}                                                                                                                     // 9284
                                                                                                                       // 9285
                                                                                                                       // 9286
	if(!Array.isArray) {                                                                                                  // 9287
		Array.isArray = function(arg) {                                                                                      // 9288
			return Object.prototype.toString.call(arg) === '[object Array]';                                                    // 9289
		};                                                                                                                   // 9290
	}                                                                                                                     // 9291
                                                                                                                       // 9292
	if (!Array.prototype.forEach) {                                                                                       // 9293
		Array.prototype.forEach = function(fun, thisArg) {                                                                   // 9294
			"use strict";                                                                                                       // 9295
                                                                                                                       // 9296
			if (this === void 0 || this === null || typeof fun !== "function")                                                  // 9297
				throw new TypeError();                                                                                             // 9298
                                                                                                                       // 9299
			var t = Object(this), len = t.length >>> 0;                                                                         // 9300
			for (var i = 0; i < len; i++) {                                                                                     // 9301
				if (i in t)                                                                                                        // 9302
					fun.call(thisArg, t[i], i, t);                                                                                    // 9303
			}                                                                                                                   // 9304
		};                                                                                                                   // 9305
	}                                                                                                                     // 9306
                                                                                                                       // 9307
	if (!Object.keys) {                                                                                                   // 9308
		Object.keys = (function () {                                                                                         // 9309
			'use strict';                                                                                                       // 9310
                                                                                                                       // 9311
			var hasOwnProperty = Object.prototype.hasOwnProperty,                                                               // 9312
				hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),                                             // 9313
				dontEnums = ['toString','toLocaleString','valueOf','hasOwnProperty',                                               // 9314
					'isPrototypeOf','propertyIsEnumerable','constructor'],                                                            // 9315
				dontEnumsLength = dontEnums.length;                                                                                // 9316
                                                                                                                       // 9317
			return function (obj) {                                                                                             // 9318
				if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {                                      // 9319
					throw new TypeError();                                                                                            // 9320
				}                                                                                                                  // 9321
				var result = [], prop, i;                                                                                          // 9322
                                                                                                                       // 9323
				for (prop in obj) {                                                                                                // 9324
					if (hasOwnProperty.call(obj, prop)) {                                                                             // 9325
						result.push(prop);                                                                                               // 9326
					}                                                                                                                 // 9327
				}                                                                                                                  // 9328
                                                                                                                       // 9329
				if (hasDontEnumBug) {                                                                                              // 9330
					for (i = 0; i < dontEnumsLength; i++) {                                                                           // 9331
						if (hasOwnProperty.call(obj, dontEnums[i])) {                                                                    // 9332
							result.push(dontEnums[i]);                                                                                      // 9333
						}                                                                                                                // 9334
					}                                                                                                                 // 9335
				}                                                                                                                  // 9336
				return result;                                                                                                     // 9337
			};                                                                                                                  // 9338
		}());                                                                                                                // 9339
	}                                                                                                                     // 9340
                                                                                                                       // 9341
	if (!String.prototype.trim) {                                                                                         // 9342
		String.prototype.trim = function () {                                                                                // 9343
			return this.replace(/^\s+|\s+$/g, '');                                                                              // 9344
		};                                                                                                                   // 9345
	}                                                                                                                     // 9346
	if (!String.prototype.trimLeft) {                                                                                     // 9347
		String.prototype.trimLeft = function() {                                                                             // 9348
			return this.replace(/^\s+/g, "");                                                                                   // 9349
		};                                                                                                                   // 9350
	}                                                                                                                     // 9351
	if (!String.prototype.trimRight) {                                                                                    // 9352
		String.prototype.trimRight = function() {                                                                            // 9353
			return this.replace(/\s+$/g, "");                                                                                   // 9354
		};                                                                                                                   // 9355
	}                                                                                                                     // 9356
                                                                                                                       // 9357
})(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this);                            // 9358
                                                                                                                       // 9359
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);

///////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['chipcastledotcom:jspdf'] = {};

})();
